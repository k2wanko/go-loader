/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 0;\n\n\n//////////////////\n// WEBPACK FOOTER\n// .\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///.?");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, module) {var require;\n(function() {\n\nError.stackTraceLimit = Infinity;\n\nvar $global, $module;\nif (typeof window !== \"undefined\") { /* web page */\n  $global = window;\n} else if (typeof self !== \"undefined\") { /* web worker */\n  $global = self;\n} else if (typeof global !== \"undefined\") { /* Node.js */\n  $global = global;\n  $global.require = !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\".\\\"\"); e.code = 'MODULE_NOT_FOUND';; throw e; }());\n} else { /* others (e.g. Nashorn) */\n  $global = this;\n}\n\nif ($global === undefined || $global.Array === undefined) {\n  throw new Error(\"no global object found\");\n}\nif (true) {\n  $module = module;\n}\n\nvar $packages = {}, $idCounter = 0;\nvar $keys = function(m) { return m ? Object.keys(m) : []; };\nvar $flushConsole = function() {};\nvar $throwRuntimeError; /* set by package \"runtime\" */\nvar $throwNilPointerError = function() { $throwRuntimeError(\"invalid memory address or nil pointer dereference\"); };\nvar $call = function(fn, rcvr, args) { return fn.apply(rcvr, args); };\nvar $makeFunc = function(fn) { return function() { return $externalize(fn(this, new ($sliceType($jsObjectPtr))($global.Array.prototype.slice.call(arguments, []))), $emptyInterface); }; };\nvar $unused = function(v) {};\n\nvar $mapArray = function(array, f) {\n  var newArray = new array.constructor(array.length);\n  for (var i = 0; i < array.length; i++) {\n    newArray[i] = f(array[i]);\n  }\n  return newArray;\n};\n\nvar $methodVal = function(recv, name) {\n  var vals = recv.$methodVals || {};\n  recv.$methodVals = vals; /* noop for primitives */\n  var f = vals[name];\n  if (f !== undefined) {\n    return f;\n  }\n  var method = recv[name];\n  f = function() {\n    $stackDepthOffset--;\n    try {\n      return method.apply(recv, arguments);\n    } finally {\n      $stackDepthOffset++;\n    }\n  };\n  vals[name] = f;\n  return f;\n};\n\nvar $methodExpr = function(typ, name) {\n  var method = typ.prototype[name];\n  if (method.$expr === undefined) {\n    method.$expr = function() {\n      $stackDepthOffset--;\n      try {\n        if (typ.wrapped) {\n          arguments[0] = new typ(arguments[0]);\n        }\n        return Function.call.apply(method, arguments);\n      } finally {\n        $stackDepthOffset++;\n      }\n    };\n  }\n  return method.$expr;\n};\n\nvar $ifaceMethodExprs = {};\nvar $ifaceMethodExpr = function(name) {\n  var expr = $ifaceMethodExprs[\"$\" + name];\n  if (expr === undefined) {\n    expr = $ifaceMethodExprs[\"$\" + name] = function() {\n      $stackDepthOffset--;\n      try {\n        return Function.call.apply(arguments[0][name], arguments);\n      } finally {\n        $stackDepthOffset++;\n      }\n    };\n  }\n  return expr;\n};\n\nvar $subslice = function(slice, low, high, max) {\n  if (low < 0 || high < low || max < high || high > slice.$capacity || max > slice.$capacity) {\n    $throwRuntimeError(\"slice bounds out of range\");\n  }\n  var s = new slice.constructor(slice.$array);\n  s.$offset = slice.$offset + low;\n  s.$length = slice.$length - low;\n  s.$capacity = slice.$capacity - low;\n  if (high !== undefined) {\n    s.$length = high - low;\n  }\n  if (max !== undefined) {\n    s.$capacity = max - low;\n  }\n  return s;\n};\n\nvar $substring = function(str, low, high) {\n  if (low < 0 || high < low || high > str.length) {\n    $throwRuntimeError(\"slice bounds out of range\");\n  }\n  return str.substring(low, high);\n};\n\nvar $sliceToArray = function(slice) {\n  if (slice.$length === 0) {\n    return [];\n  }\n  if (slice.$array.constructor !== Array) {\n    return slice.$array.subarray(slice.$offset, slice.$offset + slice.$length);\n  }\n  return slice.$array.slice(slice.$offset, slice.$offset + slice.$length);\n};\n\nvar $decodeRune = function(str, pos) {\n  var c0 = str.charCodeAt(pos);\n\n  if (c0 < 0x80) {\n    return [c0, 1];\n  }\n\n  if (c0 !== c0 || c0 < 0xC0) {\n    return [0xFFFD, 1];\n  }\n\n  var c1 = str.charCodeAt(pos + 1);\n  if (c1 !== c1 || c1 < 0x80 || 0xC0 <= c1) {\n    return [0xFFFD, 1];\n  }\n\n  if (c0 < 0xE0) {\n    var r = (c0 & 0x1F) << 6 | (c1 & 0x3F);\n    if (r <= 0x7F) {\n      return [0xFFFD, 1];\n    }\n    return [r, 2];\n  }\n\n  var c2 = str.charCodeAt(pos + 2);\n  if (c2 !== c2 || c2 < 0x80 || 0xC0 <= c2) {\n    return [0xFFFD, 1];\n  }\n\n  if (c0 < 0xF0) {\n    var r = (c0 & 0x0F) << 12 | (c1 & 0x3F) << 6 | (c2 & 0x3F);\n    if (r <= 0x7FF) {\n      return [0xFFFD, 1];\n    }\n    if (0xD800 <= r && r <= 0xDFFF) {\n      return [0xFFFD, 1];\n    }\n    return [r, 3];\n  }\n\n  var c3 = str.charCodeAt(pos + 3);\n  if (c3 !== c3 || c3 < 0x80 || 0xC0 <= c3) {\n    return [0xFFFD, 1];\n  }\n\n  if (c0 < 0xF8) {\n    var r = (c0 & 0x07) << 18 | (c1 & 0x3F) << 12 | (c2 & 0x3F) << 6 | (c3 & 0x3F);\n    if (r <= 0xFFFF || 0x10FFFF < r) {\n      return [0xFFFD, 1];\n    }\n    return [r, 4];\n  }\n\n  return [0xFFFD, 1];\n};\n\nvar $encodeRune = function(r) {\n  if (r < 0 || r > 0x10FFFF || (0xD800 <= r && r <= 0xDFFF)) {\n    r = 0xFFFD;\n  }\n  if (r <= 0x7F) {\n    return String.fromCharCode(r);\n  }\n  if (r <= 0x7FF) {\n    return String.fromCharCode(0xC0 | r >> 6, 0x80 | (r & 0x3F));\n  }\n  if (r <= 0xFFFF) {\n    return String.fromCharCode(0xE0 | r >> 12, 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));\n  }\n  return String.fromCharCode(0xF0 | r >> 18, 0x80 | (r >> 12 & 0x3F), 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));\n};\n\nvar $stringToBytes = function(str) {\n  var array = new Uint8Array(str.length);\n  for (var i = 0; i < str.length; i++) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n};\n\nvar $bytesToString = function(slice) {\n  if (slice.$length === 0) {\n    return \"\";\n  }\n  var str = \"\";\n  for (var i = 0; i < slice.$length; i += 10000) {\n    str += String.fromCharCode.apply(undefined, slice.$array.subarray(slice.$offset + i, slice.$offset + Math.min(slice.$length, i + 10000)));\n  }\n  return str;\n};\n\nvar $stringToRunes = function(str) {\n  var array = new Int32Array(str.length);\n  var rune, j = 0;\n  for (var i = 0; i < str.length; i += rune[1], j++) {\n    rune = $decodeRune(str, i);\n    array[j] = rune[0];\n  }\n  return array.subarray(0, j);\n};\n\nvar $runesToString = function(slice) {\n  if (slice.$length === 0) {\n    return \"\";\n  }\n  var str = \"\";\n  for (var i = 0; i < slice.$length; i++) {\n    str += $encodeRune(slice.$array[slice.$offset + i]);\n  }\n  return str;\n};\n\nvar $copyString = function(dst, src) {\n  var n = Math.min(src.length, dst.$length);\n  for (var i = 0; i < n; i++) {\n    dst.$array[dst.$offset + i] = src.charCodeAt(i);\n  }\n  return n;\n};\n\nvar $copySlice = function(dst, src) {\n  var n = Math.min(src.$length, dst.$length);\n  $copyArray(dst.$array, src.$array, dst.$offset, src.$offset, n, dst.constructor.elem);\n  return n;\n};\n\nvar $copyArray = function(dst, src, dstOffset, srcOffset, n, elem) {\n  if (n === 0 || (dst === src && dstOffset === srcOffset)) {\n    return;\n  }\n\n  if (src.subarray) {\n    dst.set(src.subarray(srcOffset, srcOffset + n), dstOffset);\n    return;\n  }\n\n  switch (elem.kind) {\n  case $kindArray:\n  case $kindStruct:\n    if (dst === src && dstOffset > srcOffset) {\n      for (var i = n - 1; i >= 0; i--) {\n        elem.copy(dst[dstOffset + i], src[srcOffset + i]);\n      }\n      return;\n    }\n    for (var i = 0; i < n; i++) {\n      elem.copy(dst[dstOffset + i], src[srcOffset + i]);\n    }\n    return;\n  }\n\n  if (dst === src && dstOffset > srcOffset) {\n    for (var i = n - 1; i >= 0; i--) {\n      dst[dstOffset + i] = src[srcOffset + i];\n    }\n    return;\n  }\n  for (var i = 0; i < n; i++) {\n    dst[dstOffset + i] = src[srcOffset + i];\n  }\n};\n\nvar $clone = function(src, type) {\n  var clone = type.zero();\n  type.copy(clone, src);\n  return clone;\n};\n\nvar $pointerOfStructConversion = function(obj, type) {\n  if(obj.$proxies === undefined) {\n    obj.$proxies = {};\n    obj.$proxies[obj.constructor.string] = obj;\n  }\n  var proxy = obj.$proxies[type.string];\n  if (proxy === undefined) {\n    var properties = {};\n    for (var i = 0; i < type.elem.fields.length; i++) {\n      (function(fieldProp) {\n        properties[fieldProp] = {\n          get: function() { return obj[fieldProp]; },\n          set: function(value) { obj[fieldProp] = value; }\n        };\n      })(type.elem.fields[i].prop);\n    }\n    proxy = Object.create(type.prototype, properties);\n    proxy.$val = proxy;\n    obj.$proxies[type.string] = proxy;\n    proxy.$proxies = obj.$proxies;\n  }\n  return proxy;\n};\n\nvar $append = function(slice) {\n  return $internalAppend(slice, arguments, 1, arguments.length - 1);\n};\n\nvar $appendSlice = function(slice, toAppend) {\n  if (toAppend.constructor === String) {\n    var bytes = $stringToBytes(toAppend);\n    return $internalAppend(slice, bytes, 0, bytes.length);\n  }\n  return $internalAppend(slice, toAppend.$array, toAppend.$offset, toAppend.$length);\n};\n\nvar $internalAppend = function(slice, array, offset, length) {\n  if (length === 0) {\n    return slice;\n  }\n\n  var newArray = slice.$array;\n  var newOffset = slice.$offset;\n  var newLength = slice.$length + length;\n  var newCapacity = slice.$capacity;\n\n  if (newLength > newCapacity) {\n    newOffset = 0;\n    newCapacity = Math.max(newLength, slice.$capacity < 1024 ? slice.$capacity * 2 : Math.floor(slice.$capacity * 5 / 4));\n\n    if (slice.$array.constructor === Array) {\n      newArray = slice.$array.slice(slice.$offset, slice.$offset + slice.$length);\n      newArray.length = newCapacity;\n      var zero = slice.constructor.elem.zero;\n      for (var i = slice.$length; i < newCapacity; i++) {\n        newArray[i] = zero();\n      }\n    } else {\n      newArray = new slice.$array.constructor(newCapacity);\n      newArray.set(slice.$array.subarray(slice.$offset, slice.$offset + slice.$length));\n    }\n  }\n\n  $copyArray(newArray, array, newOffset + slice.$length, offset, length, slice.constructor.elem);\n\n  var newSlice = new slice.constructor(newArray);\n  newSlice.$offset = newOffset;\n  newSlice.$length = newLength;\n  newSlice.$capacity = newCapacity;\n  return newSlice;\n};\n\nvar $equal = function(a, b, type) {\n  if (type === $jsObjectPtr) {\n    return a === b;\n  }\n  switch (type.kind) {\n  case $kindComplex64:\n  case $kindComplex128:\n    return a.$real === b.$real && a.$imag === b.$imag;\n  case $kindInt64:\n  case $kindUint64:\n    return a.$high === b.$high && a.$low === b.$low;\n  case $kindArray:\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (var i = 0; i < a.length; i++) {\n      if (!$equal(a[i], b[i], type.elem)) {\n        return false;\n      }\n    }\n    return true;\n  case $kindStruct:\n    for (var i = 0; i < type.fields.length; i++) {\n      var f = type.fields[i];\n      if (!$equal(a[f.prop], b[f.prop], f.typ)) {\n        return false;\n      }\n    }\n    return true;\n  case $kindInterface:\n    return $interfaceIsEqual(a, b);\n  default:\n    return a === b;\n  }\n};\n\nvar $interfaceIsEqual = function(a, b) {\n  if (a === $ifaceNil || b === $ifaceNil) {\n    return a === b;\n  }\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n  if (a.constructor === $jsObjectPtr) {\n    return a.object === b.object;\n  }\n  if (!a.constructor.comparable) {\n    $throwRuntimeError(\"comparing uncomparable type \" + a.constructor.string);\n  }\n  return $equal(a.$val, b.$val, a.constructor);\n};\n\nvar $min = Math.min;\nvar $mod = function(x, y) { return x % y; };\nvar $parseInt = parseInt;\nvar $parseFloat = function(f) {\n  if (f !== undefined && f !== null && f.constructor === Number) {\n    return f;\n  }\n  return parseFloat(f);\n};\n\nvar $froundBuf = new Float32Array(1);\nvar $fround = Math.fround || function(f) {\n  $froundBuf[0] = f;\n  return $froundBuf[0];\n};\n\nvar $imul = Math.imul || function(a, b) {\n  var ah = (a >>> 16) & 0xffff;\n  var al = a & 0xffff;\n  var bh = (b >>> 16) & 0xffff;\n  var bl = b & 0xffff;\n  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) >> 0);\n};\n\nvar $floatKey = function(f) {\n  if (f !== f) {\n    $idCounter++;\n    return \"NaN$\" + $idCounter;\n  }\n  return String(f);\n};\n\nvar $flatten64 = function(x) {\n  return x.$high * 4294967296 + x.$low;\n};\n\nvar $shiftLeft64 = function(x, y) {\n  if (y === 0) {\n    return x;\n  }\n  if (y < 32) {\n    return new x.constructor(x.$high << y | x.$low >>> (32 - y), (x.$low << y) >>> 0);\n  }\n  if (y < 64) {\n    return new x.constructor(x.$low << (y - 32), 0);\n  }\n  return new x.constructor(0, 0);\n};\n\nvar $shiftRightInt64 = function(x, y) {\n  if (y === 0) {\n    return x;\n  }\n  if (y < 32) {\n    return new x.constructor(x.$high >> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);\n  }\n  if (y < 64) {\n    return new x.constructor(x.$high >> 31, (x.$high >> (y - 32)) >>> 0);\n  }\n  if (x.$high < 0) {\n    return new x.constructor(-1, 4294967295);\n  }\n  return new x.constructor(0, 0);\n};\n\nvar $shiftRightUint64 = function(x, y) {\n  if (y === 0) {\n    return x;\n  }\n  if (y < 32) {\n    return new x.constructor(x.$high >>> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);\n  }\n  if (y < 64) {\n    return new x.constructor(0, x.$high >>> (y - 32));\n  }\n  return new x.constructor(0, 0);\n};\n\nvar $mul64 = function(x, y) {\n  var high = 0, low = 0;\n  if ((y.$low & 1) !== 0) {\n    high = x.$high;\n    low = x.$low;\n  }\n  for (var i = 1; i < 32; i++) {\n    if ((y.$low & 1<<i) !== 0) {\n      high += x.$high << i | x.$low >>> (32 - i);\n      low += (x.$low << i) >>> 0;\n    }\n  }\n  for (var i = 0; i < 32; i++) {\n    if ((y.$high & 1<<i) !== 0) {\n      high += x.$low << i;\n    }\n  }\n  return new x.constructor(high, low);\n};\n\nvar $div64 = function(x, y, returnRemainder) {\n  if (y.$high === 0 && y.$low === 0) {\n    $throwRuntimeError(\"integer divide by zero\");\n  }\n\n  var s = 1;\n  var rs = 1;\n\n  var xHigh = x.$high;\n  var xLow = x.$low;\n  if (xHigh < 0) {\n    s = -1;\n    rs = -1;\n    xHigh = -xHigh;\n    if (xLow !== 0) {\n      xHigh--;\n      xLow = 4294967296 - xLow;\n    }\n  }\n\n  var yHigh = y.$high;\n  var yLow = y.$low;\n  if (y.$high < 0) {\n    s *= -1;\n    yHigh = -yHigh;\n    if (yLow !== 0) {\n      yHigh--;\n      yLow = 4294967296 - yLow;\n    }\n  }\n\n  var high = 0, low = 0, n = 0;\n  while (yHigh < 2147483648 && ((xHigh > yHigh) || (xHigh === yHigh && xLow > yLow))) {\n    yHigh = (yHigh << 1 | yLow >>> 31) >>> 0;\n    yLow = (yLow << 1) >>> 0;\n    n++;\n  }\n  for (var i = 0; i <= n; i++) {\n    high = high << 1 | low >>> 31;\n    low = (low << 1) >>> 0;\n    if ((xHigh > yHigh) || (xHigh === yHigh && xLow >= yLow)) {\n      xHigh = xHigh - yHigh;\n      xLow = xLow - yLow;\n      if (xLow < 0) {\n        xHigh--;\n        xLow += 4294967296;\n      }\n      low++;\n      if (low === 4294967296) {\n        high++;\n        low = 0;\n      }\n    }\n    yLow = (yLow >>> 1 | yHigh << (32 - 1)) >>> 0;\n    yHigh = yHigh >>> 1;\n  }\n\n  if (returnRemainder) {\n    return new x.constructor(xHigh * rs, xLow * rs);\n  }\n  return new x.constructor(high * s, low * s);\n};\n\nvar $divComplex = function(n, d) {\n  var ninf = n.$real === Infinity || n.$real === -Infinity || n.$imag === Infinity || n.$imag === -Infinity;\n  var dinf = d.$real === Infinity || d.$real === -Infinity || d.$imag === Infinity || d.$imag === -Infinity;\n  var nnan = !ninf && (n.$real !== n.$real || n.$imag !== n.$imag);\n  var dnan = !dinf && (d.$real !== d.$real || d.$imag !== d.$imag);\n  if(nnan || dnan) {\n    return new n.constructor(NaN, NaN);\n  }\n  if (ninf && !dinf) {\n    return new n.constructor(Infinity, Infinity);\n  }\n  if (!ninf && dinf) {\n    return new n.constructor(0, 0);\n  }\n  if (d.$real === 0 && d.$imag === 0) {\n    if (n.$real === 0 && n.$imag === 0) {\n      return new n.constructor(NaN, NaN);\n    }\n    return new n.constructor(Infinity, Infinity);\n  }\n  var a = Math.abs(d.$real);\n  var b = Math.abs(d.$imag);\n  if (a <= b) {\n    var ratio = d.$real / d.$imag;\n    var denom = d.$real * ratio + d.$imag;\n    return new n.constructor((n.$real * ratio + n.$imag) / denom, (n.$imag * ratio - n.$real) / denom);\n  }\n  var ratio = d.$imag / d.$real;\n  var denom = d.$imag * ratio + d.$real;\n  return new n.constructor((n.$imag * ratio + n.$real) / denom, (n.$imag - n.$real * ratio) / denom);\n};\n\nvar $kindBool = 1;\nvar $kindInt = 2;\nvar $kindInt8 = 3;\nvar $kindInt16 = 4;\nvar $kindInt32 = 5;\nvar $kindInt64 = 6;\nvar $kindUint = 7;\nvar $kindUint8 = 8;\nvar $kindUint16 = 9;\nvar $kindUint32 = 10;\nvar $kindUint64 = 11;\nvar $kindUintptr = 12;\nvar $kindFloat32 = 13;\nvar $kindFloat64 = 14;\nvar $kindComplex64 = 15;\nvar $kindComplex128 = 16;\nvar $kindArray = 17;\nvar $kindChan = 18;\nvar $kindFunc = 19;\nvar $kindInterface = 20;\nvar $kindMap = 21;\nvar $kindPtr = 22;\nvar $kindSlice = 23;\nvar $kindString = 24;\nvar $kindStruct = 25;\nvar $kindUnsafePointer = 26;\n\nvar $methodSynthesizers = [];\nvar $addMethodSynthesizer = function(f) {\n  if ($methodSynthesizers === null) {\n    f();\n    return;\n  }\n  $methodSynthesizers.push(f);\n};\nvar $synthesizeMethods = function() {\n  $methodSynthesizers.forEach(function(f) { f(); });\n  $methodSynthesizers = null;\n};\n\nvar $ifaceKeyFor = function(x) {\n  if (x === $ifaceNil) {\n    return 'nil';\n  }\n  var c = x.constructor;\n  return c.string + '$' + c.keyFor(x.$val);\n};\n\nvar $identity = function(x) { return x; };\n\nvar $typeIDCounter = 0;\n\nvar $idKey = function(x) {\n  if (x.$id === undefined) {\n    $idCounter++;\n    x.$id = $idCounter;\n  }\n  return String(x.$id);\n};\n\nvar $newType = function(size, kind, string, named, pkg, exported, constructor) {\n  var typ;\n  switch(kind) {\n  case $kindBool:\n  case $kindInt:\n  case $kindInt8:\n  case $kindInt16:\n  case $kindInt32:\n  case $kindUint:\n  case $kindUint8:\n  case $kindUint16:\n  case $kindUint32:\n  case $kindUintptr:\n  case $kindUnsafePointer:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.keyFor = $identity;\n    break;\n\n  case $kindString:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.keyFor = function(x) { return \"$\" + x; };\n    break;\n\n  case $kindFloat32:\n  case $kindFloat64:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.keyFor = function(x) { return $floatKey(x); };\n    break;\n\n  case $kindInt64:\n    typ = function(high, low) {\n      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;\n      this.$low = low >>> 0;\n      this.$val = this;\n    };\n    typ.keyFor = function(x) { return x.$high + \"$\" + x.$low; };\n    break;\n\n  case $kindUint64:\n    typ = function(high, low) {\n      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;\n      this.$low = low >>> 0;\n      this.$val = this;\n    };\n    typ.keyFor = function(x) { return x.$high + \"$\" + x.$low; };\n    break;\n\n  case $kindComplex64:\n    typ = function(real, imag) {\n      this.$real = $fround(real);\n      this.$imag = $fround(imag);\n      this.$val = this;\n    };\n    typ.keyFor = function(x) { return x.$real + \"$\" + x.$imag; };\n    break;\n\n  case $kindComplex128:\n    typ = function(real, imag) {\n      this.$real = real;\n      this.$imag = imag;\n      this.$val = this;\n    };\n    typ.keyFor = function(x) { return x.$real + \"$\" + x.$imag; };\n    break;\n\n  case $kindArray:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.ptr = $newType(4, $kindPtr, \"*\" + string, false, \"\", false, function(array) {\n      this.$get = function() { return array; };\n      this.$set = function(v) { typ.copy(this, v); };\n      this.$val = array;\n    });\n    typ.init = function(elem, len) {\n      typ.elem = elem;\n      typ.len = len;\n      typ.comparable = elem.comparable;\n      typ.keyFor = function(x) {\n        return Array.prototype.join.call($mapArray(x, function(e) {\n          return String(elem.keyFor(e)).replace(/\\\\/g, \"\\\\\\\\\").replace(/\\$/g, \"\\\\$\");\n        }), \"$\");\n      };\n      typ.copy = function(dst, src) {\n        $copyArray(dst, src, 0, 0, src.length, elem);\n      };\n      typ.ptr.init(typ);\n      Object.defineProperty(typ.ptr.nil, \"nilCheck\", { get: $throwNilPointerError });\n    };\n    break;\n\n  case $kindChan:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.keyFor = $idKey;\n    typ.init = function(elem, sendOnly, recvOnly) {\n      typ.elem = elem;\n      typ.sendOnly = sendOnly;\n      typ.recvOnly = recvOnly;\n    };\n    break;\n\n  case $kindFunc:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.init = function(params, results, variadic) {\n      typ.params = params;\n      typ.results = results;\n      typ.variadic = variadic;\n      typ.comparable = false;\n    };\n    break;\n\n  case $kindInterface:\n    typ = { implementedBy: {}, missingMethodFor: {} };\n    typ.keyFor = $ifaceKeyFor;\n    typ.init = function(methods) {\n      typ.methods = methods;\n      methods.forEach(function(m) {\n        $ifaceNil[m.prop] = $throwNilPointerError;\n      });\n    };\n    break;\n\n  case $kindMap:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.init = function(key, elem) {\n      typ.key = key;\n      typ.elem = elem;\n      typ.comparable = false;\n    };\n    break;\n\n  case $kindPtr:\n    typ = constructor || function(getter, setter, target) {\n      this.$get = getter;\n      this.$set = setter;\n      this.$target = target;\n      this.$val = this;\n    };\n    typ.keyFor = $idKey;\n    typ.init = function(elem) {\n      typ.elem = elem;\n      typ.wrapped = (elem.kind === $kindArray);\n      typ.nil = new typ($throwNilPointerError, $throwNilPointerError);\n    };\n    break;\n\n  case $kindSlice:\n    typ = function(array) {\n      if (array.constructor !== typ.nativeArray) {\n        array = new typ.nativeArray(array);\n      }\n      this.$array = array;\n      this.$offset = 0;\n      this.$length = array.length;\n      this.$capacity = array.length;\n      this.$val = this;\n    };\n    typ.init = function(elem) {\n      typ.elem = elem;\n      typ.comparable = false;\n      typ.nativeArray = $nativeArray(elem.kind);\n      typ.nil = new typ([]);\n    };\n    break;\n\n  case $kindStruct:\n    typ = function(v) { this.$val = v; };\n    typ.wrapped = true;\n    typ.ptr = $newType(4, $kindPtr, \"*\" + string, false, \"\", exported, constructor);\n    typ.ptr.elem = typ;\n    typ.ptr.prototype.$get = function() { return this; };\n    typ.ptr.prototype.$set = function(v) { typ.copy(this, v); };\n    typ.init = function(pkgPath, fields) {\n      typ.pkgPath = pkgPath;\n      typ.fields = fields;\n      fields.forEach(function(f) {\n        if (!f.typ.comparable) {\n          typ.comparable = false;\n        }\n      });\n      typ.keyFor = function(x) {\n        var val = x.$val;\n        return $mapArray(fields, function(f) {\n          return String(f.typ.keyFor(val[f.prop])).replace(/\\\\/g, \"\\\\\\\\\").replace(/\\$/g, \"\\\\$\");\n        }).join(\"$\");\n      };\n      typ.copy = function(dst, src) {\n        for (var i = 0; i < fields.length; i++) {\n          var f = fields[i];\n          switch (f.typ.kind) {\n          case $kindArray:\n          case $kindStruct:\n            f.typ.copy(dst[f.prop], src[f.prop]);\n            continue;\n          default:\n            dst[f.prop] = src[f.prop];\n            continue;\n          }\n        }\n      };\n      /* nil value */\n      var properties = {};\n      fields.forEach(function(f) {\n        properties[f.prop] = { get: $throwNilPointerError, set: $throwNilPointerError };\n      });\n      typ.ptr.nil = Object.create(constructor.prototype, properties);\n      typ.ptr.nil.$val = typ.ptr.nil;\n      /* methods for embedded fields */\n      $addMethodSynthesizer(function() {\n        var synthesizeMethod = function(target, m, f) {\n          if (target.prototype[m.prop] !== undefined) { return; }\n          target.prototype[m.prop] = function() {\n            var v = this.$val[f.prop];\n            if (f.typ === $jsObjectPtr) {\n              v = new $jsObjectPtr(v);\n            }\n            if (v.$val === undefined) {\n              v = new f.typ(v);\n            }\n            return v[m.prop].apply(v, arguments);\n          };\n        };\n        fields.forEach(function(f) {\n          if (f.name === \"\") {\n            $methodSet(f.typ).forEach(function(m) {\n              synthesizeMethod(typ, m, f);\n              synthesizeMethod(typ.ptr, m, f);\n            });\n            $methodSet($ptrType(f.typ)).forEach(function(m) {\n              synthesizeMethod(typ.ptr, m, f);\n            });\n          }\n        });\n      });\n    };\n    break;\n\n  default:\n    $panic(new $String(\"invalid kind: \" + kind));\n  }\n\n  switch (kind) {\n  case $kindBool:\n  case $kindMap:\n    typ.zero = function() { return false; };\n    break;\n\n  case $kindInt:\n  case $kindInt8:\n  case $kindInt16:\n  case $kindInt32:\n  case $kindUint:\n  case $kindUint8 :\n  case $kindUint16:\n  case $kindUint32:\n  case $kindUintptr:\n  case $kindUnsafePointer:\n  case $kindFloat32:\n  case $kindFloat64:\n    typ.zero = function() { return 0; };\n    break;\n\n  case $kindString:\n    typ.zero = function() { return \"\"; };\n    break;\n\n  case $kindInt64:\n  case $kindUint64:\n  case $kindComplex64:\n  case $kindComplex128:\n    var zero = new typ(0, 0);\n    typ.zero = function() { return zero; };\n    break;\n\n  case $kindPtr:\n  case $kindSlice:\n    typ.zero = function() { return typ.nil; };\n    break;\n\n  case $kindChan:\n    typ.zero = function() { return $chanNil; };\n    break;\n\n  case $kindFunc:\n    typ.zero = function() { return $throwNilPointerError; };\n    break;\n\n  case $kindInterface:\n    typ.zero = function() { return $ifaceNil; };\n    break;\n\n  case $kindArray:\n    typ.zero = function() {\n      var arrayClass = $nativeArray(typ.elem.kind);\n      if (arrayClass !== Array) {\n        return new arrayClass(typ.len);\n      }\n      var array = new Array(typ.len);\n      for (var i = 0; i < typ.len; i++) {\n        array[i] = typ.elem.zero();\n      }\n      return array;\n    };\n    break;\n\n  case $kindStruct:\n    typ.zero = function() { return new typ.ptr(); };\n    break;\n\n  default:\n    $panic(new $String(\"invalid kind: \" + kind));\n  }\n\n  typ.id = $typeIDCounter;\n  $typeIDCounter++;\n  typ.size = size;\n  typ.kind = kind;\n  typ.string = string;\n  typ.named = named;\n  typ.pkg = pkg;\n  typ.exported = exported;\n  typ.methods = [];\n  typ.methodSetCache = null;\n  typ.comparable = true;\n  return typ;\n};\n\nvar $methodSet = function(typ) {\n  if (typ.methodSetCache !== null) {\n    return typ.methodSetCache;\n  }\n  var base = {};\n\n  var isPtr = (typ.kind === $kindPtr);\n  if (isPtr && typ.elem.kind === $kindInterface) {\n    typ.methodSetCache = [];\n    return [];\n  }\n\n  var current = [{typ: isPtr ? typ.elem : typ, indirect: isPtr}];\n\n  var seen = {};\n\n  while (current.length > 0) {\n    var next = [];\n    var mset = [];\n\n    current.forEach(function(e) {\n      if (seen[e.typ.string]) {\n        return;\n      }\n      seen[e.typ.string] = true;\n\n      if (e.typ.named) {\n        mset = mset.concat(e.typ.methods);\n        if (e.indirect) {\n          mset = mset.concat($ptrType(e.typ).methods);\n        }\n      }\n\n      switch (e.typ.kind) {\n      case $kindStruct:\n        e.typ.fields.forEach(function(f) {\n          if (f.name === \"\") {\n            var fTyp = f.typ;\n            var fIsPtr = (fTyp.kind === $kindPtr);\n            next.push({typ: fIsPtr ? fTyp.elem : fTyp, indirect: e.indirect || fIsPtr});\n          }\n        });\n        break;\n\n      case $kindInterface:\n        mset = mset.concat(e.typ.methods);\n        break;\n      }\n    });\n\n    mset.forEach(function(m) {\n      if (base[m.name] === undefined) {\n        base[m.name] = m;\n      }\n    });\n\n    current = next;\n  }\n\n  typ.methodSetCache = [];\n  Object.keys(base).sort().forEach(function(name) {\n    typ.methodSetCache.push(base[name]);\n  });\n  return typ.methodSetCache;\n};\n\nvar $Bool          = $newType( 1, $kindBool,          \"bool\",           true, \"\", false, null);\nvar $Int           = $newType( 4, $kindInt,           \"int\",            true, \"\", false, null);\nvar $Int8          = $newType( 1, $kindInt8,          \"int8\",           true, \"\", false, null);\nvar $Int16         = $newType( 2, $kindInt16,         \"int16\",          true, \"\", false, null);\nvar $Int32         = $newType( 4, $kindInt32,         \"int32\",          true, \"\", false, null);\nvar $Int64         = $newType( 8, $kindInt64,         \"int64\",          true, \"\", false, null);\nvar $Uint          = $newType( 4, $kindUint,          \"uint\",           true, \"\", false, null);\nvar $Uint8         = $newType( 1, $kindUint8,         \"uint8\",          true, \"\", false, null);\nvar $Uint16        = $newType( 2, $kindUint16,        \"uint16\",         true, \"\", false, null);\nvar $Uint32        = $newType( 4, $kindUint32,        \"uint32\",         true, \"\", false, null);\nvar $Uint64        = $newType( 8, $kindUint64,        \"uint64\",         true, \"\", false, null);\nvar $Uintptr       = $newType( 4, $kindUintptr,       \"uintptr\",        true, \"\", false, null);\nvar $Float32       = $newType( 4, $kindFloat32,       \"float32\",        true, \"\", false, null);\nvar $Float64       = $newType( 8, $kindFloat64,       \"float64\",        true, \"\", false, null);\nvar $Complex64     = $newType( 8, $kindComplex64,     \"complex64\",      true, \"\", false, null);\nvar $Complex128    = $newType(16, $kindComplex128,    \"complex128\",     true, \"\", false, null);\nvar $String        = $newType( 8, $kindString,        \"string\",         true, \"\", false, null);\nvar $UnsafePointer = $newType( 4, $kindUnsafePointer, \"unsafe.Pointer\", true, \"\", false, null);\n\nvar $nativeArray = function(elemKind) {\n  switch (elemKind) {\n  case $kindInt:\n    return Int32Array;\n  case $kindInt8:\n    return Int8Array;\n  case $kindInt16:\n    return Int16Array;\n  case $kindInt32:\n    return Int32Array;\n  case $kindUint:\n    return Uint32Array;\n  case $kindUint8:\n    return Uint8Array;\n  case $kindUint16:\n    return Uint16Array;\n  case $kindUint32:\n    return Uint32Array;\n  case $kindUintptr:\n    return Uint32Array;\n  case $kindFloat32:\n    return Float32Array;\n  case $kindFloat64:\n    return Float64Array;\n  default:\n    return Array;\n  }\n};\nvar $toNativeArray = function(elemKind, array) {\n  var nativeArray = $nativeArray(elemKind);\n  if (nativeArray === Array) {\n    return array;\n  }\n  return new nativeArray(array);\n};\nvar $arrayTypes = {};\nvar $arrayType = function(elem, len) {\n  var typeKey = elem.id + \"$\" + len;\n  var typ = $arrayTypes[typeKey];\n  if (typ === undefined) {\n    typ = $newType(12, $kindArray, \"[\" + len + \"]\" + elem.string, false, \"\", false, null);\n    $arrayTypes[typeKey] = typ;\n    typ.init(elem, len);\n  }\n  return typ;\n};\n\nvar $chanType = function(elem, sendOnly, recvOnly) {\n  var string = (recvOnly ? \"<-\" : \"\") + \"chan\" + (sendOnly ? \"<- \" : \" \") + elem.string;\n  var field = sendOnly ? \"SendChan\" : (recvOnly ? \"RecvChan\" : \"Chan\");\n  var typ = elem[field];\n  if (typ === undefined) {\n    typ = $newType(4, $kindChan, string, false, \"\", false, null);\n    elem[field] = typ;\n    typ.init(elem, sendOnly, recvOnly);\n  }\n  return typ;\n};\nvar $Chan = function(elem, capacity) {\n  if (capacity < 0 || capacity > 2147483647) {\n    $throwRuntimeError(\"makechan: size out of range\");\n  }\n  this.$elem = elem;\n  this.$capacity = capacity;\n  this.$buffer = [];\n  this.$sendQueue = [];\n  this.$recvQueue = [];\n  this.$closed = false;\n};\nvar $chanNil = new $Chan(null, 0);\n$chanNil.$sendQueue = $chanNil.$recvQueue = { length: 0, push: function() {}, shift: function() { return undefined; }, indexOf: function() { return -1; } };\n\nvar $funcTypes = {};\nvar $funcType = function(params, results, variadic) {\n  var typeKey = $mapArray(params, function(p) { return p.id; }).join(\",\") + \"$\" + $mapArray(results, function(r) { return r.id; }).join(\",\") + \"$\" + variadic;\n  var typ = $funcTypes[typeKey];\n  if (typ === undefined) {\n    var paramTypes = $mapArray(params, function(p) { return p.string; });\n    if (variadic) {\n      paramTypes[paramTypes.length - 1] = \"...\" + paramTypes[paramTypes.length - 1].substr(2);\n    }\n    var string = \"func(\" + paramTypes.join(\", \") + \")\";\n    if (results.length === 1) {\n      string += \" \" + results[0].string;\n    } else if (results.length > 1) {\n      string += \" (\" + $mapArray(results, function(r) { return r.string; }).join(\", \") + \")\";\n    }\n    typ = $newType(4, $kindFunc, string, false, \"\", false, null);\n    $funcTypes[typeKey] = typ;\n    typ.init(params, results, variadic);\n  }\n  return typ;\n};\n\nvar $interfaceTypes = {};\nvar $interfaceType = function(methods) {\n  var typeKey = $mapArray(methods, function(m) { return m.pkg + \",\" + m.name + \",\" + m.typ.id; }).join(\"$\");\n  var typ = $interfaceTypes[typeKey];\n  if (typ === undefined) {\n    var string = \"interface {}\";\n    if (methods.length !== 0) {\n      string = \"interface { \" + $mapArray(methods, function(m) {\n        return (m.pkg !== \"\" ? m.pkg + \".\" : \"\") + m.name + m.typ.string.substr(4);\n      }).join(\"; \") + \" }\";\n    }\n    typ = $newType(8, $kindInterface, string, false, \"\", false, null);\n    $interfaceTypes[typeKey] = typ;\n    typ.init(methods);\n  }\n  return typ;\n};\nvar $emptyInterface = $interfaceType([]);\nvar $ifaceNil = {};\nvar $error = $newType(8, $kindInterface, \"error\", true, \"\", false, null);\n$error.init([{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}]);\n\nvar $mapTypes = {};\nvar $mapType = function(key, elem) {\n  var typeKey = key.id + \"$\" + elem.id;\n  var typ = $mapTypes[typeKey];\n  if (typ === undefined) {\n    typ = $newType(4, $kindMap, \"map[\" + key.string + \"]\" + elem.string, false, \"\", false, null);\n    $mapTypes[typeKey] = typ;\n    typ.init(key, elem);\n  }\n  return typ;\n};\nvar $makeMap = function(keyForFunc, entries) {\n  var m = {};\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n    m[keyForFunc(e.k)] = e;\n  }\n  return m;\n};\n\nvar $ptrType = function(elem) {\n  var typ = elem.ptr;\n  if (typ === undefined) {\n    typ = $newType(4, $kindPtr, \"*\" + elem.string, false, \"\", elem.exported, null);\n    elem.ptr = typ;\n    typ.init(elem);\n  }\n  return typ;\n};\n\nvar $newDataPointer = function(data, constructor) {\n  if (constructor.elem.kind === $kindStruct) {\n    return data;\n  }\n  return new constructor(function() { return data; }, function(v) { data = v; });\n};\n\nvar $indexPtr = function(array, index, constructor) {\n  array.$ptr = array.$ptr || {};\n  return array.$ptr[index] || (array.$ptr[index] = new constructor(function() { return array[index]; }, function(v) { array[index] = v; }));\n};\n\nvar $sliceType = function(elem) {\n  var typ = elem.slice;\n  if (typ === undefined) {\n    typ = $newType(12, $kindSlice, \"[]\" + elem.string, false, \"\", false, null);\n    elem.slice = typ;\n    typ.init(elem);\n  }\n  return typ;\n};\nvar $makeSlice = function(typ, length, capacity) {\n  capacity = capacity || length;\n  if (length < 0 || length > 2147483647) {\n    $throwRuntimeError(\"makeslice: len out of range\");\n  }\n  if (capacity < 0 || capacity < length || capacity > 2147483647) {\n    $throwRuntimeError(\"makeslice: cap out of range\");\n  }\n  var array = new typ.nativeArray(capacity);\n  if (typ.nativeArray === Array) {\n    for (var i = 0; i < capacity; i++) {\n      array[i] = typ.elem.zero();\n    }\n  }\n  var slice = new typ(array);\n  slice.$length = length;\n  return slice;\n};\n\nvar $structTypes = {};\nvar $structType = function(pkgPath, fields) {\n  var typeKey = $mapArray(fields, function(f) { return f.name + \",\" + f.typ.id + \",\" + f.tag; }).join(\"$\");\n  var typ = $structTypes[typeKey];\n  if (typ === undefined) {\n    var string = \"struct { \" + $mapArray(fields, function(f) {\n      return f.name + \" \" + f.typ.string + (f.tag !== \"\" ? (\" \\\"\" + f.tag.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\") + \"\\\"\") : \"\");\n    }).join(\"; \") + \" }\";\n    if (fields.length === 0) {\n      string = \"struct {}\";\n    }\n    typ = $newType(0, $kindStruct, string, false, \"\", false, function() {\n      this.$val = this;\n      for (var i = 0; i < fields.length; i++) {\n        var f = fields[i];\n        var arg = arguments[i];\n        this[f.prop] = arg !== undefined ? arg : f.typ.zero();\n      }\n    });\n    $structTypes[typeKey] = typ;\n    typ.init(pkgPath, fields);\n  }\n  return typ;\n};\n\nvar $assertType = function(value, type, returnTuple) {\n  var isInterface = (type.kind === $kindInterface), ok, missingMethod = \"\";\n  if (value === $ifaceNil) {\n    ok = false;\n  } else if (!isInterface) {\n    ok = value.constructor === type;\n  } else {\n    var valueTypeString = value.constructor.string;\n    ok = type.implementedBy[valueTypeString];\n    if (ok === undefined) {\n      ok = true;\n      var valueMethodSet = $methodSet(value.constructor);\n      var interfaceMethods = type.methods;\n      for (var i = 0; i < interfaceMethods.length; i++) {\n        var tm = interfaceMethods[i];\n        var found = false;\n        for (var j = 0; j < valueMethodSet.length; j++) {\n          var vm = valueMethodSet[j];\n          if (vm.name === tm.name && vm.pkg === tm.pkg && vm.typ === tm.typ) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          ok = false;\n          type.missingMethodFor[valueTypeString] = tm.name;\n          break;\n        }\n      }\n      type.implementedBy[valueTypeString] = ok;\n    }\n    if (!ok) {\n      missingMethod = type.missingMethodFor[valueTypeString];\n    }\n  }\n\n  if (!ok) {\n    if (returnTuple) {\n      return [type.zero(), false];\n    }\n    $panic(new $packages[\"runtime\"].TypeAssertionError.ptr(\"\", (value === $ifaceNil ? \"\" : value.constructor.string), type.string, missingMethod));\n  }\n\n  if (!isInterface) {\n    value = value.$val;\n  }\n  if (type === $jsObjectPtr) {\n    value = value.object;\n  }\n  return returnTuple ? [value, true] : value;\n};\n\nvar $stackDepthOffset = 0;\nvar $getStackDepth = function() {\n  var err = new Error();\n  if (err.stack === undefined) {\n    return undefined;\n  }\n  return $stackDepthOffset + err.stack.split(\"\\n\").length;\n};\n\nvar $panicStackDepth = null, $panicValue;\nvar $callDeferred = function(deferred, jsErr, fromPanic) {\n  if (!fromPanic && deferred !== null && deferred.index >= $curGoroutine.deferStack.length) {\n    throw jsErr;\n  }\n  if (jsErr !== null) {\n    var newErr = null;\n    try {\n      $curGoroutine.deferStack.push(deferred);\n      $panic(new $jsErrorPtr(jsErr));\n    } catch (err) {\n      newErr = err;\n    }\n    $curGoroutine.deferStack.pop();\n    $callDeferred(deferred, newErr);\n    return;\n  }\n  if ($curGoroutine.asleep) {\n    return;\n  }\n\n  $stackDepthOffset--;\n  var outerPanicStackDepth = $panicStackDepth;\n  var outerPanicValue = $panicValue;\n\n  var localPanicValue = $curGoroutine.panicStack.pop();\n  if (localPanicValue !== undefined) {\n    $panicStackDepth = $getStackDepth();\n    $panicValue = localPanicValue;\n  }\n\n  try {\n    while (true) {\n      if (deferred === null) {\n        deferred = $curGoroutine.deferStack[$curGoroutine.deferStack.length - 1];\n        if (deferred === undefined) {\n          /* The panic reached the top of the stack. Clear it and throw it as a JavaScript error. */\n          $panicStackDepth = null;\n          if (localPanicValue.Object instanceof Error) {\n            throw localPanicValue.Object;\n          }\n          var msg;\n          if (localPanicValue.constructor === $String) {\n            msg = localPanicValue.$val;\n          } else if (localPanicValue.Error !== undefined) {\n            msg = localPanicValue.Error();\n          } else if (localPanicValue.String !== undefined) {\n            msg = localPanicValue.String();\n          } else {\n            msg = localPanicValue;\n          }\n          throw new Error(msg);\n        }\n      }\n      var call = deferred.pop();\n      if (call === undefined) {\n        $curGoroutine.deferStack.pop();\n        if (localPanicValue !== undefined) {\n          deferred = null;\n          continue;\n        }\n        return;\n      }\n      var r = call[0].apply(call[2], call[1]);\n      if (r && r.$blk !== undefined) {\n        deferred.push([r.$blk, [], r]);\n        if (fromPanic) {\n          throw null;\n        }\n        return;\n      }\n\n      if (localPanicValue !== undefined && $panicStackDepth === null) {\n        throw null; /* error was recovered */\n      }\n    }\n  } finally {\n    if (localPanicValue !== undefined) {\n      if ($panicStackDepth !== null) {\n        $curGoroutine.panicStack.push(localPanicValue);\n      }\n      $panicStackDepth = outerPanicStackDepth;\n      $panicValue = outerPanicValue;\n    }\n    $stackDepthOffset++;\n  }\n};\n\nvar $panic = function(value) {\n  $curGoroutine.panicStack.push(value);\n  $callDeferred(null, null, true);\n};\nvar $recover = function() {\n  if ($panicStackDepth === null || ($panicStackDepth !== undefined && $panicStackDepth !== $getStackDepth() - 2)) {\n    return $ifaceNil;\n  }\n  $panicStackDepth = null;\n  return $panicValue;\n};\nvar $throw = function(err) { throw err; };\n\nvar $dummyGoroutine = { asleep: false, exit: false, deferStack: [], panicStack: [], canBlock: false };\nvar $curGoroutine = $dummyGoroutine, $totalGoroutines = 0, $awakeGoroutines = 0, $checkForDeadlock = true;\nvar $mainFinished = false;\nvar $go = function(fun, args, direct) {\n  $totalGoroutines++;\n  $awakeGoroutines++;\n  var $goroutine = function() {\n    try {\n      $curGoroutine = $goroutine;\n      var r = fun.apply(undefined, args);\n      if (r && r.$blk !== undefined) {\n        fun = function() { return r.$blk(); };\n        args = [];\n        return;\n      }\n      $goroutine.exit = true;\n    } catch (err) {\n      if (!$goroutine.exit) {\n        throw err;\n      }\n    } finally {\n      $curGoroutine = $dummyGoroutine;\n      if ($goroutine.exit) { /* also set by runtime.Goexit() */\n        $totalGoroutines--;\n        $goroutine.asleep = true;\n      }\n      if ($goroutine.asleep) {\n        $awakeGoroutines--;\n        if (!$mainFinished && $awakeGoroutines === 0 && $checkForDeadlock) {\n          console.error(\"fatal error: all goroutines are asleep - deadlock!\");\n          if ($global.process !== undefined) {\n            $global.process.exit(2);\n          }\n        }\n      }\n    }\n  };\n  $goroutine.asleep = false;\n  $goroutine.exit = false;\n  $goroutine.deferStack = [];\n  $goroutine.panicStack = [];\n  $goroutine.canBlock = true;\n  $schedule($goroutine, direct);\n};\n\nvar $scheduled = [], $schedulerActive = false;\nvar $runScheduled = function() {\n  try {\n    var r;\n    while ((r = $scheduled.shift()) !== undefined) {\n      r();\n    }\n    $schedulerActive = false;\n  } finally {\n    if ($schedulerActive) {\n      setTimeout($runScheduled, 0);\n    }\n  }\n};\nvar $schedule = function(goroutine, direct) {\n  if (goroutine.asleep) {\n    goroutine.asleep = false;\n    $awakeGoroutines++;\n  }\n\n  if (direct) {\n    goroutine();\n    return;\n  }\n\n  $scheduled.push(goroutine);\n  if (!$schedulerActive) {\n    $schedulerActive = true;\n    setTimeout($runScheduled, 0);\n  }\n};\n\nvar $setTimeout = function(f, t) {\n  $awakeGoroutines++;\n  return setTimeout(function() {\n    $awakeGoroutines--;\n    f();\n  }, t);\n};\n\nvar $block = function() {\n  if (!$curGoroutine.canBlock) {\n    $throwRuntimeError(\"cannot block in JavaScript callback, fix by wrapping code in goroutine\");\n  }\n  $curGoroutine.asleep = true;\n};\n\nvar $send = function(chan, value) {\n  if (chan.$closed) {\n    $throwRuntimeError(\"send on closed channel\");\n  }\n  var queuedRecv = chan.$recvQueue.shift();\n  if (queuedRecv !== undefined) {\n    queuedRecv([value, true]);\n    return;\n  }\n  if (chan.$buffer.length < chan.$capacity) {\n    chan.$buffer.push(value);\n    return;\n  }\n\n  var thisGoroutine = $curGoroutine;\n  var closedDuringSend;\n  chan.$sendQueue.push(function(closed) {\n    closedDuringSend = closed;\n    $schedule(thisGoroutine);\n    return value;\n  });\n  $block();\n  return {\n    $blk: function() {\n      if (closedDuringSend) {\n        $throwRuntimeError(\"send on closed channel\");\n      }\n    }\n  };\n};\nvar $recv = function(chan) {\n  var queuedSend = chan.$sendQueue.shift();\n  if (queuedSend !== undefined) {\n    chan.$buffer.push(queuedSend(false));\n  }\n  var bufferedValue = chan.$buffer.shift();\n  if (bufferedValue !== undefined) {\n    return [bufferedValue, true];\n  }\n  if (chan.$closed) {\n    return [chan.$elem.zero(), false];\n  }\n\n  var thisGoroutine = $curGoroutine;\n  var f = { $blk: function() { return this.value; } };\n  var queueEntry = function(v) {\n    f.value = v;\n    $schedule(thisGoroutine);\n  };\n  chan.$recvQueue.push(queueEntry);\n  $block();\n  return f;\n};\nvar $close = function(chan) {\n  if (chan.$closed) {\n    $throwRuntimeError(\"close of closed channel\");\n  }\n  chan.$closed = true;\n  while (true) {\n    var queuedSend = chan.$sendQueue.shift();\n    if (queuedSend === undefined) {\n      break;\n    }\n    queuedSend(true); /* will panic */\n  }\n  while (true) {\n    var queuedRecv = chan.$recvQueue.shift();\n    if (queuedRecv === undefined) {\n      break;\n    }\n    queuedRecv([chan.$elem.zero(), false]);\n  }\n};\nvar $select = function(comms) {\n  var ready = [];\n  var selection = -1;\n  for (var i = 0; i < comms.length; i++) {\n    var comm = comms[i];\n    var chan = comm[0];\n    switch (comm.length) {\n    case 0: /* default */\n      selection = i;\n      break;\n    case 1: /* recv */\n      if (chan.$sendQueue.length !== 0 || chan.$buffer.length !== 0 || chan.$closed) {\n        ready.push(i);\n      }\n      break;\n    case 2: /* send */\n      if (chan.$closed) {\n        $throwRuntimeError(\"send on closed channel\");\n      }\n      if (chan.$recvQueue.length !== 0 || chan.$buffer.length < chan.$capacity) {\n        ready.push(i);\n      }\n      break;\n    }\n  }\n\n  if (ready.length !== 0) {\n    selection = ready[Math.floor(Math.random() * ready.length)];\n  }\n  if (selection !== -1) {\n    var comm = comms[selection];\n    switch (comm.length) {\n    case 0: /* default */\n      return [selection];\n    case 1: /* recv */\n      return [selection, $recv(comm[0])];\n    case 2: /* send */\n      $send(comm[0], comm[1]);\n      return [selection];\n    }\n  }\n\n  var entries = [];\n  var thisGoroutine = $curGoroutine;\n  var f = { $blk: function() { return this.selection; } };\n  var removeFromQueues = function() {\n    for (var i = 0; i < entries.length; i++) {\n      var entry = entries[i];\n      var queue = entry[0];\n      var index = queue.indexOf(entry[1]);\n      if (index !== -1) {\n        queue.splice(index, 1);\n      }\n    }\n  };\n  for (var i = 0; i < comms.length; i++) {\n    (function(i) {\n      var comm = comms[i];\n      switch (comm.length) {\n      case 1: /* recv */\n        var queueEntry = function(value) {\n          f.selection = [i, value];\n          removeFromQueues();\n          $schedule(thisGoroutine);\n        };\n        entries.push([comm[0].$recvQueue, queueEntry]);\n        comm[0].$recvQueue.push(queueEntry);\n        break;\n      case 2: /* send */\n        var queueEntry = function() {\n          if (comm[0].$closed) {\n            $throwRuntimeError(\"send on closed channel\");\n          }\n          f.selection = [i];\n          removeFromQueues();\n          $schedule(thisGoroutine);\n          return comm[1];\n        };\n        entries.push([comm[0].$sendQueue, queueEntry]);\n        comm[0].$sendQueue.push(queueEntry);\n        break;\n      }\n    })(i);\n  }\n  $block();\n  return f;\n};\n\nvar $jsObjectPtr, $jsErrorPtr;\n\nvar $needsExternalization = function(t) {\n  switch (t.kind) {\n    case $kindBool:\n    case $kindInt:\n    case $kindInt8:\n    case $kindInt16:\n    case $kindInt32:\n    case $kindUint:\n    case $kindUint8:\n    case $kindUint16:\n    case $kindUint32:\n    case $kindUintptr:\n    case $kindFloat32:\n    case $kindFloat64:\n      return false;\n    default:\n      return t !== $jsObjectPtr;\n  }\n};\n\nvar $externalize = function(v, t) {\n  if (t === $jsObjectPtr) {\n    return v;\n  }\n  switch (t.kind) {\n  case $kindBool:\n  case $kindInt:\n  case $kindInt8:\n  case $kindInt16:\n  case $kindInt32:\n  case $kindUint:\n  case $kindUint8:\n  case $kindUint16:\n  case $kindUint32:\n  case $kindUintptr:\n  case $kindFloat32:\n  case $kindFloat64:\n    return v;\n  case $kindInt64:\n  case $kindUint64:\n    return $flatten64(v);\n  case $kindArray:\n    if ($needsExternalization(t.elem)) {\n      return $mapArray(v, function(e) { return $externalize(e, t.elem); });\n    }\n    return v;\n  case $kindFunc:\n    return $externalizeFunction(v, t, false);\n  case $kindInterface:\n    if (v === $ifaceNil) {\n      return null;\n    }\n    if (v.constructor === $jsObjectPtr) {\n      return v.$val.object;\n    }\n    return $externalize(v.$val, v.constructor);\n  case $kindMap:\n    var m = {};\n    var keys = $keys(v);\n    for (var i = 0; i < keys.length; i++) {\n      var entry = v[keys[i]];\n      m[$externalize(entry.k, t.key)] = $externalize(entry.v, t.elem);\n    }\n    return m;\n  case $kindPtr:\n    if (v === t.nil) {\n      return null;\n    }\n    return $externalize(v.$get(), t.elem);\n  case $kindSlice:\n    if ($needsExternalization(t.elem)) {\n      return $mapArray($sliceToArray(v), function(e) { return $externalize(e, t.elem); });\n    }\n    return $sliceToArray(v);\n  case $kindString:\n    if (v.search(/^[\\x00-\\x7F]*$/) !== -1) {\n      return v;\n    }\n    var s = \"\", r;\n    for (var i = 0; i < v.length; i += r[1]) {\n      r = $decodeRune(v, i);\n      var c = r[0];\n      if (c > 0xFFFF) {\n        var h = Math.floor((c - 0x10000) / 0x400) + 0xD800;\n        var l = (c - 0x10000) % 0x400 + 0xDC00;\n        s += String.fromCharCode(h, l);\n        continue;\n      }\n      s += String.fromCharCode(c);\n    }\n    return s;\n  case $kindStruct:\n    var timePkg = $packages[\"time\"];\n    if (timePkg !== undefined && v.constructor === timePkg.Time.ptr) {\n      var milli = $div64(v.UnixNano(), new $Int64(0, 1000000));\n      return new Date($flatten64(milli));\n    }\n\n    var noJsObject = {};\n    var searchJsObject = function(v, t) {\n      if (t === $jsObjectPtr) {\n        return v;\n      }\n      switch (t.kind) {\n      case $kindPtr:\n        if (v === t.nil) {\n          return noJsObject;\n        }\n        return searchJsObject(v.$get(), t.elem);\n      case $kindStruct:\n        var f = t.fields[0];\n        return searchJsObject(v[f.prop], f.typ);\n      case $kindInterface:\n        return searchJsObject(v.$val, v.constructor);\n      default:\n        return noJsObject;\n      }\n    };\n    var o = searchJsObject(v, t);\n    if (o !== noJsObject) {\n      return o;\n    }\n\n    o = {};\n    for (var i = 0; i < t.fields.length; i++) {\n      var f = t.fields[i];\n      if (!f.exported) {\n        continue;\n      }\n      o[f.name] = $externalize(v[f.prop], f.typ);\n    }\n    return o;\n  }\n  $throwRuntimeError(\"cannot externalize \" + t.string);\n};\n\nvar $externalizeFunction = function(v, t, passThis) {\n  if (v === $throwNilPointerError) {\n    return null;\n  }\n  if (v.$externalizeWrapper === undefined) {\n    $checkForDeadlock = false;\n    v.$externalizeWrapper = function() {\n      var args = [];\n      for (var i = 0; i < t.params.length; i++) {\n        if (t.variadic && i === t.params.length - 1) {\n          var vt = t.params[i].elem, varargs = [];\n          for (var j = i; j < arguments.length; j++) {\n            varargs.push($internalize(arguments[j], vt));\n          }\n          args.push(new (t.params[i])(varargs));\n          break;\n        }\n        args.push($internalize(arguments[i], t.params[i]));\n      }\n      var canBlock = $curGoroutine.canBlock;\n      $curGoroutine.canBlock = false;\n      try {\n        var result = v.apply(passThis ? this : undefined, args);\n      } finally {\n        $curGoroutine.canBlock = canBlock;\n      }\n      switch (t.results.length) {\n      case 0:\n        return;\n      case 1:\n        return $externalize(result, t.results[0]);\n      default:\n        for (var i = 0; i < t.results.length; i++) {\n          result[i] = $externalize(result[i], t.results[i]);\n        }\n        return result;\n      }\n    };\n  }\n  return v.$externalizeWrapper;\n};\n\nvar $internalize = function(v, t, recv) {\n  if (t === $jsObjectPtr) {\n    return v;\n  }\n  if (t === $jsObjectPtr.elem) {\n    $throwRuntimeError(\"cannot internalize js.Object, use *js.Object instead\");\n  }\n  if (v && v.__internal_object__ !== undefined) {\n    return $assertType(v.__internal_object__, t, false);\n  }\n  var timePkg = $packages[\"time\"];\n  if (timePkg !== undefined && t === timePkg.Time) {\n    if (!(v !== null && v !== undefined && v.constructor === Date)) {\n      $throwRuntimeError(\"cannot internalize time.Time from \" + typeof v + \", must be Date\");\n    }\n    return timePkg.Unix(new $Int64(0, 0), new $Int64(0, v.getTime() * 1000000));\n  }\n  switch (t.kind) {\n  case $kindBool:\n    return !!v;\n  case $kindInt:\n    return parseInt(v);\n  case $kindInt8:\n    return parseInt(v) << 24 >> 24;\n  case $kindInt16:\n    return parseInt(v) << 16 >> 16;\n  case $kindInt32:\n    return parseInt(v) >> 0;\n  case $kindUint:\n    return parseInt(v);\n  case $kindUint8:\n    return parseInt(v) << 24 >>> 24;\n  case $kindUint16:\n    return parseInt(v) << 16 >>> 16;\n  case $kindUint32:\n  case $kindUintptr:\n    return parseInt(v) >>> 0;\n  case $kindInt64:\n  case $kindUint64:\n    return new t(0, v);\n  case $kindFloat32:\n  case $kindFloat64:\n    return parseFloat(v);\n  case $kindArray:\n    if (v.length !== t.len) {\n      $throwRuntimeError(\"got array with wrong size from JavaScript native\");\n    }\n    return $mapArray(v, function(e) { return $internalize(e, t.elem); });\n  case $kindFunc:\n    return function() {\n      var args = [];\n      for (var i = 0; i < t.params.length; i++) {\n        if (t.variadic && i === t.params.length - 1) {\n          var vt = t.params[i].elem, varargs = arguments[i];\n          for (var j = 0; j < varargs.$length; j++) {\n            args.push($externalize(varargs.$array[varargs.$offset + j], vt));\n          }\n          break;\n        }\n        args.push($externalize(arguments[i], t.params[i]));\n      }\n      var result = v.apply(recv, args);\n      switch (t.results.length) {\n      case 0:\n        return;\n      case 1:\n        return $internalize(result, t.results[0]);\n      default:\n        for (var i = 0; i < t.results.length; i++) {\n          result[i] = $internalize(result[i], t.results[i]);\n        }\n        return result;\n      }\n    };\n  case $kindInterface:\n    if (t.methods.length !== 0) {\n      $throwRuntimeError(\"cannot internalize \" + t.string);\n    }\n    if (v === null) {\n      return $ifaceNil;\n    }\n    if (v === undefined) {\n      return new $jsObjectPtr(undefined);\n    }\n    switch (v.constructor) {\n    case Int8Array:\n      return new ($sliceType($Int8))(v);\n    case Int16Array:\n      return new ($sliceType($Int16))(v);\n    case Int32Array:\n      return new ($sliceType($Int))(v);\n    case Uint8Array:\n      return new ($sliceType($Uint8))(v);\n    case Uint16Array:\n      return new ($sliceType($Uint16))(v);\n    case Uint32Array:\n      return new ($sliceType($Uint))(v);\n    case Float32Array:\n      return new ($sliceType($Float32))(v);\n    case Float64Array:\n      return new ($sliceType($Float64))(v);\n    case Array:\n      return $internalize(v, $sliceType($emptyInterface));\n    case Boolean:\n      return new $Bool(!!v);\n    case Date:\n      if (timePkg === undefined) {\n        /* time package is not present, internalize as &js.Object{Date} so it can be externalized into original Date. */\n        return new $jsObjectPtr(v);\n      }\n      return new timePkg.Time($internalize(v, timePkg.Time));\n    case Function:\n      var funcType = $funcType([$sliceType($emptyInterface)], [$jsObjectPtr], true);\n      return new funcType($internalize(v, funcType));\n    case Number:\n      return new $Float64(parseFloat(v));\n    case String:\n      return new $String($internalize(v, $String));\n    default:\n      if ($global.Node && v instanceof $global.Node) {\n        return new $jsObjectPtr(v);\n      }\n      var mapType = $mapType($String, $emptyInterface);\n      return new mapType($internalize(v, mapType));\n    }\n  case $kindMap:\n    var m = {};\n    var keys = $keys(v);\n    for (var i = 0; i < keys.length; i++) {\n      var k = $internalize(keys[i], t.key);\n      m[t.key.keyFor(k)] = { k: k, v: $internalize(v[keys[i]], t.elem) };\n    }\n    return m;\n  case $kindPtr:\n    if (t.elem.kind === $kindStruct) {\n      return $internalize(v, t.elem);\n    }\n  case $kindSlice:\n    return new t($mapArray(v, function(e) { return $internalize(e, t.elem); }));\n  case $kindString:\n    v = String(v);\n    if (v.search(/^[\\x00-\\x7F]*$/) !== -1) {\n      return v;\n    }\n    var s = \"\";\n    var i = 0;\n    while (i < v.length) {\n      var h = v.charCodeAt(i);\n      if (0xD800 <= h && h <= 0xDBFF) {\n        var l = v.charCodeAt(i + 1);\n        var c = (h - 0xD800) * 0x400 + l - 0xDC00 + 0x10000;\n        s += $encodeRune(c);\n        i += 2;\n        continue;\n      }\n      s += $encodeRune(h);\n      i++;\n    }\n    return s;\n  case $kindStruct:\n    var noJsObject = {};\n    var searchJsObject = function(t) {\n      if (t === $jsObjectPtr) {\n        return v;\n      }\n      if (t === $jsObjectPtr.elem) {\n        $throwRuntimeError(\"cannot internalize js.Object, use *js.Object instead\");\n      }\n      switch (t.kind) {\n      case $kindPtr:\n        return searchJsObject(t.elem);\n      case $kindStruct:\n        var f = t.fields[0];\n        var o = searchJsObject(f.typ);\n        if (o !== noJsObject) {\n          var n = new t.ptr();\n          n[f.prop] = o;\n          return n;\n        }\n        return noJsObject;\n      default:\n        return noJsObject;\n      }\n    };\n    var o = searchJsObject(t);\n    if (o !== noJsObject) {\n      return o;\n    }\n  }\n  $throwRuntimeError(\"cannot internalize \" + t.string);\n};\n\n$packages[\"github.com/gopherjs/gopherjs/js\"] = (function() {\n\tvar $pkg = {}, $init, Object, Error, sliceType, ptrType, ptrType$1, MakeFunc, init;\n\tObject = $pkg.Object = $newType(0, $kindStruct, \"js.Object\", true, \"github.com/gopherjs/gopherjs/js\", true, function(object_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.object = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.object = object_;\n\t});\n\tError = $pkg.Error = $newType(0, $kindStruct, \"js.Error\", true, \"github.com/gopherjs/gopherjs/js\", true, function(Object_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Object = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.Object = Object_;\n\t});\n\tsliceType = $sliceType($emptyInterface);\n\tptrType = $ptrType(Object);\n\tptrType$1 = $ptrType(Error);\n\tObject.ptr.prototype.Get = function(key) {\n\t\tvar $ptr, key, o;\n\t\to = this;\n\t\treturn o.object[$externalize(key, $String)];\n\t};\n\tObject.prototype.Get = function(key) { return this.$val.Get(key); };\n\tObject.ptr.prototype.Set = function(key, value) {\n\t\tvar $ptr, key, o, value;\n\t\to = this;\n\t\to.object[$externalize(key, $String)] = $externalize(value, $emptyInterface);\n\t};\n\tObject.prototype.Set = function(key, value) { return this.$val.Set(key, value); };\n\tObject.ptr.prototype.Delete = function(key) {\n\t\tvar $ptr, key, o;\n\t\to = this;\n\t\tdelete o.object[$externalize(key, $String)];\n\t};\n\tObject.prototype.Delete = function(key) { return this.$val.Delete(key); };\n\tObject.ptr.prototype.Length = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $parseInt(o.object.length);\n\t};\n\tObject.prototype.Length = function() { return this.$val.Length(); };\n\tObject.ptr.prototype.Index = function(i) {\n\t\tvar $ptr, i, o;\n\t\to = this;\n\t\treturn o.object[i];\n\t};\n\tObject.prototype.Index = function(i) { return this.$val.Index(i); };\n\tObject.ptr.prototype.SetIndex = function(i, value) {\n\t\tvar $ptr, i, o, value;\n\t\to = this;\n\t\to.object[i] = $externalize(value, $emptyInterface);\n\t};\n\tObject.prototype.SetIndex = function(i, value) { return this.$val.SetIndex(i, value); };\n\tObject.ptr.prototype.Call = function(name, args) {\n\t\tvar $ptr, args, name, o, obj;\n\t\to = this;\n\t\treturn (obj = o.object, obj[$externalize(name, $String)].apply(obj, $externalize(args, sliceType)));\n\t};\n\tObject.prototype.Call = function(name, args) { return this.$val.Call(name, args); };\n\tObject.ptr.prototype.Invoke = function(args) {\n\t\tvar $ptr, args, o;\n\t\to = this;\n\t\treturn o.object.apply(undefined, $externalize(args, sliceType));\n\t};\n\tObject.prototype.Invoke = function(args) { return this.$val.Invoke(args); };\n\tObject.ptr.prototype.New = function(args) {\n\t\tvar $ptr, args, o;\n\t\to = this;\n\t\treturn new ($global.Function.prototype.bind.apply(o.object, [undefined].concat($externalize(args, sliceType))));\n\t};\n\tObject.prototype.New = function(args) { return this.$val.New(args); };\n\tObject.ptr.prototype.Bool = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn !!(o.object);\n\t};\n\tObject.prototype.Bool = function() { return this.$val.Bool(); };\n\tObject.ptr.prototype.String = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $internalize(o.object, $String);\n\t};\n\tObject.prototype.String = function() { return this.$val.String(); };\n\tObject.ptr.prototype.Int = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $parseInt(o.object) >> 0;\n\t};\n\tObject.prototype.Int = function() { return this.$val.Int(); };\n\tObject.ptr.prototype.Int64 = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $internalize(o.object, $Int64);\n\t};\n\tObject.prototype.Int64 = function() { return this.$val.Int64(); };\n\tObject.ptr.prototype.Uint64 = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $internalize(o.object, $Uint64);\n\t};\n\tObject.prototype.Uint64 = function() { return this.$val.Uint64(); };\n\tObject.ptr.prototype.Float = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $parseFloat(o.object);\n\t};\n\tObject.prototype.Float = function() { return this.$val.Float(); };\n\tObject.ptr.prototype.Interface = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn $internalize(o.object, $emptyInterface);\n\t};\n\tObject.prototype.Interface = function() { return this.$val.Interface(); };\n\tObject.ptr.prototype.Unsafe = function() {\n\t\tvar $ptr, o;\n\t\to = this;\n\t\treturn o.object;\n\t};\n\tObject.prototype.Unsafe = function() { return this.$val.Unsafe(); };\n\tError.ptr.prototype.Error = function() {\n\t\tvar $ptr, err;\n\t\terr = this;\n\t\treturn \"JavaScript error: \" + $internalize(err.Object.message, $String);\n\t};\n\tError.prototype.Error = function() { return this.$val.Error(); };\n\tError.ptr.prototype.Stack = function() {\n\t\tvar $ptr, err;\n\t\terr = this;\n\t\treturn $internalize(err.Object.stack, $String);\n\t};\n\tError.prototype.Stack = function() { return this.$val.Stack(); };\n\tMakeFunc = function(fn) {\n\t\tvar $ptr, fn;\n\t\treturn $makeFunc(fn);\n\t};\n\t$pkg.MakeFunc = MakeFunc;\n\tinit = function() {\n\t\tvar $ptr, e;\n\t\te = new Error.ptr(null);\n\t\t$unused(e);\n\t};\n\tptrType.methods = [{prop: \"Get\", name: \"Get\", pkg: \"\", typ: $funcType([$String], [ptrType], false)}, {prop: \"Set\", name: \"Set\", pkg: \"\", typ: $funcType([$String, $emptyInterface], [], false)}, {prop: \"Delete\", name: \"Delete\", pkg: \"\", typ: $funcType([$String], [], false)}, {prop: \"Length\", name: \"Length\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Index\", name: \"Index\", pkg: \"\", typ: $funcType([$Int], [ptrType], false)}, {prop: \"SetIndex\", name: \"SetIndex\", pkg: \"\", typ: $funcType([$Int, $emptyInterface], [], false)}, {prop: \"Call\", name: \"Call\", pkg: \"\", typ: $funcType([$String, sliceType], [ptrType], true)}, {prop: \"Invoke\", name: \"Invoke\", pkg: \"\", typ: $funcType([sliceType], [ptrType], true)}, {prop: \"New\", name: \"New\", pkg: \"\", typ: $funcType([sliceType], [ptrType], true)}, {prop: \"Bool\", name: \"Bool\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Int\", name: \"Int\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Int64\", name: \"Int64\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"Uint64\", name: \"Uint64\", pkg: \"\", typ: $funcType([], [$Uint64], false)}, {prop: \"Float\", name: \"Float\", pkg: \"\", typ: $funcType([], [$Float64], false)}, {prop: \"Interface\", name: \"Interface\", pkg: \"\", typ: $funcType([], [$emptyInterface], false)}, {prop: \"Unsafe\", name: \"Unsafe\", pkg: \"\", typ: $funcType([], [$Uintptr], false)}];\n\tptrType$1.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Stack\", name: \"Stack\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tObject.init(\"github.com/gopherjs/gopherjs/js\", [{prop: \"object\", name: \"object\", exported: false, typ: ptrType, tag: \"\"}]);\n\tError.init(\"\", [{prop: \"Object\", name: \"\", exported: true, typ: ptrType, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tinit();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"runtime/internal/sys\"] = (function() {\n\tvar $pkg = {}, $init;\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"runtime\"] = (function() {\n\tvar $pkg = {}, $init, js, sys, TypeAssertionError, errorString, ptrType$3, init, Goexit, SetFinalizer;\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tsys = $packages[\"runtime/internal/sys\"];\n\tTypeAssertionError = $pkg.TypeAssertionError = $newType(0, $kindStruct, \"runtime.TypeAssertionError\", true, \"runtime\", true, function(interfaceString_, concreteString_, assertedString_, missingMethod_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.interfaceString = \"\";\n\t\t\tthis.concreteString = \"\";\n\t\t\tthis.assertedString = \"\";\n\t\t\tthis.missingMethod = \"\";\n\t\t\treturn;\n\t\t}\n\t\tthis.interfaceString = interfaceString_;\n\t\tthis.concreteString = concreteString_;\n\t\tthis.assertedString = assertedString_;\n\t\tthis.missingMethod = missingMethod_;\n\t});\n\terrorString = $pkg.errorString = $newType(8, $kindString, \"runtime.errorString\", true, \"runtime\", false, null);\n\tptrType$3 = $ptrType(TypeAssertionError);\n\tinit = function() {\n\t\tvar $ptr, e, jsPkg;\n\t\tjsPkg = $packages[$externalize(\"github.com/gopherjs/gopherjs/js\", $String)];\n\t\t$jsObjectPtr = jsPkg.Object.ptr;\n\t\t$jsErrorPtr = jsPkg.Error.ptr;\n\t\t$throwRuntimeError = (function(msg) {\n\t\t\tvar $ptr, msg;\n\t\t\t$panic(new errorString(msg));\n\t\t});\n\t\te = $ifaceNil;\n\t\te = new TypeAssertionError.ptr(\"\", \"\", \"\", \"\");\n\t\t$unused(e);\n\t};\n\tGoexit = function() {\n\t\tvar $ptr;\n\t\t$curGoroutine.exit = $externalize(true, $Bool);\n\t\t$throw(null);\n\t};\n\t$pkg.Goexit = Goexit;\n\tSetFinalizer = function(x, f) {\n\t\tvar $ptr, f, x;\n\t};\n\t$pkg.SetFinalizer = SetFinalizer;\n\tTypeAssertionError.ptr.prototype.RuntimeError = function() {\n\t\tvar $ptr;\n\t};\n\tTypeAssertionError.prototype.RuntimeError = function() { return this.$val.RuntimeError(); };\n\tTypeAssertionError.ptr.prototype.Error = function() {\n\t\tvar $ptr, e, inter;\n\t\te = this;\n\t\tinter = e.interfaceString;\n\t\tif (inter === \"\") {\n\t\t\tinter = \"interface\";\n\t\t}\n\t\tif (e.concreteString === \"\") {\n\t\t\treturn \"interface conversion: \" + inter + \" is nil, not \" + e.assertedString;\n\t\t}\n\t\tif (e.missingMethod === \"\") {\n\t\t\treturn \"interface conversion: \" + inter + \" is \" + e.concreteString + \", not \" + e.assertedString;\n\t\t}\n\t\treturn \"interface conversion: \" + e.concreteString + \" is not \" + e.assertedString + \": missing method \" + e.missingMethod;\n\t};\n\tTypeAssertionError.prototype.Error = function() { return this.$val.Error(); };\n\terrorString.prototype.RuntimeError = function() {\n\t\tvar $ptr, e;\n\t\te = this.$val;\n\t};\n\t$ptrType(errorString).prototype.RuntimeError = function() { return new errorString(this.$get()).RuntimeError(); };\n\terrorString.prototype.Error = function() {\n\t\tvar $ptr, e;\n\t\te = this.$val;\n\t\treturn \"runtime error: \" + e;\n\t};\n\t$ptrType(errorString).prototype.Error = function() { return new errorString(this.$get()).Error(); };\n\tptrType$3.methods = [{prop: \"RuntimeError\", name: \"RuntimeError\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\terrorString.methods = [{prop: \"RuntimeError\", name: \"RuntimeError\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tTypeAssertionError.init(\"runtime\", [{prop: \"interfaceString\", name: \"interfaceString\", exported: false, typ: $String, tag: \"\"}, {prop: \"concreteString\", name: \"concreteString\", exported: false, typ: $String, tag: \"\"}, {prop: \"assertedString\", name: \"assertedString\", exported: false, typ: $String, tag: \"\"}, {prop: \"missingMethod\", name: \"missingMethod\", exported: false, typ: $String, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = sys.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tinit();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"errors\"] = (function() {\n\tvar $pkg = {}, $init, errorString, ptrType, New;\n\terrorString = $pkg.errorString = $newType(0, $kindStruct, \"errors.errorString\", true, \"errors\", false, function(s_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.s = \"\";\n\t\t\treturn;\n\t\t}\n\t\tthis.s = s_;\n\t});\n\tptrType = $ptrType(errorString);\n\tNew = function(text) {\n\t\tvar $ptr, text;\n\t\treturn new errorString.ptr(text);\n\t};\n\t$pkg.New = New;\n\terrorString.ptr.prototype.Error = function() {\n\t\tvar $ptr, e;\n\t\te = this;\n\t\treturn e.s;\n\t};\n\terrorString.prototype.Error = function() { return this.$val.Error(); };\n\tptrType.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\terrorString.init(\"errors\", [{prop: \"s\", name: \"s\", exported: false, typ: $String, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"internal/race\"] = (function() {\n\tvar $pkg = {}, $init, Acquire, Release, ReleaseMerge, Disable, Enable, ReadRange, WriteRange;\n\tAcquire = function(addr) {\n\t\tvar $ptr, addr;\n\t};\n\t$pkg.Acquire = Acquire;\n\tRelease = function(addr) {\n\t\tvar $ptr, addr;\n\t};\n\t$pkg.Release = Release;\n\tReleaseMerge = function(addr) {\n\t\tvar $ptr, addr;\n\t};\n\t$pkg.ReleaseMerge = ReleaseMerge;\n\tDisable = function() {\n\t\tvar $ptr;\n\t};\n\t$pkg.Disable = Disable;\n\tEnable = function() {\n\t\tvar $ptr;\n\t};\n\t$pkg.Enable = Enable;\n\tReadRange = function(addr, len) {\n\t\tvar $ptr, addr, len;\n\t};\n\t$pkg.ReadRange = ReadRange;\n\tWriteRange = function(addr, len) {\n\t\tvar $ptr, addr, len;\n\t};\n\t$pkg.WriteRange = WriteRange;\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"sync/atomic\"] = (function() {\n\tvar $pkg = {}, $init, js, CompareAndSwapInt32, AddInt32, LoadUint32, StoreUint32;\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tCompareAndSwapInt32 = function(addr, old, new$1) {\n\t\tvar $ptr, addr, new$1, old;\n\t\tif (addr.$get() === old) {\n\t\t\taddr.$set(new$1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\t$pkg.CompareAndSwapInt32 = CompareAndSwapInt32;\n\tAddInt32 = function(addr, delta) {\n\t\tvar $ptr, addr, delta, new$1;\n\t\tnew$1 = addr.$get() + delta >> 0;\n\t\taddr.$set(new$1);\n\t\treturn new$1;\n\t};\n\t$pkg.AddInt32 = AddInt32;\n\tLoadUint32 = function(addr) {\n\t\tvar $ptr, addr;\n\t\treturn addr.$get();\n\t};\n\t$pkg.LoadUint32 = LoadUint32;\n\tStoreUint32 = function(addr, val) {\n\t\tvar $ptr, addr, val;\n\t\taddr.$set(val);\n\t};\n\t$pkg.StoreUint32 = StoreUint32;\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"sync\"] = (function() {\n\tvar $pkg = {}, $init, race, runtime, atomic, Pool, Mutex, Locker, Once, poolLocal, notifyList, RWMutex, rlocker, ptrType, sliceType, ptrType$1, chanType, sliceType$1, ptrType$3, ptrType$5, sliceType$3, ptrType$6, ptrType$7, funcType, ptrType$13, funcType$1, ptrType$14, arrayType$1, semWaiters, allPools, runtime_registerPoolCleanup, runtime_Semacquire, runtime_Semrelease, runtime_notifyListCheck, runtime_canSpin, poolCleanup, init, indexLocal, init$1, runtime_doSpin;\n\trace = $packages[\"internal/race\"];\n\truntime = $packages[\"runtime\"];\n\tatomic = $packages[\"sync/atomic\"];\n\tPool = $pkg.Pool = $newType(0, $kindStruct, \"sync.Pool\", true, \"sync\", true, function(local_, localSize_, store_, New_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.local = 0;\n\t\t\tthis.localSize = 0;\n\t\t\tthis.store = sliceType$3.nil;\n\t\t\tthis.New = $throwNilPointerError;\n\t\t\treturn;\n\t\t}\n\t\tthis.local = local_;\n\t\tthis.localSize = localSize_;\n\t\tthis.store = store_;\n\t\tthis.New = New_;\n\t});\n\tMutex = $pkg.Mutex = $newType(0, $kindStruct, \"sync.Mutex\", true, \"sync\", true, function(state_, sema_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.state = 0;\n\t\t\tthis.sema = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.state = state_;\n\t\tthis.sema = sema_;\n\t});\n\tLocker = $pkg.Locker = $newType(8, $kindInterface, \"sync.Locker\", true, \"sync\", true, null);\n\tOnce = $pkg.Once = $newType(0, $kindStruct, \"sync.Once\", true, \"sync\", true, function(m_, done_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.m = new Mutex.ptr(0, 0);\n\t\t\tthis.done = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.m = m_;\n\t\tthis.done = done_;\n\t});\n\tpoolLocal = $pkg.poolLocal = $newType(0, $kindStruct, \"sync.poolLocal\", true, \"sync\", false, function(private$0_, shared_, Mutex_, pad_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.private$0 = $ifaceNil;\n\t\t\tthis.shared = sliceType$3.nil;\n\t\t\tthis.Mutex = new Mutex.ptr(0, 0);\n\t\t\tthis.pad = arrayType$1.zero();\n\t\t\treturn;\n\t\t}\n\t\tthis.private$0 = private$0_;\n\t\tthis.shared = shared_;\n\t\tthis.Mutex = Mutex_;\n\t\tthis.pad = pad_;\n\t});\n\tnotifyList = $pkg.notifyList = $newType(0, $kindStruct, \"sync.notifyList\", true, \"sync\", false, function(wait_, notify_, lock_, head_, tail_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.wait = 0;\n\t\t\tthis.notify = 0;\n\t\t\tthis.lock = 0;\n\t\t\tthis.head = 0;\n\t\t\tthis.tail = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.wait = wait_;\n\t\tthis.notify = notify_;\n\t\tthis.lock = lock_;\n\t\tthis.head = head_;\n\t\tthis.tail = tail_;\n\t});\n\tRWMutex = $pkg.RWMutex = $newType(0, $kindStruct, \"sync.RWMutex\", true, \"sync\", true, function(w_, writerSem_, readerSem_, readerCount_, readerWait_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.w = new Mutex.ptr(0, 0);\n\t\t\tthis.writerSem = 0;\n\t\t\tthis.readerSem = 0;\n\t\t\tthis.readerCount = 0;\n\t\t\tthis.readerWait = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.w = w_;\n\t\tthis.writerSem = writerSem_;\n\t\tthis.readerSem = readerSem_;\n\t\tthis.readerCount = readerCount_;\n\t\tthis.readerWait = readerWait_;\n\t});\n\trlocker = $pkg.rlocker = $newType(0, $kindStruct, \"sync.rlocker\", true, \"sync\", false, function(w_, writerSem_, readerSem_, readerCount_, readerWait_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.w = new Mutex.ptr(0, 0);\n\t\t\tthis.writerSem = 0;\n\t\t\tthis.readerSem = 0;\n\t\t\tthis.readerCount = 0;\n\t\t\tthis.readerWait = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.w = w_;\n\t\tthis.writerSem = writerSem_;\n\t\tthis.readerSem = readerSem_;\n\t\tthis.readerCount = readerCount_;\n\t\tthis.readerWait = readerWait_;\n\t});\n\tptrType = $ptrType(Pool);\n\tsliceType = $sliceType(ptrType);\n\tptrType$1 = $ptrType($Uint32);\n\tchanType = $chanType($Bool, false, false);\n\tsliceType$1 = $sliceType(chanType);\n\tptrType$3 = $ptrType($Int32);\n\tptrType$5 = $ptrType(poolLocal);\n\tsliceType$3 = $sliceType($emptyInterface);\n\tptrType$6 = $ptrType(rlocker);\n\tptrType$7 = $ptrType(RWMutex);\n\tfuncType = $funcType([], [$emptyInterface], false);\n\tptrType$13 = $ptrType(Mutex);\n\tfuncType$1 = $funcType([], [], false);\n\tptrType$14 = $ptrType(Once);\n\tarrayType$1 = $arrayType($Uint8, 128);\n\tPool.ptr.prototype.Get = function() {\n\t\tvar $ptr, _r, p, x, x$1, x$2, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t/* */ if (p.store.$length === 0) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (p.store.$length === 0) { */ case 1:\n\t\t\t/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (!(p.New === $throwNilPointerError)) { */ case 3:\n\t\t\t\t_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return _r;\n\t\t\t/* } */ case 4:\n\t\t\t$s = -1; return $ifaceNil;\n\t\t/* } */ case 2:\n\t\tx$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + x$1]));\n\t\tp.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));\n\t\t$s = -1; return x$2;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f.$ptr = $ptr; $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tPool.prototype.Get = function() { return this.$val.Get(); };\n\tPool.ptr.prototype.Put = function(x) {\n\t\tvar $ptr, p, x;\n\t\tp = this;\n\t\tif ($interfaceIsEqual(x, $ifaceNil)) {\n\t\t\treturn;\n\t\t}\n\t\tp.store = $append(p.store, x);\n\t};\n\tPool.prototype.Put = function(x) { return this.$val.Put(x); };\n\truntime_registerPoolCleanup = function(cleanup) {\n\t\tvar $ptr, cleanup;\n\t};\n\truntime_Semacquire = function(s) {\n\t\tvar $ptr, _entry, _key, _r, ch, s, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _entry = $f._entry; _key = $f._key; _r = $f._r; ch = $f.ch; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t/* */ if (s.$get() === 0) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (s.$get() === 0) { */ case 1:\n\t\t\tch = new $Chan($Bool, 0);\n\t\t\t_key = s; (semWaiters || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$1.keyFor(_key)] = { k: _key, v: $append((_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil), ch) };\n\t\t\t_r = $recv(ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t_r[0];\n\t\t/* } */ case 2:\n\t\ts.$set(s.$get() - (1) >>> 0);\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semacquire }; } $f.$ptr = $ptr; $f._entry = _entry; $f._key = _key; $f._r = _r; $f.ch = ch; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\truntime_Semrelease = function(s) {\n\t\tvar $ptr, _entry, _key, ch, s, w, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _entry = $f._entry; _key = $f._key; ch = $f.ch; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ts.$set(s.$get() + (1) >>> 0);\n\t\tw = (_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil);\n\t\tif (w.$length === 0) {\n\t\t\t$s = -1; return;\n\t\t}\n\t\tch = (0 >= w.$length ? $throwRuntimeError(\"index out of range\") : w.$array[w.$offset + 0]);\n\t\tw = $subslice(w, 1);\n\t\t_key = s; (semWaiters || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$1.keyFor(_key)] = { k: _key, v: w };\n\t\tif (w.$length === 0) {\n\t\t\tdelete semWaiters[ptrType$1.keyFor(s)];\n\t\t}\n\t\t$r = $send(ch, true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semrelease }; } $f.$ptr = $ptr; $f._entry = _entry; $f._key = _key; $f.ch = ch; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\truntime_notifyListCheck = function(size) {\n\t\tvar $ptr, size;\n\t};\n\truntime_canSpin = function(i) {\n\t\tvar $ptr, i;\n\t\treturn false;\n\t};\n\tMutex.ptr.prototype.Lock = function() {\n\t\tvar $ptr, awoke, iter, m, new$1, old, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; awoke = $f.awoke; iter = $f.iter; m = $f.m; new$1 = $f.new$1; old = $f.old; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tm = this;\n\t\tif (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), 0, 1)) {\n\t\t\tif (false) {\n\t\t\t\trace.Acquire(m);\n\t\t\t}\n\t\t\t$s = -1; return;\n\t\t}\n\t\tawoke = false;\n\t\titer = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\told = m.state;\n\t\t\tnew$1 = old | 1;\n\t\t\t/* */ if (!(((old & 1) === 0))) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (!(((old & 1) === 0))) { */ case 3:\n\t\t\t\tif (runtime_canSpin(iter)) {\n\t\t\t\t\tif (!awoke && ((old & 2) === 0) && !(((old >> 2 >> 0) === 0)) && atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, old | 2)) {\n\t\t\t\t\t\tawoke = true;\n\t\t\t\t\t}\n\t\t\t\t\truntime_doSpin();\n\t\t\t\t\titer = iter + (1) >> 0;\n\t\t\t\t\t/* continue; */ $s = 1; continue;\n\t\t\t\t}\n\t\t\t\tnew$1 = old + 4 >> 0;\n\t\t\t/* } */ case 4:\n\t\t\tif (awoke) {\n\t\t\t\tif ((new$1 & 2) === 0) {\n\t\t\t\t\t$panic(new $String(\"sync: inconsistent mutex state\"));\n\t\t\t\t}\n\t\t\t\tnew$1 = (new$1 & ~(2)) >> 0;\n\t\t\t}\n\t\t\t/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 5; continue; }\n\t\t\t/* */ $s = 6; continue;\n\t\t\t/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 5:\n\t\t\t\tif ((old & 1) === 0) {\n\t\t\t\t\t/* break; */ $s = 2; continue;\n\t\t\t\t}\n\t\t\t\t$r = runtime_Semacquire((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m)))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\tawoke = true;\n\t\t\t\titer = 0;\n\t\t\t/* } */ case 6:\n\t\t/* } */ $s = 1; continue; case 2:\n\t\tif (false) {\n\t\t\trace.Acquire(m);\n\t\t}\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Lock }; } $f.$ptr = $ptr; $f.awoke = awoke; $f.iter = iter; $f.m = m; $f.new$1 = new$1; $f.old = old; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tMutex.prototype.Lock = function() { return this.$val.Lock(); };\n\tMutex.ptr.prototype.Unlock = function() {\n\t\tvar $ptr, m, new$1, old, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; m = $f.m; new$1 = $f.new$1; old = $f.old; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tm = this;\n\t\tif (false) {\n\t\t\t$unused(m.state);\n\t\t\trace.Release(m);\n\t\t}\n\t\tnew$1 = atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), -1);\n\t\tif ((((new$1 + 1 >> 0)) & 1) === 0) {\n\t\t\t$panic(new $String(\"sync: unlock of unlocked mutex\"));\n\t\t}\n\t\told = new$1;\n\t\t/* while (true) { */ case 1:\n\t\t\tif (((old >> 2 >> 0) === 0) || !(((old & 3) === 0))) {\n\t\t\t\t$s = -1; return;\n\t\t\t}\n\t\t\tnew$1 = ((old - 4 >> 0)) | 2;\n\t\t\t/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$3(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 3:\n\t\t\t\t$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m)))); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return;\n\t\t\t/* } */ case 4:\n\t\t\told = m.state;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Unlock }; } $f.$ptr = $ptr; $f.m = m; $f.new$1 = new$1; $f.old = old; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tMutex.prototype.Unlock = function() { return this.$val.Unlock(); };\n\tOnce.ptr.prototype.Do = function(f) {\n\t\tvar $ptr, f, o, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; f = $f.f; o = $f.o; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\to = this;\n\t\tif (atomic.LoadUint32((o.$ptr_done || (o.$ptr_done = new ptrType$1(function() { return this.$target.done; }, function($v) { this.$target.done = $v; }, o)))) === 1) {\n\t\t\t$s = -1; return;\n\t\t}\n\t\t$r = o.m.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$deferred.push([$methodVal(o.m, \"Unlock\"), []]);\n\t\t/* */ if (o.done === 0) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (o.done === 0) { */ case 2:\n\t\t\t$deferred.push([atomic.StoreUint32, [(o.$ptr_done || (o.$ptr_done = new ptrType$1(function() { return this.$target.done; }, function($v) { this.$target.done = $v; }, o))), 1]]);\n\t\t\t$r = f(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* } */ case 3:\n\t\t$s = -1; return;\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Once.ptr.prototype.Do }; } $f.$ptr = $ptr; $f.f = f; $f.o = o; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\tOnce.prototype.Do = function(f) { return this.$val.Do(f); };\n\tpoolCleanup = function() {\n\t\tvar $ptr, _i, _i$1, _ref, _ref$1, i, i$1, j, l, p, x;\n\t\t_ref = allPools;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\tp = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t((i < 0 || i >= allPools.$length) ? $throwRuntimeError(\"index out of range\") : allPools.$array[allPools.$offset + i] = ptrType.nil);\n\t\t\ti$1 = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i$1 < (p.localSize >> 0))) { break; }\n\t\t\t\tl = indexLocal(p.local, i$1);\n\t\t\t\tl.private$0 = $ifaceNil;\n\t\t\t\t_ref$1 = l.shared;\n\t\t\t\t_i$1 = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\t\t\tj = _i$1;\n\t\t\t\t\t(x = l.shared, ((j < 0 || j >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + j] = $ifaceNil));\n\t\t\t\t\t_i$1++;\n\t\t\t\t}\n\t\t\t\tl.shared = sliceType$3.nil;\n\t\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t\t}\n\t\t\tp.local = 0;\n\t\t\tp.localSize = 0;\n\t\t\t_i++;\n\t\t}\n\t\tallPools = new sliceType([]);\n\t};\n\tinit = function() {\n\t\tvar $ptr;\n\t\truntime_registerPoolCleanup(poolCleanup);\n\t};\n\tindexLocal = function(l, i) {\n\t\tvar $ptr, i, l, x;\n\t\treturn (x = l, (x.nilCheck, ((i < 0 || i >= x.length) ? $throwRuntimeError(\"index out of range\") : x[i])));\n\t};\n\tinit$1 = function() {\n\t\tvar $ptr, n;\n\t\tn = new notifyList.ptr(0, 0, 0, 0, 0);\n\t\truntime_notifyListCheck(20);\n\t};\n\truntime_doSpin = function() {\n\t\t$throwRuntimeError(\"native function not implemented: sync.runtime_doSpin\");\n\t};\n\tRWMutex.ptr.prototype.RLock = function() {\n\t\tvar $ptr, rw, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\trw = this;\n\t\tif (false) {\n\t\t\t$unused(rw.w.state);\n\t\t\trace.Disable();\n\t\t}\n\t\t/* */ if (atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$3(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1) < 0) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$3(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1) < 0) { */ case 1:\n\t\t\t$r = runtime_Semacquire((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw)))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* } */ case 2:\n\t\tif (false) {\n\t\t\trace.Enable();\n\t\t\trace.Acquire((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw))));\n\t\t}\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.RLock }; } $f.$ptr = $ptr; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tRWMutex.prototype.RLock = function() { return this.$val.RLock(); };\n\tRWMutex.ptr.prototype.RUnlock = function() {\n\t\tvar $ptr, r, rw, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; r = $f.r; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\trw = this;\n\t\tif (false) {\n\t\t\t$unused(rw.w.state);\n\t\t\trace.ReleaseMerge((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw))));\n\t\t\trace.Disable();\n\t\t}\n\t\tr = atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$3(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), -1);\n\t\t/* */ if (r < 0) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (r < 0) { */ case 1:\n\t\t\tif (((r + 1 >> 0) === 0) || ((r + 1 >> 0) === -1073741824)) {\n\t\t\t\trace.Enable();\n\t\t\t\t$panic(new $String(\"sync: RUnlock of unlocked RWMutex\"));\n\t\t\t}\n\t\t\t/* */ if (atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$3(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), -1) === 0) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$3(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), -1) === 0) { */ case 3:\n\t\t\t\t$r = runtime_Semrelease((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw)))); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 4:\n\t\t/* } */ case 2:\n\t\tif (false) {\n\t\t\trace.Enable();\n\t\t}\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.RUnlock }; } $f.$ptr = $ptr; $f.r = r; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tRWMutex.prototype.RUnlock = function() { return this.$val.RUnlock(); };\n\tRWMutex.ptr.prototype.Lock = function() {\n\t\tvar $ptr, r, rw, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; r = $f.r; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\trw = this;\n\t\tif (false) {\n\t\t\t$unused(rw.w.state);\n\t\t\trace.Disable();\n\t\t}\n\t\t$r = rw.w.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tr = atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$3(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), -1073741824) + 1073741824 >> 0;\n\t\t/* */ if (!((r === 0)) && !((atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$3(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), r) === 0))) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (!((r === 0)) && !((atomic.AddInt32((rw.$ptr_readerWait || (rw.$ptr_readerWait = new ptrType$3(function() { return this.$target.readerWait; }, function($v) { this.$target.readerWait = $v; }, rw))), r) === 0))) { */ case 2:\n\t\t\t$r = runtime_Semacquire((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw)))); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* } */ case 3:\n\t\tif (false) {\n\t\t\trace.Enable();\n\t\t\trace.Acquire((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw))));\n\t\t\trace.Acquire((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw))));\n\t\t}\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.Lock }; } $f.$ptr = $ptr; $f.r = r; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tRWMutex.prototype.Lock = function() { return this.$val.Lock(); };\n\tRWMutex.ptr.prototype.Unlock = function() {\n\t\tvar $ptr, i, r, rw, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; i = $f.i; r = $f.r; rw = $f.rw; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\trw = this;\n\t\tif (false) {\n\t\t\t$unused(rw.w.state);\n\t\t\trace.Release((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw))));\n\t\t\trace.Release((rw.$ptr_writerSem || (rw.$ptr_writerSem = new ptrType$1(function() { return this.$target.writerSem; }, function($v) { this.$target.writerSem = $v; }, rw))));\n\t\t\trace.Disable();\n\t\t}\n\t\tr = atomic.AddInt32((rw.$ptr_readerCount || (rw.$ptr_readerCount = new ptrType$3(function() { return this.$target.readerCount; }, function($v) { this.$target.readerCount = $v; }, rw))), 1073741824);\n\t\tif (r >= 1073741824) {\n\t\t\trace.Enable();\n\t\t\t$panic(new $String(\"sync: Unlock of unlocked RWMutex\"));\n\t\t}\n\t\ti = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(i < (r >> 0))) { break; } */ if(!(i < (r >> 0))) { $s = 2; continue; }\n\t\t\t$r = runtime_Semrelease((rw.$ptr_readerSem || (rw.$ptr_readerSem = new ptrType$1(function() { return this.$target.readerSem; }, function($v) { this.$target.readerSem = $v; }, rw)))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\ti = i + (1) >> 0;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t$r = rw.w.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tif (false) {\n\t\t\trace.Enable();\n\t\t}\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: RWMutex.ptr.prototype.Unlock }; } $f.$ptr = $ptr; $f.i = i; $f.r = r; $f.rw = rw; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tRWMutex.prototype.Unlock = function() { return this.$val.Unlock(); };\n\tRWMutex.ptr.prototype.RLocker = function() {\n\t\tvar $ptr, rw;\n\t\trw = this;\n\t\treturn $pointerOfStructConversion(rw, ptrType$6);\n\t};\n\tRWMutex.prototype.RLocker = function() { return this.$val.RLocker(); };\n\trlocker.ptr.prototype.Lock = function() {\n\t\tvar $ptr, r, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tr = this;\n\t\t$r = $pointerOfStructConversion(r, ptrType$7).RLock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rlocker.ptr.prototype.Lock }; } $f.$ptr = $ptr; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trlocker.prototype.Lock = function() { return this.$val.Lock(); };\n\trlocker.ptr.prototype.Unlock = function() {\n\t\tvar $ptr, r, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tr = this;\n\t\t$r = $pointerOfStructConversion(r, ptrType$7).RUnlock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rlocker.ptr.prototype.Unlock }; } $f.$ptr = $ptr; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trlocker.prototype.Unlock = function() { return this.$val.Unlock(); };\n\tptrType.methods = [{prop: \"Get\", name: \"Get\", pkg: \"\", typ: $funcType([], [$emptyInterface], false)}, {prop: \"Put\", name: \"Put\", pkg: \"\", typ: $funcType([$emptyInterface], [], false)}, {prop: \"getSlow\", name: \"getSlow\", pkg: \"sync\", typ: $funcType([], [$emptyInterface], false)}, {prop: \"pin\", name: \"pin\", pkg: \"sync\", typ: $funcType([], [ptrType$5], false)}, {prop: \"pinSlow\", name: \"pinSlow\", pkg: \"sync\", typ: $funcType([], [ptrType$5], false)}];\n\tptrType$13.methods = [{prop: \"Lock\", name: \"Lock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Unlock\", name: \"Unlock\", pkg: \"\", typ: $funcType([], [], false)}];\n\tptrType$14.methods = [{prop: \"Do\", name: \"Do\", pkg: \"\", typ: $funcType([funcType$1], [], false)}];\n\tptrType$7.methods = [{prop: \"RLock\", name: \"RLock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"RUnlock\", name: \"RUnlock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Lock\", name: \"Lock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Unlock\", name: \"Unlock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"RLocker\", name: \"RLocker\", pkg: \"\", typ: $funcType([], [Locker], false)}];\n\tptrType$6.methods = [{prop: \"Lock\", name: \"Lock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Unlock\", name: \"Unlock\", pkg: \"\", typ: $funcType([], [], false)}];\n\tPool.init(\"sync\", [{prop: \"local\", name: \"local\", exported: false, typ: $UnsafePointer, tag: \"\"}, {prop: \"localSize\", name: \"localSize\", exported: false, typ: $Uintptr, tag: \"\"}, {prop: \"store\", name: \"store\", exported: false, typ: sliceType$3, tag: \"\"}, {prop: \"New\", name: \"New\", exported: true, typ: funcType, tag: \"\"}]);\n\tMutex.init(\"sync\", [{prop: \"state\", name: \"state\", exported: false, typ: $Int32, tag: \"\"}, {prop: \"sema\", name: \"sema\", exported: false, typ: $Uint32, tag: \"\"}]);\n\tLocker.init([{prop: \"Lock\", name: \"Lock\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"Unlock\", name: \"Unlock\", pkg: \"\", typ: $funcType([], [], false)}]);\n\tOnce.init(\"sync\", [{prop: \"m\", name: \"m\", exported: false, typ: Mutex, tag: \"\"}, {prop: \"done\", name: \"done\", exported: false, typ: $Uint32, tag: \"\"}]);\n\tpoolLocal.init(\"sync\", [{prop: \"private$0\", name: \"private\", exported: false, typ: $emptyInterface, tag: \"\"}, {prop: \"shared\", name: \"shared\", exported: false, typ: sliceType$3, tag: \"\"}, {prop: \"Mutex\", name: \"\", exported: true, typ: Mutex, tag: \"\"}, {prop: \"pad\", name: \"pad\", exported: false, typ: arrayType$1, tag: \"\"}]);\n\tnotifyList.init(\"sync\", [{prop: \"wait\", name: \"wait\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"notify\", name: \"notify\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"lock\", name: \"lock\", exported: false, typ: $Uintptr, tag: \"\"}, {prop: \"head\", name: \"head\", exported: false, typ: $UnsafePointer, tag: \"\"}, {prop: \"tail\", name: \"tail\", exported: false, typ: $UnsafePointer, tag: \"\"}]);\n\tRWMutex.init(\"sync\", [{prop: \"w\", name: \"w\", exported: false, typ: Mutex, tag: \"\"}, {prop: \"writerSem\", name: \"writerSem\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"readerSem\", name: \"readerSem\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"readerCount\", name: \"readerCount\", exported: false, typ: $Int32, tag: \"\"}, {prop: \"readerWait\", name: \"readerWait\", exported: false, typ: $Int32, tag: \"\"}]);\n\trlocker.init(\"sync\", [{prop: \"w\", name: \"w\", exported: false, typ: Mutex, tag: \"\"}, {prop: \"writerSem\", name: \"writerSem\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"readerSem\", name: \"readerSem\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"readerCount\", name: \"readerCount\", exported: false, typ: $Int32, tag: \"\"}, {prop: \"readerWait\", name: \"readerWait\", exported: false, typ: $Int32, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = race.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = runtime.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = atomic.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tallPools = sliceType.nil;\n\t\tsemWaiters = {};\n\t\tinit();\n\t\tinit$1();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"io\"] = (function() {\n\tvar $pkg = {}, $init, errors, sync, RuneScanner, errWhence, errOffset;\n\terrors = $packages[\"errors\"];\n\tsync = $packages[\"sync\"];\n\tRuneScanner = $pkg.RuneScanner = $newType(8, $kindInterface, \"io.RuneScanner\", true, \"io\", true, null);\n\tRuneScanner.init([{prop: \"ReadRune\", name: \"ReadRune\", pkg: \"\", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: \"UnreadRune\", name: \"UnreadRune\", pkg: \"\", typ: $funcType([], [$error], false)}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = sync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$pkg.ErrShortWrite = errors.New(\"short write\");\n\t\t$pkg.ErrShortBuffer = errors.New(\"short buffer\");\n\t\t$pkg.EOF = errors.New(\"EOF\");\n\t\t$pkg.ErrUnexpectedEOF = errors.New(\"unexpected EOF\");\n\t\t$pkg.ErrNoProgress = errors.New(\"multiple Read calls return no data or error\");\n\t\terrWhence = errors.New(\"Seek: invalid whence\");\n\t\terrOffset = errors.New(\"Seek: invalid offset\");\n\t\t$pkg.ErrClosedPipe = errors.New(\"io: read/write on closed pipe\");\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"math\"] = (function() {\n\tvar $pkg = {}, $init, js, arrayType, arrayType$1, arrayType$2, structType, arrayType$3, math, buf, pow10tab, init, Float32bits, Float64bits, init$1;\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tarrayType = $arrayType($Uint32, 2);\n\tarrayType$1 = $arrayType($Float32, 2);\n\tarrayType$2 = $arrayType($Float64, 1);\n\tstructType = $structType(\"math\", [{prop: \"uint32array\", name: \"uint32array\", exported: false, typ: arrayType, tag: \"\"}, {prop: \"float32array\", name: \"float32array\", exported: false, typ: arrayType$1, tag: \"\"}, {prop: \"float64array\", name: \"float64array\", exported: false, typ: arrayType$2, tag: \"\"}]);\n\tarrayType$3 = $arrayType($Float64, 70);\n\tinit = function() {\n\t\tvar $ptr, ab;\n\t\tab = new ($global.ArrayBuffer)(8);\n\t\tbuf.uint32array = new ($global.Uint32Array)(ab);\n\t\tbuf.float32array = new ($global.Float32Array)(ab);\n\t\tbuf.float64array = new ($global.Float64Array)(ab);\n\t};\n\tFloat32bits = function(f) {\n\t\tvar $ptr, f;\n\t\tbuf.float32array[0] = f;\n\t\treturn buf.uint32array[0];\n\t};\n\t$pkg.Float32bits = Float32bits;\n\tFloat64bits = function(f) {\n\t\tvar $ptr, f, x, x$1;\n\t\tbuf.float64array[0] = f;\n\t\treturn (x = $shiftLeft64(new $Uint64(0, buf.uint32array[1]), 32), x$1 = new $Uint64(0, buf.uint32array[0]), new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));\n\t};\n\t$pkg.Float64bits = Float64bits;\n\tinit$1 = function() {\n\t\tvar $ptr, _q, i, m, x;\n\t\tpow10tab[0] = 1;\n\t\tpow10tab[1] = 10;\n\t\ti = 2;\n\t\twhile (true) {\n\t\t\tif (!(i < 70)) { break; }\n\t\t\tm = (_q = i / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t((i < 0 || i >= pow10tab.length) ? $throwRuntimeError(\"index out of range\") : pow10tab[i] = ((m < 0 || m >= pow10tab.length) ? $throwRuntimeError(\"index out of range\") : pow10tab[m]) * (x = i - m >> 0, ((x < 0 || x >= pow10tab.length) ? $throwRuntimeError(\"index out of range\") : pow10tab[x])));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t};\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tbuf = new structType.ptr(arrayType.zero(), arrayType$1.zero(), arrayType$2.zero());\n\t\tpow10tab = arrayType$3.zero();\n\t\tmath = $global.Math;\n\t\tinit();\n\t\tinit$1();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"syscall\"] = (function() {\n\tvar $pkg = {}, $init, errors, js, race, runtime, sync, mmapper, Errno, _C_int, Timespec, Stat_t, Dirent, sliceType, sliceType$1, ptrType$2, arrayType$1, sliceType$5, ptrType$12, arrayType$10, arrayType$13, arrayType$14, arrayType$15, structType, ptrType$20, ptrType$27, mapType, funcType, funcType$1, ptrType$31, arrayType$17, warningPrinted, lineBuffer, syscallModule, alreadyTriedToLoad, minusOne, envOnce, envLock, env, envs, freebsdConfArch, minRoutingSockaddrLen, mapper, errEAGAIN, errEINVAL, errENOENT, ioSync, ioSync$24ptr, errors$1, init, printWarning, printToConsole, use, indexByte, runtime_envs, syscall, Syscall, Syscall6, BytePtrFromString, copyenv, Getenv, msanRead, msanWrite, rsaAlignOf, itoa, uitoa, ByteSliceFromString, ReadDirent, Sysctl, nametomib, ParseDirent, errnoErr, Read, Write, sysctl, Close, Fchdir, Fchmod, Fchown, Fstat, Fsync, Ftruncate, Getdirentries, Lstat, Pread, Pwrite, read, Seek, write, mmap, munmap;\n\terrors = $packages[\"errors\"];\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\trace = $packages[\"internal/race\"];\n\truntime = $packages[\"runtime\"];\n\tsync = $packages[\"sync\"];\n\tmmapper = $pkg.mmapper = $newType(0, $kindStruct, \"syscall.mmapper\", true, \"syscall\", false, function(Mutex_, active_, mmap_, munmap_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Mutex = new sync.Mutex.ptr(0, 0);\n\t\t\tthis.active = false;\n\t\t\tthis.mmap = $throwNilPointerError;\n\t\t\tthis.munmap = $throwNilPointerError;\n\t\t\treturn;\n\t\t}\n\t\tthis.Mutex = Mutex_;\n\t\tthis.active = active_;\n\t\tthis.mmap = mmap_;\n\t\tthis.munmap = munmap_;\n\t});\n\tErrno = $pkg.Errno = $newType(4, $kindUintptr, \"syscall.Errno\", true, \"syscall\", true, null);\n\t_C_int = $pkg._C_int = $newType(4, $kindInt32, \"syscall._C_int\", true, \"syscall\", false, null);\n\tTimespec = $pkg.Timespec = $newType(0, $kindStruct, \"syscall.Timespec\", true, \"syscall\", true, function(Sec_, Nsec_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Sec = new $Int64(0, 0);\n\t\t\tthis.Nsec = new $Int64(0, 0);\n\t\t\treturn;\n\t\t}\n\t\tthis.Sec = Sec_;\n\t\tthis.Nsec = Nsec_;\n\t});\n\tStat_t = $pkg.Stat_t = $newType(0, $kindStruct, \"syscall.Stat_t\", true, \"syscall\", true, function(Dev_, Mode_, Nlink_, Ino_, Uid_, Gid_, Rdev_, Pad_cgo_0_, Atimespec_, Mtimespec_, Ctimespec_, Birthtimespec_, Size_, Blocks_, Blksize_, Flags_, Gen_, Lspare_, Qspare_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Dev = 0;\n\t\t\tthis.Mode = 0;\n\t\t\tthis.Nlink = 0;\n\t\t\tthis.Ino = new $Uint64(0, 0);\n\t\t\tthis.Uid = 0;\n\t\t\tthis.Gid = 0;\n\t\t\tthis.Rdev = 0;\n\t\t\tthis.Pad_cgo_0 = arrayType$1.zero();\n\t\t\tthis.Atimespec = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));\n\t\t\tthis.Mtimespec = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));\n\t\t\tthis.Ctimespec = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));\n\t\t\tthis.Birthtimespec = new Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0));\n\t\t\tthis.Size = new $Int64(0, 0);\n\t\t\tthis.Blocks = new $Int64(0, 0);\n\t\t\tthis.Blksize = 0;\n\t\t\tthis.Flags = 0;\n\t\t\tthis.Gen = 0;\n\t\t\tthis.Lspare = 0;\n\t\t\tthis.Qspare = arrayType$17.zero();\n\t\t\treturn;\n\t\t}\n\t\tthis.Dev = Dev_;\n\t\tthis.Mode = Mode_;\n\t\tthis.Nlink = Nlink_;\n\t\tthis.Ino = Ino_;\n\t\tthis.Uid = Uid_;\n\t\tthis.Gid = Gid_;\n\t\tthis.Rdev = Rdev_;\n\t\tthis.Pad_cgo_0 = Pad_cgo_0_;\n\t\tthis.Atimespec = Atimespec_;\n\t\tthis.Mtimespec = Mtimespec_;\n\t\tthis.Ctimespec = Ctimespec_;\n\t\tthis.Birthtimespec = Birthtimespec_;\n\t\tthis.Size = Size_;\n\t\tthis.Blocks = Blocks_;\n\t\tthis.Blksize = Blksize_;\n\t\tthis.Flags = Flags_;\n\t\tthis.Gen = Gen_;\n\t\tthis.Lspare = Lspare_;\n\t\tthis.Qspare = Qspare_;\n\t});\n\tDirent = $pkg.Dirent = $newType(0, $kindStruct, \"syscall.Dirent\", true, \"syscall\", true, function(Ino_, Seekoff_, Reclen_, Namlen_, Type_, Name_, Pad_cgo_0_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Ino = new $Uint64(0, 0);\n\t\t\tthis.Seekoff = new $Uint64(0, 0);\n\t\t\tthis.Reclen = 0;\n\t\t\tthis.Namlen = 0;\n\t\t\tthis.Type = 0;\n\t\t\tthis.Name = arrayType$14.zero();\n\t\t\tthis.Pad_cgo_0 = arrayType$15.zero();\n\t\t\treturn;\n\t\t}\n\t\tthis.Ino = Ino_;\n\t\tthis.Seekoff = Seekoff_;\n\t\tthis.Reclen = Reclen_;\n\t\tthis.Namlen = Namlen_;\n\t\tthis.Type = Type_;\n\t\tthis.Name = Name_;\n\t\tthis.Pad_cgo_0 = Pad_cgo_0_;\n\t});\n\tsliceType = $sliceType($Uint8);\n\tsliceType$1 = $sliceType($String);\n\tptrType$2 = $ptrType($Uint8);\n\tarrayType$1 = $arrayType($Uint8, 4);\n\tsliceType$5 = $sliceType(_C_int);\n\tptrType$12 = $ptrType($Uintptr);\n\tarrayType$10 = $arrayType($Uint8, 32);\n\tarrayType$13 = $arrayType(_C_int, 14);\n\tarrayType$14 = $arrayType($Int8, 1024);\n\tarrayType$15 = $arrayType($Uint8, 3);\n\tstructType = $structType(\"syscall\", [{prop: \"addr\", name: \"addr\", exported: false, typ: $Uintptr, tag: \"\"}, {prop: \"len\", name: \"len\", exported: false, typ: $Int, tag: \"\"}, {prop: \"cap\", name: \"cap\", exported: false, typ: $Int, tag: \"\"}]);\n\tptrType$20 = $ptrType($Int64);\n\tptrType$27 = $ptrType(mmapper);\n\tmapType = $mapType(ptrType$2, sliceType);\n\tfuncType = $funcType([$Uintptr, $Uintptr, $Int, $Int, $Int, $Int64], [$Uintptr, $error], false);\n\tfuncType$1 = $funcType([$Uintptr, $Uintptr], [$error], false);\n\tptrType$31 = $ptrType(Timespec);\n\tarrayType$17 = $arrayType($Int64, 2);\n\tinit = function() {\n\t\tvar $ptr;\n\t\t$flushConsole = (function() {\n\t\t\tvar $ptr;\n\t\t\tif (!((lineBuffer.$length === 0))) {\n\t\t\t\t$global.console.log($externalize($bytesToString(lineBuffer), $String));\n\t\t\t\tlineBuffer = sliceType.nil;\n\t\t\t}\n\t\t});\n\t};\n\tprintWarning = function() {\n\t\tvar $ptr;\n\t\tif (!warningPrinted) {\n\t\t\t$global.console.error($externalize(\"warning: system calls not available, see https://github.com/gopherjs/gopherjs/blob/master/doc/syscalls.md\", $String));\n\t\t}\n\t\twarningPrinted = true;\n\t};\n\tprintToConsole = function(b) {\n\t\tvar $ptr, b, goPrintToConsole, i;\n\t\tgoPrintToConsole = $global.goPrintToConsole;\n\t\tif (!(goPrintToConsole === undefined)) {\n\t\t\tgoPrintToConsole(b);\n\t\t\treturn;\n\t\t}\n\t\tlineBuffer = $appendSlice(lineBuffer, b);\n\t\twhile (true) {\n\t\t\ti = indexByte(lineBuffer, 10);\n\t\t\tif (i === -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$global.console.log($externalize($bytesToString($subslice(lineBuffer, 0, i)), $String));\n\t\t\tlineBuffer = $subslice(lineBuffer, (i + 1 >> 0));\n\t\t}\n\t};\n\tuse = function(p) {\n\t\tvar $ptr, p;\n\t};\n\tindexByte = function(s, c) {\n\t\tvar $ptr, _i, _ref, b, c, i, s;\n\t\t_ref = s;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\tb = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tif (b === c) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\treturn -1;\n\t};\n\truntime_envs = function() {\n\t\tvar $ptr, envkeys, envs$1, i, jsEnv, key, process;\n\t\tprocess = $global.process;\n\t\tif (process === undefined) {\n\t\t\treturn sliceType$1.nil;\n\t\t}\n\t\tjsEnv = process.env;\n\t\tenvkeys = $global.Object.keys(jsEnv);\n\t\tenvs$1 = $makeSlice(sliceType$1, $parseInt(envkeys.length));\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < $parseInt(envkeys.length))) { break; }\n\t\t\tkey = $internalize(envkeys[i], $String);\n\t\t\t((i < 0 || i >= envs$1.$length) ? $throwRuntimeError(\"index out of range\") : envs$1.$array[envs$1.$offset + i] = key + \"=\" + $internalize(jsEnv[$externalize(key, $String)], $String));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\treturn envs$1;\n\t};\n\tsyscall = function(name) {\n\t\tvar $ptr, name, require, $deferred;\n\t\t/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\t$deferred.push([(function() {\n\t\t\tvar $ptr;\n\t\t\t$recover();\n\t\t}), []]);\n\t\tif (syscallModule === null) {\n\t\t\tif (alreadyTriedToLoad) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\talreadyTriedToLoad = true;\n\t\t\trequire = $global.require;\n\t\t\tif (require === undefined) {\n\t\t\t\t$panic(new $String(\"\"));\n\t\t\t}\n\t\t\tsyscallModule = require($externalize(\"syscall\", $String));\n\t\t}\n\t\treturn syscallModule[$externalize(name, $String)];\n\t\t/* */ } catch(err) { $err = err; return null; } finally { $callDeferred($deferred, $err); }\n\t};\n\tSyscall = function(trap, a1, a2, a3) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, a1, a2, a3, array, err, f, r, r1, r2, slice, trap;\n\t\tr1 = 0;\n\t\tr2 = 0;\n\t\terr = 0;\n\t\tf = syscall(\"Syscall\");\n\t\tif (!(f === null)) {\n\t\t\tr = f(trap, a1, a2, a3);\n\t\t\t_tmp = (($parseInt(r[0]) >> 0) >>> 0);\n\t\t\t_tmp$1 = (($parseInt(r[1]) >> 0) >>> 0);\n\t\t\t_tmp$2 = (($parseInt(r[2]) >> 0) >>> 0);\n\t\t\tr1 = _tmp;\n\t\t\tr2 = _tmp$1;\n\t\t\terr = _tmp$2;\n\t\t\treturn [r1, r2, err];\n\t\t}\n\t\tif ((trap === 4) && ((a1 === 1) || (a1 === 2))) {\n\t\t\tarray = a2;\n\t\t\tslice = $makeSlice(sliceType, $parseInt(array.length));\n\t\t\tslice.$array = array;\n\t\t\tprintToConsole(slice);\n\t\t\t_tmp$3 = ($parseInt(array.length) >>> 0);\n\t\t\t_tmp$4 = 0;\n\t\t\t_tmp$5 = 0;\n\t\t\tr1 = _tmp$3;\n\t\t\tr2 = _tmp$4;\n\t\t\terr = _tmp$5;\n\t\t\treturn [r1, r2, err];\n\t\t}\n\t\tif (trap === 1) {\n\t\t\truntime.Goexit();\n\t\t}\n\t\tprintWarning();\n\t\t_tmp$6 = (minusOne >>> 0);\n\t\t_tmp$7 = 0;\n\t\t_tmp$8 = 13;\n\t\tr1 = _tmp$6;\n\t\tr2 = _tmp$7;\n\t\terr = _tmp$8;\n\t\treturn [r1, r2, err];\n\t};\n\t$pkg.Syscall = Syscall;\n\tSyscall6 = function(trap, a1, a2, a3, a4, a5, a6) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, a1, a2, a3, a4, a5, a6, err, f, r, r1, r2, trap;\n\t\tr1 = 0;\n\t\tr2 = 0;\n\t\terr = 0;\n\t\tf = syscall(\"Syscall6\");\n\t\tif (!(f === null)) {\n\t\t\tr = f(trap, a1, a2, a3, a4, a5, a6);\n\t\t\t_tmp = (($parseInt(r[0]) >> 0) >>> 0);\n\t\t\t_tmp$1 = (($parseInt(r[1]) >> 0) >>> 0);\n\t\t\t_tmp$2 = (($parseInt(r[2]) >> 0) >>> 0);\n\t\t\tr1 = _tmp;\n\t\t\tr2 = _tmp$1;\n\t\t\terr = _tmp$2;\n\t\t\treturn [r1, r2, err];\n\t\t}\n\t\tif (!((trap === 202))) {\n\t\t\tprintWarning();\n\t\t}\n\t\t_tmp$3 = (minusOne >>> 0);\n\t\t_tmp$4 = 0;\n\t\t_tmp$5 = 13;\n\t\tr1 = _tmp$3;\n\t\tr2 = _tmp$4;\n\t\terr = _tmp$5;\n\t\treturn [r1, r2, err];\n\t};\n\t$pkg.Syscall6 = Syscall6;\n\tBytePtrFromString = function(s) {\n\t\tvar $ptr, _i, _ref, array, b, i, s;\n\t\tarray = new ($global.Uint8Array)(s.length + 1 >> 0);\n\t\t_ref = new sliceType($stringToBytes(s));\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\tb = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tif (b === 0) {\n\t\t\t\treturn [ptrType$2.nil, new Errno(22)];\n\t\t\t}\n\t\t\tarray[i] = b;\n\t\t\t_i++;\n\t\t}\n\t\tarray[s.length] = 0;\n\t\treturn [array, $ifaceNil];\n\t};\n\t$pkg.BytePtrFromString = BytePtrFromString;\n\tcopyenv = function() {\n\t\tvar $ptr, _entry, _i, _key, _ref, _tuple, i, j, key, ok, s;\n\t\tenv = {};\n\t\t_ref = envs;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\ts = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tj = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(j < s.length)) { break; }\n\t\t\t\tif (s.charCodeAt(j) === 61) {\n\t\t\t\t\tkey = $substring(s, 0, j);\n\t\t\t\t\t_tuple = (_entry = env[$String.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [0, false]);\n\t\t\t\t\tok = _tuple[1];\n\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t_key = key; (env || $throwRuntimeError(\"assignment to entry in nil map\"))[$String.keyFor(_key)] = { k: _key, v: i };\n\t\t\t\t\t} else {\n\t\t\t\t\t\t((i < 0 || i >= envs.$length) ? $throwRuntimeError(\"index out of range\") : envs.$array[envs.$offset + i] = \"\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj = j + (1) >> 0;\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t};\n\tGetenv = function(key) {\n\t\tvar $ptr, _entry, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, found, i, i$1, key, ok, s, value, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _entry = $f._entry; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tuple = $f._tuple; found = $f.found; i = $f.i; i$1 = $f.i$1; key = $f.key; ok = $f.ok; s = $f.s; value = $f.value; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\tvalue = \"\";\n\t\tfound = false;\n\t\t$r = envOnce.Do(copyenv); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tif (key.length === 0) {\n\t\t\t_tmp = \"\";\n\t\t\t_tmp$1 = false;\n\t\t\tvalue = _tmp;\n\t\t\tfound = _tmp$1;\n\t\t\t$s = -1; return [value, found];\n\t\t}\n\t\t$r = envLock.RLock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$deferred.push([$methodVal(envLock, \"RUnlock\"), []]);\n\t\t_tuple = (_entry = env[$String.keyFor(key)], _entry !== undefined ? [_entry.v, true] : [0, false]);\n\t\ti = _tuple[0];\n\t\tok = _tuple[1];\n\t\tif (!ok) {\n\t\t\t_tmp$2 = \"\";\n\t\t\t_tmp$3 = false;\n\t\t\tvalue = _tmp$2;\n\t\t\tfound = _tmp$3;\n\t\t\t$s = -1; return [value, found];\n\t\t}\n\t\ts = ((i < 0 || i >= envs.$length) ? $throwRuntimeError(\"index out of range\") : envs.$array[envs.$offset + i]);\n\t\ti$1 = 0;\n\t\twhile (true) {\n\t\t\tif (!(i$1 < s.length)) { break; }\n\t\t\tif (s.charCodeAt(i$1) === 61) {\n\t\t\t\t_tmp$4 = $substring(s, (i$1 + 1 >> 0));\n\t\t\t\t_tmp$5 = true;\n\t\t\t\tvalue = _tmp$4;\n\t\t\t\tfound = _tmp$5;\n\t\t\t\t$s = -1; return [value, found];\n\t\t\t}\n\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t}\n\t\t_tmp$6 = \"\";\n\t\t_tmp$7 = false;\n\t\tvalue = _tmp$6;\n\t\tfound = _tmp$7;\n\t\t$s = -1; return [value, found];\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [value, found]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Getenv }; } $f.$ptr = $ptr; $f._entry = _entry; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tuple = _tuple; $f.found = found; $f.i = i; $f.i$1 = i$1; $f.key = key; $f.ok = ok; $f.s = s; $f.value = value; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\t$pkg.Getenv = Getenv;\n\tmsanRead = function(addr, len) {\n\t\tvar $ptr, addr, len;\n\t};\n\tmsanWrite = function(addr, len) {\n\t\tvar $ptr, addr, len;\n\t};\n\trsaAlignOf = function(salen) {\n\t\tvar $ptr, salen, salign;\n\t\tsalign = 8;\n\t\tif (true) {\n\t\t\tsalign = 4;\n\t\t} else if (false) {\n\t\t\tsalign = 8;\n\t\t} else if (false) {\n\t\t\tif (freebsdConfArch === \"amd64\") {\n\t\t\t\tsalign = 8;\n\t\t\t}\n\t\t}\n\t\tif (salen === 0) {\n\t\t\treturn salign;\n\t\t}\n\t\treturn (((salen + salign >> 0) - 1 >> 0)) & (~((salign - 1 >> 0)) >> 0);\n\t};\n\titoa = function(val) {\n\t\tvar $ptr, val;\n\t\tif (val < 0) {\n\t\t\treturn \"-\" + uitoa((-val >>> 0));\n\t\t}\n\t\treturn uitoa((val >>> 0));\n\t};\n\tuitoa = function(val) {\n\t\tvar $ptr, _q, _r, buf, i, val;\n\t\tbuf = arrayType$10.zero();\n\t\ti = 31;\n\t\twhile (true) {\n\t\t\tif (!(val >= 10)) { break; }\n\t\t\t((i < 0 || i >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[i] = (((_r = val % 10, _r === _r ? _r : $throwRuntimeError(\"integer divide by zero\")) + 48 >>> 0) << 24 >>> 24));\n\t\t\ti = i - (1) >> 0;\n\t\t\tval = (_q = val / (10), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t}\n\t\t((i < 0 || i >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[i] = ((val + 48 >>> 0) << 24 >>> 24));\n\t\treturn $bytesToString($subslice(new sliceType(buf), i));\n\t};\n\tByteSliceFromString = function(s) {\n\t\tvar $ptr, a, i, s;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < s.length)) { break; }\n\t\t\tif (s.charCodeAt(i) === 0) {\n\t\t\t\treturn [sliceType.nil, new Errno(22)];\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\ta = $makeSlice(sliceType, (s.length + 1 >> 0));\n\t\t$copyString(a, s);\n\t\treturn [a, $ifaceNil];\n\t};\n\t$pkg.ByteSliceFromString = ByteSliceFromString;\n\tTimespec.ptr.prototype.Unix = function() {\n\t\tvar $ptr, _tmp, _tmp$1, nsec, sec, ts;\n\t\tsec = new $Int64(0, 0);\n\t\tnsec = new $Int64(0, 0);\n\t\tts = this;\n\t\t_tmp = ts.Sec;\n\t\t_tmp$1 = ts.Nsec;\n\t\tsec = _tmp;\n\t\tnsec = _tmp$1;\n\t\treturn [sec, nsec];\n\t};\n\tTimespec.prototype.Unix = function() { return this.$val.Unix(); };\n\tTimespec.ptr.prototype.Nano = function() {\n\t\tvar $ptr, ts, x, x$1;\n\t\tts = this;\n\t\treturn (x = $mul64(ts.Sec, new $Int64(0, 1000000000)), x$1 = ts.Nsec, new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));\n\t};\n\tTimespec.prototype.Nano = function() { return this.$val.Nano(); };\n\tReadDirent = function(fd, buf) {\n\t\tvar $ptr, _tuple, base, buf, err, fd, n;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tbase = new Uint8Array(8);\n\t\t_tuple = Getdirentries(fd, buf, base);\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [n, err];\n\t};\n\t$pkg.ReadDirent = ReadDirent;\n\tSysctl = function(name) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, buf, err, mib, n, n$24ptr, name, value, x;\n\t\tvalue = \"\";\n\t\terr = $ifaceNil;\n\t\t_tuple = nametomib(name);\n\t\tmib = _tuple[0];\n\t\terr = _tuple[1];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t_tmp = \"\";\n\t\t\t_tmp$1 = err;\n\t\t\tvalue = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [value, err];\n\t\t}\n\t\tn = 0;\n\t\terr = sysctl(mib, ptrType$2.nil, (n$24ptr || (n$24ptr = new ptrType$12(function() { return n; }, function($v) { n = $v; }))), ptrType$2.nil, 0);\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t_tmp$2 = \"\";\n\t\t\t_tmp$3 = err;\n\t\t\tvalue = _tmp$2;\n\t\t\terr = _tmp$3;\n\t\t\treturn [value, err];\n\t\t}\n\t\tif (n === 0) {\n\t\t\t_tmp$4 = \"\";\n\t\t\t_tmp$5 = $ifaceNil;\n\t\t\tvalue = _tmp$4;\n\t\t\terr = _tmp$5;\n\t\t\treturn [value, err];\n\t\t}\n\t\tbuf = $makeSlice(sliceType, n);\n\t\terr = sysctl(mib, $indexPtr(buf.$array, buf.$offset + 0, ptrType$2), (n$24ptr || (n$24ptr = new ptrType$12(function() { return n; }, function($v) { n = $v; }))), ptrType$2.nil, 0);\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t_tmp$6 = \"\";\n\t\t\t_tmp$7 = err;\n\t\t\tvalue = _tmp$6;\n\t\t\terr = _tmp$7;\n\t\t\treturn [value, err];\n\t\t}\n\t\tif (n > 0 && ((x = n - 1 >>> 0, ((x < 0 || x >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + x])) === 0)) {\n\t\t\tn = n - (1) >>> 0;\n\t\t}\n\t\t_tmp$8 = $bytesToString($subslice(buf, 0, n));\n\t\t_tmp$9 = $ifaceNil;\n\t\tvalue = _tmp$8;\n\t\terr = _tmp$9;\n\t\treturn [value, err];\n\t};\n\t$pkg.Sysctl = Sysctl;\n\tnametomib = function(name) {\n\t\tvar $ptr, _q, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, buf, bytes, err, mib, n, n$24ptr, name, p;\n\t\tmib = sliceType$5.nil;\n\t\terr = $ifaceNil;\n\t\tbuf = arrayType$13.zero();\n\t\tn = 48;\n\t\tp = $sliceToArray(new sliceType(buf));\n\t\t_tuple = ByteSliceFromString(name);\n\t\tbytes = _tuple[0];\n\t\terr = _tuple[1];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t_tmp = sliceType$5.nil;\n\t\t\t_tmp$1 = err;\n\t\t\tmib = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [mib, err];\n\t\t}\n\t\terr = sysctl(new sliceType$5([0, 3]), p, (n$24ptr || (n$24ptr = new ptrType$12(function() { return n; }, function($v) { n = $v; }))), $indexPtr(bytes.$array, bytes.$offset + 0, ptrType$2), (name.length >>> 0));\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t_tmp$2 = sliceType$5.nil;\n\t\t\t_tmp$3 = err;\n\t\t\tmib = _tmp$2;\n\t\t\terr = _tmp$3;\n\t\t\treturn [mib, err];\n\t\t}\n\t\t_tmp$4 = $subslice(new sliceType$5(buf), 0, (_q = n / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\")));\n\t\t_tmp$5 = $ifaceNil;\n\t\tmib = _tmp$4;\n\t\terr = _tmp$5;\n\t\treturn [mib, err];\n\t};\n\tParseDirent = function(buf, max, names) {\n\t\tvar $ptr, _array, _struct, _tmp, _tmp$1, _tmp$2, _view, buf, bytes, consumed, count, dirent, max, name, names, newnames, origlen, x;\n\t\tconsumed = 0;\n\t\tcount = 0;\n\t\tnewnames = sliceType$1.nil;\n\t\toriglen = buf.$length;\n\t\twhile (true) {\n\t\t\tif (!(!((max === 0)) && buf.$length > 0)) { break; }\n\t\t\tdirent = (_array = $sliceToArray(buf), _struct = new Dirent.ptr(new $Uint64(0, 0), new $Uint64(0, 0), 0, 0, 0, arrayType$14.zero(), arrayType$15.zero()), _view = new DataView(_array.buffer, _array.byteOffset), _struct.Ino = new $Uint64(_view.getUint32(4, true), _view.getUint32(0, true)), _struct.Seekoff = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Reclen = _view.getUint16(16, true), _struct.Namlen = _view.getUint16(18, true), _struct.Type = _view.getUint8(20, true), _struct.Name = new ($nativeArray($kindInt8))(_array.buffer, $min(_array.byteOffset + 21, _array.buffer.byteLength)), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 1045, _array.buffer.byteLength)), _struct);\n\t\t\tif (dirent.Reclen === 0) {\n\t\t\t\tbuf = sliceType.nil;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf = $subslice(buf, dirent.Reclen);\n\t\t\tif ((x = dirent.Ino, (x.$high === 0 && x.$low === 0))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbytes = $sliceToArray(new sliceType(dirent.Name));\n\t\t\tname = $bytesToString($subslice(new sliceType(bytes), 0, dirent.Namlen));\n\t\t\tif (name === \".\" || name === \"..\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmax = max - (1) >> 0;\n\t\t\tcount = count + (1) >> 0;\n\t\t\tnames = $append(names, name);\n\t\t}\n\t\t_tmp = origlen - buf.$length >> 0;\n\t\t_tmp$1 = count;\n\t\t_tmp$2 = names;\n\t\tconsumed = _tmp;\n\t\tcount = _tmp$1;\n\t\tnewnames = _tmp$2;\n\t\treturn [consumed, count, newnames];\n\t};\n\t$pkg.ParseDirent = ParseDirent;\n\tmmapper.ptr.prototype.Mmap = function(fd, offset, length, prot, flags) {\n\t\tvar $ptr, _key, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, addr, b, data, err, errno, fd, flags, length, m, offset, p, prot, sl, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _key = $f._key; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; addr = $f.addr; b = $f.b; data = $f.data; err = $f.err; errno = $f.errno; fd = $f.fd; flags = $f.flags; length = $f.length; m = $f.m; offset = $f.offset; p = $f.p; prot = $f.prot; sl = $f.sl; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\tsl = [sl];\n\t\tdata = sliceType.nil;\n\t\terr = $ifaceNil;\n\t\tm = this;\n\t\tif (length <= 0) {\n\t\t\t_tmp = sliceType.nil;\n\t\t\t_tmp$1 = new Errno(22);\n\t\t\tdata = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\t$s = -1; return [data, err];\n\t\t}\n\t\t_r = m.mmap(0, (length >>> 0), prot, flags, fd, offset); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\taddr = _tuple[0];\n\t\terrno = _tuple[1];\n\t\tif (!($interfaceIsEqual(errno, $ifaceNil))) {\n\t\t\t_tmp$2 = sliceType.nil;\n\t\t\t_tmp$3 = errno;\n\t\t\tdata = _tmp$2;\n\t\t\terr = _tmp$3;\n\t\t\t$s = -1; return [data, err];\n\t\t}\n\t\tsl[0] = new structType.ptr(addr, length, length);\n\t\tb = sl[0];\n\t\tp = $indexPtr(b.$array, b.$offset + (b.$capacity - 1 >> 0), ptrType$2);\n\t\t$r = m.Mutex.Lock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$deferred.push([$methodVal(m.Mutex, \"Unlock\"), []]);\n\t\t_key = p; (m.active || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$2.keyFor(_key)] = { k: _key, v: b };\n\t\t_tmp$4 = b;\n\t\t_tmp$5 = $ifaceNil;\n\t\tdata = _tmp$4;\n\t\terr = _tmp$5;\n\t\t$s = -1; return [data, err];\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [data, err]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mmapper.ptr.prototype.Mmap }; } $f.$ptr = $ptr; $f._key = _key; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.addr = addr; $f.b = b; $f.data = data; $f.err = err; $f.errno = errno; $f.fd = fd; $f.flags = flags; $f.length = length; $f.m = m; $f.offset = offset; $f.p = p; $f.prot = prot; $f.sl = sl; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\tmmapper.prototype.Mmap = function(fd, offset, length, prot, flags) { return this.$val.Mmap(fd, offset, length, prot, flags); };\n\tmmapper.ptr.prototype.Munmap = function(data) {\n\t\tvar $ptr, _entry, _r, b, data, err, errno, m, p, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _entry = $f._entry; _r = $f._r; b = $f.b; data = $f.data; err = $f.err; errno = $f.errno; m = $f.m; p = $f.p; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\terr = $ifaceNil;\n\t\tm = this;\n\t\tif ((data.$length === 0) || !((data.$length === data.$capacity))) {\n\t\t\terr = new Errno(22);\n\t\t\t$s = -1; return err;\n\t\t}\n\t\tp = $indexPtr(data.$array, data.$offset + (data.$capacity - 1 >> 0), ptrType$2);\n\t\t$r = m.Mutex.Lock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$deferred.push([$methodVal(m.Mutex, \"Unlock\"), []]);\n\t\tb = (_entry = m.active[ptrType$2.keyFor(p)], _entry !== undefined ? _entry.v : sliceType.nil);\n\t\tif (b === sliceType.nil || !($indexPtr(b.$array, b.$offset + 0, ptrType$2) === $indexPtr(data.$array, data.$offset + 0, ptrType$2))) {\n\t\t\terr = new Errno(22);\n\t\t\t$s = -1; return err;\n\t\t}\n\t\t_r = m.munmap($sliceToArray(b), (b.$length >>> 0)); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\terrno = _r;\n\t\tif (!($interfaceIsEqual(errno, $ifaceNil))) {\n\t\t\terr = errno;\n\t\t\t$s = -1; return err;\n\t\t}\n\t\tdelete m.active[ptrType$2.keyFor(p)];\n\t\terr = $ifaceNil;\n\t\t$s = -1; return err;\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  err; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: mmapper.ptr.prototype.Munmap }; } $f.$ptr = $ptr; $f._entry = _entry; $f._r = _r; $f.b = b; $f.data = data; $f.err = err; $f.errno = errno; $f.m = m; $f.p = p; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\tmmapper.prototype.Munmap = function(data) { return this.$val.Munmap(data); };\n\tErrno.prototype.Error = function() {\n\t\tvar $ptr, e, s;\n\t\te = this.$val;\n\t\tif (0 <= (e >> 0) && (e >> 0) < 106) {\n\t\t\ts = ((e < 0 || e >= errors$1.length) ? $throwRuntimeError(\"index out of range\") : errors$1[e]);\n\t\t\tif (!(s === \"\")) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn \"errno \" + itoa((e >> 0));\n\t};\n\t$ptrType(Errno).prototype.Error = function() { return new Errno(this.$get()).Error(); };\n\tErrno.prototype.Temporary = function() {\n\t\tvar $ptr, e;\n\t\te = this.$val;\n\t\treturn (e === 4) || (e === 24) || (e === 54) || (e === 53) || new Errno(e).Timeout();\n\t};\n\t$ptrType(Errno).prototype.Temporary = function() { return new Errno(this.$get()).Temporary(); };\n\tErrno.prototype.Timeout = function() {\n\t\tvar $ptr, e;\n\t\te = this.$val;\n\t\treturn (e === 35) || (e === 35) || (e === 60);\n\t};\n\t$ptrType(Errno).prototype.Timeout = function() { return new Errno(this.$get()).Timeout(); };\n\terrnoErr = function(e) {\n\t\tvar $ptr, _1, e;\n\t\t_1 = e;\n\t\tif (_1 === (0)) {\n\t\t\treturn $ifaceNil;\n\t\t} else if (_1 === (35)) {\n\t\t\treturn errEAGAIN;\n\t\t} else if (_1 === (22)) {\n\t\t\treturn errEINVAL;\n\t\t} else if (_1 === (2)) {\n\t\t\treturn errENOENT;\n\t\t}\n\t\treturn new Errno(e);\n\t};\n\tRead = function(fd, p) {\n\t\tvar $ptr, _tuple, err, fd, n, p;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_tuple = read(fd, p);\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\tif (false) {\n\t\t\tif (n > 0) {\n\t\t\t\trace.WriteRange($sliceToArray(p), n);\n\t\t\t}\n\t\t\tif ($interfaceIsEqual(err, $ifaceNil)) {\n\t\t\t\trace.Acquire((ioSync$24ptr || (ioSync$24ptr = new ptrType$20(function() { return ioSync; }, function($v) { ioSync = $v; }))));\n\t\t\t}\n\t\t}\n\t\tif (false) {\n\t\t\tmsanWrite($sliceToArray(p), n);\n\t\t}\n\t\treturn [n, err];\n\t};\n\t$pkg.Read = Read;\n\tWrite = function(fd, p) {\n\t\tvar $ptr, _tuple, err, fd, n, p;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tif (false) {\n\t\t\trace.ReleaseMerge((ioSync$24ptr || (ioSync$24ptr = new ptrType$20(function() { return ioSync; }, function($v) { ioSync = $v; }))));\n\t\t}\n\t\t_tuple = write(fd, p);\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\tif (false) {\n\t\t\trace.ReadRange($sliceToArray(p), n);\n\t\t}\n\t\tif (false) {\n\t\t\tmsanRead($sliceToArray(p), n);\n\t\t}\n\t\treturn [n, err];\n\t};\n\t$pkg.Write = Write;\n\tsysctl = function(mib, old, oldlen, new$1, newlen) {\n\t\tvar $ptr, _p0, _tuple, e1, err, mib, new$1, newlen, old, oldlen;\n\t\terr = $ifaceNil;\n\t\t_p0 = 0;\n\t\tif (mib.$length > 0) {\n\t\t\t_p0 = $sliceToArray(mib);\n\t\t} else {\n\t\t\t_p0 = new Uint8Array(0);\n\t\t}\n\t\t_tuple = Syscall6(202, _p0, (mib.$length >>> 0), old, oldlen, new$1, newlen);\n\t\te1 = _tuple[2];\n\t\tuse(_p0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\tClose = function(fd) {\n\t\tvar $ptr, _tuple, e1, err, fd;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(6, (fd >>> 0), 0, 0);\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Close = Close;\n\tFchdir = function(fd) {\n\t\tvar $ptr, _tuple, e1, err, fd;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(13, (fd >>> 0), 0, 0);\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Fchdir = Fchdir;\n\tFchmod = function(fd, mode) {\n\t\tvar $ptr, _tuple, e1, err, fd, mode;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(124, (fd >>> 0), (mode >>> 0), 0);\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Fchmod = Fchmod;\n\tFchown = function(fd, uid, gid) {\n\t\tvar $ptr, _tuple, e1, err, fd, gid, uid;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(123, (fd >>> 0), (uid >>> 0), (gid >>> 0));\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Fchown = Fchown;\n\tFstat = function(fd, stat) {\n\t\tvar $ptr, _array, _struct, _tuple, _view, e1, err, fd, stat;\n\t\terr = $ifaceNil;\n\t\t_array = new Uint8Array(144);\n\t\t_tuple = Syscall(339, (fd >>> 0), _array, 0);\n\t\t_struct = stat, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Dev = _view.getInt32(0, true), _struct.Mode = _view.getUint16(4, true), _struct.Nlink = _view.getUint16(6, true), _struct.Ino = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Uid = _view.getUint32(16, true), _struct.Gid = _view.getUint32(20, true), _struct.Rdev = _view.getInt32(24, true), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 28, _array.buffer.byteLength)), _struct.Atimespec.Sec = new $Int64(_view.getUint32(36, true), _view.getUint32(32, true)), _struct.Atimespec.Nsec = new $Int64(_view.getUint32(44, true), _view.getUint32(40, true)), _struct.Mtimespec.Sec = new $Int64(_view.getUint32(52, true), _view.getUint32(48, true)), _struct.Mtimespec.Nsec = new $Int64(_view.getUint32(60, true), _view.getUint32(56, true)), _struct.Ctimespec.Sec = new $Int64(_view.getUint32(68, true), _view.getUint32(64, true)), _struct.Ctimespec.Nsec = new $Int64(_view.getUint32(76, true), _view.getUint32(72, true)), _struct.Birthtimespec.Sec = new $Int64(_view.getUint32(84, true), _view.getUint32(80, true)), _struct.Birthtimespec.Nsec = new $Int64(_view.getUint32(92, true), _view.getUint32(88, true)), _struct.Size = new $Int64(_view.getUint32(100, true), _view.getUint32(96, true)), _struct.Blocks = new $Int64(_view.getUint32(108, true), _view.getUint32(104, true)), _struct.Blksize = _view.getInt32(112, true), _struct.Flags = _view.getUint32(116, true), _struct.Gen = _view.getUint32(120, true), _struct.Lspare = _view.getInt32(124, true), _struct.Qspare = new ($nativeArray($kindInt64))(_array.buffer, $min(_array.byteOffset + 128, _array.buffer.byteLength));\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Fstat = Fstat;\n\tFsync = function(fd) {\n\t\tvar $ptr, _tuple, e1, err, fd;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(95, (fd >>> 0), 0, 0);\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Fsync = Fsync;\n\tFtruncate = function(fd, length) {\n\t\tvar $ptr, _tuple, e1, err, fd, length;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(201, (fd >>> 0), (length.$low >>> 0), 0);\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Ftruncate = Ftruncate;\n\tGetdirentries = function(fd, buf, basep) {\n\t\tvar $ptr, _p0, _tuple, basep, buf, e1, err, fd, n, r0;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_p0 = 0;\n\t\tif (buf.$length > 0) {\n\t\t\t_p0 = $sliceToArray(buf);\n\t\t} else {\n\t\t\t_p0 = new Uint8Array(0);\n\t\t}\n\t\t_tuple = Syscall6(344, (fd >>> 0), _p0, (buf.$length >>> 0), basep, 0, 0);\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tn = (r0 >> 0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [n, err];\n\t};\n\t$pkg.Getdirentries = Getdirentries;\n\tLstat = function(path, stat) {\n\t\tvar $ptr, _array, _p0, _struct, _tuple, _tuple$1, _view, e1, err, path, stat;\n\t\terr = $ifaceNil;\n\t\t_p0 = ptrType$2.nil;\n\t\t_tuple = BytePtrFromString(path);\n\t\t_p0 = _tuple[0];\n\t\terr = _tuple[1];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\treturn err;\n\t\t}\n\t\t_array = new Uint8Array(144);\n\t\t_tuple$1 = Syscall(340, _p0, _array, 0);\n\t\t_struct = stat, _view = new DataView(_array.buffer, _array.byteOffset), _struct.Dev = _view.getInt32(0, true), _struct.Mode = _view.getUint16(4, true), _struct.Nlink = _view.getUint16(6, true), _struct.Ino = new $Uint64(_view.getUint32(12, true), _view.getUint32(8, true)), _struct.Uid = _view.getUint32(16, true), _struct.Gid = _view.getUint32(20, true), _struct.Rdev = _view.getInt32(24, true), _struct.Pad_cgo_0 = new ($nativeArray($kindUint8))(_array.buffer, $min(_array.byteOffset + 28, _array.buffer.byteLength)), _struct.Atimespec.Sec = new $Int64(_view.getUint32(36, true), _view.getUint32(32, true)), _struct.Atimespec.Nsec = new $Int64(_view.getUint32(44, true), _view.getUint32(40, true)), _struct.Mtimespec.Sec = new $Int64(_view.getUint32(52, true), _view.getUint32(48, true)), _struct.Mtimespec.Nsec = new $Int64(_view.getUint32(60, true), _view.getUint32(56, true)), _struct.Ctimespec.Sec = new $Int64(_view.getUint32(68, true), _view.getUint32(64, true)), _struct.Ctimespec.Nsec = new $Int64(_view.getUint32(76, true), _view.getUint32(72, true)), _struct.Birthtimespec.Sec = new $Int64(_view.getUint32(84, true), _view.getUint32(80, true)), _struct.Birthtimespec.Nsec = new $Int64(_view.getUint32(92, true), _view.getUint32(88, true)), _struct.Size = new $Int64(_view.getUint32(100, true), _view.getUint32(96, true)), _struct.Blocks = new $Int64(_view.getUint32(108, true), _view.getUint32(104, true)), _struct.Blksize = _view.getInt32(112, true), _struct.Flags = _view.getUint32(116, true), _struct.Gen = _view.getUint32(120, true), _struct.Lspare = _view.getInt32(124, true), _struct.Qspare = new ($nativeArray($kindInt64))(_array.buffer, $min(_array.byteOffset + 128, _array.buffer.byteLength));\n\t\te1 = _tuple$1[2];\n\t\tuse(_p0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\t$pkg.Lstat = Lstat;\n\tPread = function(fd, p, offset) {\n\t\tvar $ptr, _p0, _tuple, e1, err, fd, n, offset, p, r0;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_p0 = 0;\n\t\tif (p.$length > 0) {\n\t\t\t_p0 = $sliceToArray(p);\n\t\t} else {\n\t\t\t_p0 = new Uint8Array(0);\n\t\t}\n\t\t_tuple = Syscall6(153, (fd >>> 0), _p0, (p.$length >>> 0), (offset.$low >>> 0), 0, 0);\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tn = (r0 >> 0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [n, err];\n\t};\n\t$pkg.Pread = Pread;\n\tPwrite = function(fd, p, offset) {\n\t\tvar $ptr, _p0, _tuple, e1, err, fd, n, offset, p, r0;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_p0 = 0;\n\t\tif (p.$length > 0) {\n\t\t\t_p0 = $sliceToArray(p);\n\t\t} else {\n\t\t\t_p0 = new Uint8Array(0);\n\t\t}\n\t\t_tuple = Syscall6(154, (fd >>> 0), _p0, (p.$length >>> 0), (offset.$low >>> 0), 0, 0);\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tn = (r0 >> 0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [n, err];\n\t};\n\t$pkg.Pwrite = Pwrite;\n\tread = function(fd, p) {\n\t\tvar $ptr, _p0, _tuple, e1, err, fd, n, p, r0;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_p0 = 0;\n\t\tif (p.$length > 0) {\n\t\t\t_p0 = $sliceToArray(p);\n\t\t} else {\n\t\t\t_p0 = new Uint8Array(0);\n\t\t}\n\t\t_tuple = Syscall(3, (fd >>> 0), _p0, (p.$length >>> 0));\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tn = (r0 >> 0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [n, err];\n\t};\n\tSeek = function(fd, offset, whence) {\n\t\tvar $ptr, _tuple, e1, err, fd, newoffset, offset, r0, whence;\n\t\tnewoffset = new $Int64(0, 0);\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(199, (fd >>> 0), (offset.$low >>> 0), (whence >>> 0));\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tnewoffset = new $Int64(0, r0.constructor === Number ? r0 : 1);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [newoffset, err];\n\t};\n\t$pkg.Seek = Seek;\n\twrite = function(fd, p) {\n\t\tvar $ptr, _p0, _tuple, e1, err, fd, n, p, r0;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_p0 = 0;\n\t\tif (p.$length > 0) {\n\t\t\t_p0 = $sliceToArray(p);\n\t\t} else {\n\t\t\t_p0 = new Uint8Array(0);\n\t\t}\n\t\t_tuple = Syscall(4, (fd >>> 0), _p0, (p.$length >>> 0));\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tn = (r0 >> 0);\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [n, err];\n\t};\n\tmmap = function(addr, length, prot, flag, fd, pos) {\n\t\tvar $ptr, _tuple, addr, e1, err, fd, flag, length, pos, prot, r0, ret;\n\t\tret = 0;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall6(197, addr, length, (prot >>> 0), (flag >>> 0), (fd >>> 0), (pos.$low >>> 0));\n\t\tr0 = _tuple[0];\n\t\te1 = _tuple[2];\n\t\tret = r0;\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn [ret, err];\n\t};\n\tmunmap = function(addr, length) {\n\t\tvar $ptr, _tuple, addr, e1, err, length;\n\t\terr = $ifaceNil;\n\t\t_tuple = Syscall(73, addr, length, 0);\n\t\te1 = _tuple[2];\n\t\tif (!((e1 === 0))) {\n\t\t\terr = errnoErr(e1);\n\t\t}\n\t\treturn err;\n\t};\n\tptrType$27.methods = [{prop: \"Mmap\", name: \"Mmap\", pkg: \"\", typ: $funcType([$Int, $Int64, $Int, $Int, $Int], [sliceType, $error], false)}, {prop: \"Munmap\", name: \"Munmap\", pkg: \"\", typ: $funcType([sliceType], [$error], false)}];\n\tErrno.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Temporary\", name: \"Temporary\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Timeout\", name: \"Timeout\", pkg: \"\", typ: $funcType([], [$Bool], false)}];\n\tptrType$31.methods = [{prop: \"Unix\", name: \"Unix\", pkg: \"\", typ: $funcType([], [$Int64, $Int64], false)}, {prop: \"Nano\", name: \"Nano\", pkg: \"\", typ: $funcType([], [$Int64], false)}];\n\tmmapper.init(\"syscall\", [{prop: \"Mutex\", name: \"\", exported: true, typ: sync.Mutex, tag: \"\"}, {prop: \"active\", name: \"active\", exported: false, typ: mapType, tag: \"\"}, {prop: \"mmap\", name: \"mmap\", exported: false, typ: funcType, tag: \"\"}, {prop: \"munmap\", name: \"munmap\", exported: false, typ: funcType$1, tag: \"\"}]);\n\tTimespec.init(\"\", [{prop: \"Sec\", name: \"Sec\", exported: true, typ: $Int64, tag: \"\"}, {prop: \"Nsec\", name: \"Nsec\", exported: true, typ: $Int64, tag: \"\"}]);\n\tStat_t.init(\"\", [{prop: \"Dev\", name: \"Dev\", exported: true, typ: $Int32, tag: \"\"}, {prop: \"Mode\", name: \"Mode\", exported: true, typ: $Uint16, tag: \"\"}, {prop: \"Nlink\", name: \"Nlink\", exported: true, typ: $Uint16, tag: \"\"}, {prop: \"Ino\", name: \"Ino\", exported: true, typ: $Uint64, tag: \"\"}, {prop: \"Uid\", name: \"Uid\", exported: true, typ: $Uint32, tag: \"\"}, {prop: \"Gid\", name: \"Gid\", exported: true, typ: $Uint32, tag: \"\"}, {prop: \"Rdev\", name: \"Rdev\", exported: true, typ: $Int32, tag: \"\"}, {prop: \"Pad_cgo_0\", name: \"Pad_cgo_0\", exported: true, typ: arrayType$1, tag: \"\"}, {prop: \"Atimespec\", name: \"Atimespec\", exported: true, typ: Timespec, tag: \"\"}, {prop: \"Mtimespec\", name: \"Mtimespec\", exported: true, typ: Timespec, tag: \"\"}, {prop: \"Ctimespec\", name: \"Ctimespec\", exported: true, typ: Timespec, tag: \"\"}, {prop: \"Birthtimespec\", name: \"Birthtimespec\", exported: true, typ: Timespec, tag: \"\"}, {prop: \"Size\", name: \"Size\", exported: true, typ: $Int64, tag: \"\"}, {prop: \"Blocks\", name: \"Blocks\", exported: true, typ: $Int64, tag: \"\"}, {prop: \"Blksize\", name: \"Blksize\", exported: true, typ: $Int32, tag: \"\"}, {prop: \"Flags\", name: \"Flags\", exported: true, typ: $Uint32, tag: \"\"}, {prop: \"Gen\", name: \"Gen\", exported: true, typ: $Uint32, tag: \"\"}, {prop: \"Lspare\", name: \"Lspare\", exported: true, typ: $Int32, tag: \"\"}, {prop: \"Qspare\", name: \"Qspare\", exported: true, typ: arrayType$17, tag: \"\"}]);\n\tDirent.init(\"\", [{prop: \"Ino\", name: \"Ino\", exported: true, typ: $Uint64, tag: \"\"}, {prop: \"Seekoff\", name: \"Seekoff\", exported: true, typ: $Uint64, tag: \"\"}, {prop: \"Reclen\", name: \"Reclen\", exported: true, typ: $Uint16, tag: \"\"}, {prop: \"Namlen\", name: \"Namlen\", exported: true, typ: $Uint16, tag: \"\"}, {prop: \"Type\", name: \"Type\", exported: true, typ: $Uint8, tag: \"\"}, {prop: \"Name\", name: \"Name\", exported: true, typ: arrayType$14, tag: \"\"}, {prop: \"Pad_cgo_0\", name: \"Pad_cgo_0\", exported: true, typ: arrayType$15, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = race.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = sync.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tlineBuffer = sliceType.nil;\n\t\tsyscallModule = null;\n\t\tenvOnce = new sync.Once.ptr(new sync.Mutex.ptr(0, 0), 0);\n\t\tenvLock = new sync.RWMutex.ptr(new sync.Mutex.ptr(0, 0), 0, 0, 0, 0);\n\t\tenv = false;\n\t\tfreebsdConfArch = \"\";\n\t\tioSync = new $Int64(0, 0);\n\t\twarningPrinted = false;\n\t\talreadyTriedToLoad = false;\n\t\tminusOne = -1;\n\t\tenvs = runtime_envs();\n\t\t$pkg.Stdin = 0;\n\t\t$pkg.Stdout = 1;\n\t\t$pkg.Stderr = 2;\n\t\terrEAGAIN = new Errno(35);\n\t\terrEINVAL = new Errno(22);\n\t\terrENOENT = new Errno(2);\n\t\terrors$1 = $toNativeArray($kindString, [\"\", \"operation not permitted\", \"no such file or directory\", \"no such process\", \"interrupted system call\", \"input/output error\", \"device not configured\", \"argument list too long\", \"exec format error\", \"bad file descriptor\", \"no child processes\", \"resource deadlock avoided\", \"cannot allocate memory\", \"permission denied\", \"bad address\", \"block device required\", \"resource busy\", \"file exists\", \"cross-device link\", \"operation not supported by device\", \"not a directory\", \"is a directory\", \"invalid argument\", \"too many open files in system\", \"too many open files\", \"inappropriate ioctl for device\", \"text file busy\", \"file too large\", \"no space left on device\", \"illegal seek\", \"read-only file system\", \"too many links\", \"broken pipe\", \"numerical argument out of domain\", \"result too large\", \"resource temporarily unavailable\", \"operation now in progress\", \"operation already in progress\", \"socket operation on non-socket\", \"destination address required\", \"message too long\", \"protocol wrong type for socket\", \"protocol not available\", \"protocol not supported\", \"socket type not supported\", \"operation not supported\", \"protocol family not supported\", \"address family not supported by protocol family\", \"address already in use\", \"can't assign requested address\", \"network is down\", \"network is unreachable\", \"network dropped connection on reset\", \"software caused connection abort\", \"connection reset by peer\", \"no buffer space available\", \"socket is already connected\", \"socket is not connected\", \"can't send after socket shutdown\", \"too many references: can't splice\", \"operation timed out\", \"connection refused\", \"too many levels of symbolic links\", \"file name too long\", \"host is down\", \"no route to host\", \"directory not empty\", \"too many processes\", \"too many users\", \"disc quota exceeded\", \"stale NFS file handle\", \"too many levels of remote in path\", \"RPC struct is bad\", \"RPC version wrong\", \"RPC prog. not avail\", \"program version wrong\", \"bad procedure for program\", \"no locks available\", \"function not implemented\", \"inappropriate file type or format\", \"authentication error\", \"need authenticator\", \"device power is off\", \"device error\", \"value too large to be stored in data type\", \"bad executable (or shared library)\", \"bad CPU type in executable\", \"shared library version mismatch\", \"malformed Mach-o file\", \"operation canceled\", \"identifier removed\", \"no message of desired type\", \"illegal byte sequence\", \"attribute not found\", \"bad message\", \"EMULTIHOP (Reserved)\", \"no message available on STREAM\", \"ENOLINK (Reserved)\", \"no STREAM resources\", \"not a STREAM\", \"protocol error\", \"STREAM ioctl timeout\", \"operation not supported on socket\", \"policy not found\", \"state not recoverable\", \"previous owner died\"]);\n\t\tmapper = new mmapper.ptr(new sync.Mutex.ptr(0, 0), {}, mmap, munmap);\n\t\tminRoutingSockaddrLen = rsaAlignOf(0);\n\t\tinit();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"github.com/gopherjs/gopherjs/nosync\"] = (function() {\n\tvar $pkg = {}, $init, Once, funcType, ptrType$3;\n\tOnce = $pkg.Once = $newType(0, $kindStruct, \"nosync.Once\", true, \"github.com/gopherjs/gopherjs/nosync\", true, function(doing_, done_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.doing = false;\n\t\t\tthis.done = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.doing = doing_;\n\t\tthis.done = done_;\n\t});\n\tfuncType = $funcType([], [], false);\n\tptrType$3 = $ptrType(Once);\n\tOnce.ptr.prototype.Do = function(f) {\n\t\tvar $ptr, f, o, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; f = $f.f; o = $f.o; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\to = [o];\n\t\to[0] = this;\n\t\tif (o[0].done) {\n\t\t\t$s = -1; return;\n\t\t}\n\t\tif (o[0].doing) {\n\t\t\t$panic(new $String(\"nosync: Do called within f\"));\n\t\t}\n\t\to[0].doing = true;\n\t\t$deferred.push([(function(o) { return function() {\n\t\t\tvar $ptr;\n\t\t\to[0].doing = false;\n\t\t\to[0].done = true;\n\t\t}; })(o), []]);\n\t\t$r = f(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return;\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Once.ptr.prototype.Do }; } $f.$ptr = $ptr; $f.f = f; $f.o = o; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\tOnce.prototype.Do = function(f) { return this.$val.Do(f); };\n\tptrType$3.methods = [{prop: \"Do\", name: \"Do\", pkg: \"\", typ: $funcType([funcType], [], false)}];\n\tOnce.init(\"github.com/gopherjs/gopherjs/nosync\", [{prop: \"doing\", name: \"doing\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"done\", name: \"done\", exported: false, typ: $Bool, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"time\"] = (function() {\n\tvar $pkg = {}, $init, errors, js, nosync, runtime, syscall, ParseError, Time, Month, Weekday, Duration, Location, zone, zoneTrans, sliceType, sliceType$1, ptrType, sliceType$2, arrayType, sliceType$3, arrayType$1, arrayType$2, ptrType$1, arrayType$4, ptrType$3, ptrType$6, std0x, longDayNames, shortDayNames, shortMonthNames, longMonthNames, atoiError, errBad, errLeadingInt, months, days, daysBefore, utcLoc, utcLoc$24ptr, localLoc, localLoc$24ptr, localOnce, zoneinfo, badData, _tuple, _r, init, initLocal, indexByte, startsWithLowerCase, nextStdChunk, match, lookup, appendInt, atoi, formatNano, quote, isDigit, getnum, cutspace, skip, Parse, parse, parseTimeZone, parseGMT, parseNanoseconds, leadingInt, absWeekday, absClock, fmtFrac, fmtInt, absDate, daysIn, Unix, isLeap, norm, Date, div, FixedZone;\n\terrors = $packages[\"errors\"];\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tnosync = $packages[\"github.com/gopherjs/gopherjs/nosync\"];\n\truntime = $packages[\"runtime\"];\n\tsyscall = $packages[\"syscall\"];\n\tParseError = $pkg.ParseError = $newType(0, $kindStruct, \"time.ParseError\", true, \"time\", true, function(Layout_, Value_, LayoutElem_, ValueElem_, Message_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Layout = \"\";\n\t\t\tthis.Value = \"\";\n\t\t\tthis.LayoutElem = \"\";\n\t\t\tthis.ValueElem = \"\";\n\t\t\tthis.Message = \"\";\n\t\t\treturn;\n\t\t}\n\t\tthis.Layout = Layout_;\n\t\tthis.Value = Value_;\n\t\tthis.LayoutElem = LayoutElem_;\n\t\tthis.ValueElem = ValueElem_;\n\t\tthis.Message = Message_;\n\t});\n\tTime = $pkg.Time = $newType(0, $kindStruct, \"time.Time\", true, \"time\", true, function(sec_, nsec_, loc_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.sec = new $Int64(0, 0);\n\t\t\tthis.nsec = 0;\n\t\t\tthis.loc = ptrType$1.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.sec = sec_;\n\t\tthis.nsec = nsec_;\n\t\tthis.loc = loc_;\n\t});\n\tMonth = $pkg.Month = $newType(4, $kindInt, \"time.Month\", true, \"time\", true, null);\n\tWeekday = $pkg.Weekday = $newType(4, $kindInt, \"time.Weekday\", true, \"time\", true, null);\n\tDuration = $pkg.Duration = $newType(8, $kindInt64, \"time.Duration\", true, \"time\", true, null);\n\tLocation = $pkg.Location = $newType(0, $kindStruct, \"time.Location\", true, \"time\", true, function(name_, zone_, tx_, cacheStart_, cacheEnd_, cacheZone_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = \"\";\n\t\t\tthis.zone = sliceType.nil;\n\t\t\tthis.tx = sliceType$1.nil;\n\t\t\tthis.cacheStart = new $Int64(0, 0);\n\t\t\tthis.cacheEnd = new $Int64(0, 0);\n\t\t\tthis.cacheZone = ptrType.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.zone = zone_;\n\t\tthis.tx = tx_;\n\t\tthis.cacheStart = cacheStart_;\n\t\tthis.cacheEnd = cacheEnd_;\n\t\tthis.cacheZone = cacheZone_;\n\t});\n\tzone = $pkg.zone = $newType(0, $kindStruct, \"time.zone\", true, \"time\", false, function(name_, offset_, isDST_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = \"\";\n\t\t\tthis.offset = 0;\n\t\t\tthis.isDST = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.offset = offset_;\n\t\tthis.isDST = isDST_;\n\t});\n\tzoneTrans = $pkg.zoneTrans = $newType(0, $kindStruct, \"time.zoneTrans\", true, \"time\", false, function(when_, index_, isstd_, isutc_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.when = new $Int64(0, 0);\n\t\t\tthis.index = 0;\n\t\t\tthis.isstd = false;\n\t\t\tthis.isutc = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.when = when_;\n\t\tthis.index = index_;\n\t\tthis.isstd = isstd_;\n\t\tthis.isutc = isutc_;\n\t});\n\tsliceType = $sliceType(zone);\n\tsliceType$1 = $sliceType(zoneTrans);\n\tptrType = $ptrType(zone);\n\tsliceType$2 = $sliceType($String);\n\tarrayType = $arrayType($Uint8, 20);\n\tsliceType$3 = $sliceType($Uint8);\n\tarrayType$1 = $arrayType($Uint8, 9);\n\tarrayType$2 = $arrayType($Uint8, 64);\n\tptrType$1 = $ptrType(Location);\n\tarrayType$4 = $arrayType($Uint8, 32);\n\tptrType$3 = $ptrType(ParseError);\n\tptrType$6 = $ptrType(Time);\n\tinit = function() {\n\t\tvar $ptr;\n\t\t$unused(Unix(new $Int64(0, 0), new $Int64(0, 0)));\n\t};\n\tinitLocal = function() {\n\t\tvar $ptr, d, i, j, s;\n\t\td = new ($global.Date)();\n\t\ts = $internalize(d, $String);\n\t\ti = indexByte(s, 40);\n\t\tj = indexByte(s, 41);\n\t\tif ((i === -1) || (j === -1)) {\n\t\t\tlocalLoc.name = \"UTC\";\n\t\t\treturn;\n\t\t}\n\t\tlocalLoc.name = $substring(s, (i + 1 >> 0), j);\n\t\tlocalLoc.zone = new sliceType([new zone.ptr(localLoc.name, $imul(($parseInt(d.getTimezoneOffset()) >> 0), -60), false)]);\n\t};\n\tindexByte = function(s, c) {\n\t\tvar $ptr, c, s;\n\t\treturn $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;\n\t};\n\tstartsWithLowerCase = function(str) {\n\t\tvar $ptr, c, str;\n\t\tif (str.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tc = str.charCodeAt(0);\n\t\treturn 97 <= c && c <= 122;\n\t};\n\tnextStdChunk = function(layout) {\n\t\tvar $ptr, _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$44, _tmp$45, _tmp$46, _tmp$47, _tmp$48, _tmp$49, _tmp$5, _tmp$50, _tmp$51, _tmp$52, _tmp$53, _tmp$54, _tmp$55, _tmp$56, _tmp$57, _tmp$58, _tmp$59, _tmp$6, _tmp$60, _tmp$61, _tmp$62, _tmp$63, _tmp$64, _tmp$65, _tmp$66, _tmp$67, _tmp$68, _tmp$69, _tmp$7, _tmp$70, _tmp$71, _tmp$72, _tmp$73, _tmp$74, _tmp$75, _tmp$76, _tmp$77, _tmp$78, _tmp$79, _tmp$8, _tmp$80, _tmp$81, _tmp$82, _tmp$83, _tmp$84, _tmp$85, _tmp$86, _tmp$9, c, ch, i, j, layout, prefix, std, std$1, suffix, x;\n\t\tprefix = \"\";\n\t\tstd = 0;\n\t\tsuffix = \"\";\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < layout.length)) { break; }\n\t\t\tc = (layout.charCodeAt(i) >> 0);\n\t\t\t_1 = c;\n\t\t\tif (_1 === (74)) {\n\t\t\t\tif (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === \"Jan\") {\n\t\t\t\t\tif (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === \"January\") {\n\t\t\t\t\t\t_tmp = $substring(layout, 0, i);\n\t\t\t\t\t\t_tmp$1 = 257;\n\t\t\t\t\t\t_tmp$2 = $substring(layout, (i + 7 >> 0));\n\t\t\t\t\t\tprefix = _tmp;\n\t\t\t\t\t\tstd = _tmp$1;\n\t\t\t\t\t\tsuffix = _tmp$2;\n\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t}\n\t\t\t\t\tif (!startsWithLowerCase($substring(layout, (i + 3 >> 0)))) {\n\t\t\t\t\t\t_tmp$3 = $substring(layout, 0, i);\n\t\t\t\t\t\t_tmp$4 = 258;\n\t\t\t\t\t\t_tmp$5 = $substring(layout, (i + 3 >> 0));\n\t\t\t\t\t\tprefix = _tmp$3;\n\t\t\t\t\t\tstd = _tmp$4;\n\t\t\t\t\t\tsuffix = _tmp$5;\n\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (_1 === (77)) {\n\t\t\t\tif (layout.length >= (i + 3 >> 0)) {\n\t\t\t\t\tif ($substring(layout, i, (i + 3 >> 0)) === \"Mon\") {\n\t\t\t\t\t\tif (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === \"Monday\") {\n\t\t\t\t\t\t\t_tmp$6 = $substring(layout, 0, i);\n\t\t\t\t\t\t\t_tmp$7 = 261;\n\t\t\t\t\t\t\t_tmp$8 = $substring(layout, (i + 6 >> 0));\n\t\t\t\t\t\t\tprefix = _tmp$6;\n\t\t\t\t\t\t\tstd = _tmp$7;\n\t\t\t\t\t\t\tsuffix = _tmp$8;\n\t\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!startsWithLowerCase($substring(layout, (i + 3 >> 0)))) {\n\t\t\t\t\t\t\t_tmp$9 = $substring(layout, 0, i);\n\t\t\t\t\t\t\t_tmp$10 = 262;\n\t\t\t\t\t\t\t_tmp$11 = $substring(layout, (i + 3 >> 0));\n\t\t\t\t\t\t\tprefix = _tmp$9;\n\t\t\t\t\t\t\tstd = _tmp$10;\n\t\t\t\t\t\t\tsuffix = _tmp$11;\n\t\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($substring(layout, i, (i + 3 >> 0)) === \"MST\") {\n\t\t\t\t\t\t_tmp$12 = $substring(layout, 0, i);\n\t\t\t\t\t\t_tmp$13 = 21;\n\t\t\t\t\t\t_tmp$14 = $substring(layout, (i + 3 >> 0));\n\t\t\t\t\t\tprefix = _tmp$12;\n\t\t\t\t\t\tstd = _tmp$13;\n\t\t\t\t\t\tsuffix = _tmp$14;\n\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (_1 === (48)) {\n\t\t\t\tif (layout.length >= (i + 2 >> 0) && 49 <= layout.charCodeAt((i + 1 >> 0)) && layout.charCodeAt((i + 1 >> 0)) <= 54) {\n\t\t\t\t\t_tmp$15 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$16 = (x = layout.charCodeAt((i + 1 >> 0)) - 49 << 24 >>> 24, ((x < 0 || x >= std0x.length) ? $throwRuntimeError(\"index out of range\") : std0x[x]));\n\t\t\t\t\t_tmp$17 = $substring(layout, (i + 2 >> 0));\n\t\t\t\t\tprefix = _tmp$15;\n\t\t\t\t\tstd = _tmp$16;\n\t\t\t\t\tsuffix = _tmp$17;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t} else if (_1 === (49)) {\n\t\t\t\tif (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 53)) {\n\t\t\t\t\t_tmp$18 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$19 = 522;\n\t\t\t\t\t_tmp$20 = $substring(layout, (i + 2 >> 0));\n\t\t\t\t\tprefix = _tmp$18;\n\t\t\t\t\tstd = _tmp$19;\n\t\t\t\t\tsuffix = _tmp$20;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\t_tmp$21 = $substring(layout, 0, i);\n\t\t\t\t_tmp$22 = 259;\n\t\t\t\t_tmp$23 = $substring(layout, (i + 1 >> 0));\n\t\t\t\tprefix = _tmp$21;\n\t\t\t\tstd = _tmp$22;\n\t\t\t\tsuffix = _tmp$23;\n\t\t\t\treturn [prefix, std, suffix];\n\t\t\t} else if (_1 === (50)) {\n\t\t\t\tif (layout.length >= (i + 4 >> 0) && $substring(layout, i, (i + 4 >> 0)) === \"2006\") {\n\t\t\t\t\t_tmp$24 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$25 = 273;\n\t\t\t\t\t_tmp$26 = $substring(layout, (i + 4 >> 0));\n\t\t\t\t\tprefix = _tmp$24;\n\t\t\t\t\tstd = _tmp$25;\n\t\t\t\t\tsuffix = _tmp$26;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\t_tmp$27 = $substring(layout, 0, i);\n\t\t\t\t_tmp$28 = 263;\n\t\t\t\t_tmp$29 = $substring(layout, (i + 1 >> 0));\n\t\t\t\tprefix = _tmp$27;\n\t\t\t\tstd = _tmp$28;\n\t\t\t\tsuffix = _tmp$29;\n\t\t\t\treturn [prefix, std, suffix];\n\t\t\t} else if (_1 === (95)) {\n\t\t\t\tif (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 50)) {\n\t\t\t\t\tif (layout.length >= (i + 5 >> 0) && $substring(layout, (i + 1 >> 0), (i + 5 >> 0)) === \"2006\") {\n\t\t\t\t\t\t_tmp$30 = $substring(layout, 0, (i + 1 >> 0));\n\t\t\t\t\t\t_tmp$31 = 273;\n\t\t\t\t\t\t_tmp$32 = $substring(layout, (i + 5 >> 0));\n\t\t\t\t\t\tprefix = _tmp$30;\n\t\t\t\t\t\tstd = _tmp$31;\n\t\t\t\t\t\tsuffix = _tmp$32;\n\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$33 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$34 = 264;\n\t\t\t\t\t_tmp$35 = $substring(layout, (i + 2 >> 0));\n\t\t\t\t\tprefix = _tmp$33;\n\t\t\t\t\tstd = _tmp$34;\n\t\t\t\t\tsuffix = _tmp$35;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t} else if (_1 === (51)) {\n\t\t\t\t_tmp$36 = $substring(layout, 0, i);\n\t\t\t\t_tmp$37 = 523;\n\t\t\t\t_tmp$38 = $substring(layout, (i + 1 >> 0));\n\t\t\t\tprefix = _tmp$36;\n\t\t\t\tstd = _tmp$37;\n\t\t\t\tsuffix = _tmp$38;\n\t\t\t\treturn [prefix, std, suffix];\n\t\t\t} else if (_1 === (52)) {\n\t\t\t\t_tmp$39 = $substring(layout, 0, i);\n\t\t\t\t_tmp$40 = 525;\n\t\t\t\t_tmp$41 = $substring(layout, (i + 1 >> 0));\n\t\t\t\tprefix = _tmp$39;\n\t\t\t\tstd = _tmp$40;\n\t\t\t\tsuffix = _tmp$41;\n\t\t\t\treturn [prefix, std, suffix];\n\t\t\t} else if (_1 === (53)) {\n\t\t\t\t_tmp$42 = $substring(layout, 0, i);\n\t\t\t\t_tmp$43 = 527;\n\t\t\t\t_tmp$44 = $substring(layout, (i + 1 >> 0));\n\t\t\t\tprefix = _tmp$42;\n\t\t\t\tstd = _tmp$43;\n\t\t\t\tsuffix = _tmp$44;\n\t\t\t\treturn [prefix, std, suffix];\n\t\t\t} else if (_1 === (80)) {\n\t\t\t\tif (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 77)) {\n\t\t\t\t\t_tmp$45 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$46 = 531;\n\t\t\t\t\t_tmp$47 = $substring(layout, (i + 2 >> 0));\n\t\t\t\t\tprefix = _tmp$45;\n\t\t\t\t\tstd = _tmp$46;\n\t\t\t\t\tsuffix = _tmp$47;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t} else if (_1 === (112)) {\n\t\t\t\tif (layout.length >= (i + 2 >> 0) && (layout.charCodeAt((i + 1 >> 0)) === 109)) {\n\t\t\t\t\t_tmp$48 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$49 = 532;\n\t\t\t\t\t_tmp$50 = $substring(layout, (i + 2 >> 0));\n\t\t\t\t\tprefix = _tmp$48;\n\t\t\t\t\tstd = _tmp$49;\n\t\t\t\t\tsuffix = _tmp$50;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t} else if (_1 === (45)) {\n\t\t\t\tif (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === \"-070000\") {\n\t\t\t\t\t_tmp$51 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$52 = 28;\n\t\t\t\t\t_tmp$53 = $substring(layout, (i + 7 >> 0));\n\t\t\t\t\tprefix = _tmp$51;\n\t\t\t\t\tstd = _tmp$52;\n\t\t\t\t\tsuffix = _tmp$53;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 9 >> 0) && $substring(layout, i, (i + 9 >> 0)) === \"-07:00:00\") {\n\t\t\t\t\t_tmp$54 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$55 = 31;\n\t\t\t\t\t_tmp$56 = $substring(layout, (i + 9 >> 0));\n\t\t\t\t\tprefix = _tmp$54;\n\t\t\t\t\tstd = _tmp$55;\n\t\t\t\t\tsuffix = _tmp$56;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 5 >> 0) && $substring(layout, i, (i + 5 >> 0)) === \"-0700\") {\n\t\t\t\t\t_tmp$57 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$58 = 27;\n\t\t\t\t\t_tmp$59 = $substring(layout, (i + 5 >> 0));\n\t\t\t\t\tprefix = _tmp$57;\n\t\t\t\t\tstd = _tmp$58;\n\t\t\t\t\tsuffix = _tmp$59;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === \"-07:00\") {\n\t\t\t\t\t_tmp$60 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$61 = 30;\n\t\t\t\t\t_tmp$62 = $substring(layout, (i + 6 >> 0));\n\t\t\t\t\tprefix = _tmp$60;\n\t\t\t\t\tstd = _tmp$61;\n\t\t\t\t\tsuffix = _tmp$62;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === \"-07\") {\n\t\t\t\t\t_tmp$63 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$64 = 29;\n\t\t\t\t\t_tmp$65 = $substring(layout, (i + 3 >> 0));\n\t\t\t\t\tprefix = _tmp$63;\n\t\t\t\t\tstd = _tmp$64;\n\t\t\t\t\tsuffix = _tmp$65;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t} else if (_1 === (90)) {\n\t\t\t\tif (layout.length >= (i + 7 >> 0) && $substring(layout, i, (i + 7 >> 0)) === \"Z070000\") {\n\t\t\t\t\t_tmp$66 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$67 = 23;\n\t\t\t\t\t_tmp$68 = $substring(layout, (i + 7 >> 0));\n\t\t\t\t\tprefix = _tmp$66;\n\t\t\t\t\tstd = _tmp$67;\n\t\t\t\t\tsuffix = _tmp$68;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 9 >> 0) && $substring(layout, i, (i + 9 >> 0)) === \"Z07:00:00\") {\n\t\t\t\t\t_tmp$69 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$70 = 26;\n\t\t\t\t\t_tmp$71 = $substring(layout, (i + 9 >> 0));\n\t\t\t\t\tprefix = _tmp$69;\n\t\t\t\t\tstd = _tmp$70;\n\t\t\t\t\tsuffix = _tmp$71;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 5 >> 0) && $substring(layout, i, (i + 5 >> 0)) === \"Z0700\") {\n\t\t\t\t\t_tmp$72 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$73 = 22;\n\t\t\t\t\t_tmp$74 = $substring(layout, (i + 5 >> 0));\n\t\t\t\t\tprefix = _tmp$72;\n\t\t\t\t\tstd = _tmp$73;\n\t\t\t\t\tsuffix = _tmp$74;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 6 >> 0) && $substring(layout, i, (i + 6 >> 0)) === \"Z07:00\") {\n\t\t\t\t\t_tmp$75 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$76 = 25;\n\t\t\t\t\t_tmp$77 = $substring(layout, (i + 6 >> 0));\n\t\t\t\t\tprefix = _tmp$75;\n\t\t\t\t\tstd = _tmp$76;\n\t\t\t\t\tsuffix = _tmp$77;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t\tif (layout.length >= (i + 3 >> 0) && $substring(layout, i, (i + 3 >> 0)) === \"Z07\") {\n\t\t\t\t\t_tmp$78 = $substring(layout, 0, i);\n\t\t\t\t\t_tmp$79 = 24;\n\t\t\t\t\t_tmp$80 = $substring(layout, (i + 3 >> 0));\n\t\t\t\t\tprefix = _tmp$78;\n\t\t\t\t\tstd = _tmp$79;\n\t\t\t\t\tsuffix = _tmp$80;\n\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t}\n\t\t\t} else if (_1 === (46)) {\n\t\t\t\tif ((i + 1 >> 0) < layout.length && ((layout.charCodeAt((i + 1 >> 0)) === 48) || (layout.charCodeAt((i + 1 >> 0)) === 57))) {\n\t\t\t\t\tch = layout.charCodeAt((i + 1 >> 0));\n\t\t\t\t\tj = i + 1 >> 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!(j < layout.length && (layout.charCodeAt(j) === ch))) { break; }\n\t\t\t\t\t\tj = j + (1) >> 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isDigit(layout, j)) {\n\t\t\t\t\t\tstd$1 = 32;\n\t\t\t\t\t\tif (layout.charCodeAt((i + 1 >> 0)) === 57) {\n\t\t\t\t\t\t\tstd$1 = 33;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstd$1 = std$1 | ((((j - ((i + 1 >> 0)) >> 0)) << 16 >> 0));\n\t\t\t\t\t\t_tmp$81 = $substring(layout, 0, i);\n\t\t\t\t\t\t_tmp$82 = std$1;\n\t\t\t\t\t\t_tmp$83 = $substring(layout, j);\n\t\t\t\t\t\tprefix = _tmp$81;\n\t\t\t\t\t\tstd = _tmp$82;\n\t\t\t\t\t\tsuffix = _tmp$83;\n\t\t\t\t\t\treturn [prefix, std, suffix];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\t_tmp$84 = layout;\n\t\t_tmp$85 = 0;\n\t\t_tmp$86 = \"\";\n\t\tprefix = _tmp$84;\n\t\tstd = _tmp$85;\n\t\tsuffix = _tmp$86;\n\t\treturn [prefix, std, suffix];\n\t};\n\tmatch = function(s1, s2) {\n\t\tvar $ptr, c1, c2, i, s1, s2;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < s1.length)) { break; }\n\t\t\tc1 = s1.charCodeAt(i);\n\t\t\tc2 = s2.charCodeAt(i);\n\t\t\tif (!((c1 === c2))) {\n\t\t\t\tc1 = (c1 | (32)) >>> 0;\n\t\t\t\tc2 = (c2 | (32)) >>> 0;\n\t\t\t\tif (!((c1 === c2)) || c1 < 97 || c1 > 122) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\treturn true;\n\t};\n\tlookup = function(tab, val) {\n\t\tvar $ptr, _i, _ref, i, tab, v, val;\n\t\t_ref = tab;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\tv = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tif (val.length >= v.length && match($substring(val, 0, v.length), v)) {\n\t\t\t\treturn [i, $substring(val, v.length), $ifaceNil];\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\treturn [-1, val, errBad];\n\t};\n\tappendInt = function(b, x, width) {\n\t\tvar $ptr, _q, b, buf, i, q, u, w, width, x;\n\t\tu = (x >>> 0);\n\t\tif (x < 0) {\n\t\t\tb = $append(b, 45);\n\t\t\tu = (-x >>> 0);\n\t\t}\n\t\tbuf = arrayType.zero();\n\t\ti = 20;\n\t\twhile (true) {\n\t\t\tif (!(u >= 10)) { break; }\n\t\t\ti = i - (1) >> 0;\n\t\t\tq = (_q = u / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t((i < 0 || i >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[i] = (((48 + u >>> 0) - (q * 10 >>> 0) >>> 0) << 24 >>> 24));\n\t\t\tu = q;\n\t\t}\n\t\ti = i - (1) >> 0;\n\t\t((i < 0 || i >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[i] = ((48 + u >>> 0) << 24 >>> 24));\n\t\tw = 20 - i >> 0;\n\t\twhile (true) {\n\t\t\tif (!(w < width)) { break; }\n\t\t\tb = $append(b, 48);\n\t\t\tw = w + (1) >> 0;\n\t\t}\n\t\treturn $appendSlice(b, $subslice(new sliceType$3(buf), i));\n\t};\n\tatoi = function(s) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple$1, err, neg, q, rem, s, x;\n\t\tx = 0;\n\t\terr = $ifaceNil;\n\t\tneg = false;\n\t\tif (!(s === \"\") && ((s.charCodeAt(0) === 45) || (s.charCodeAt(0) === 43))) {\n\t\t\tneg = s.charCodeAt(0) === 45;\n\t\t\ts = $substring(s, 1);\n\t\t}\n\t\t_tuple$1 = leadingInt(s);\n\t\tq = _tuple$1[0];\n\t\trem = _tuple$1[1];\n\t\terr = _tuple$1[2];\n\t\tx = ((q.$low + ((q.$high >> 31) * 4294967296)) >> 0);\n\t\tif (!($interfaceIsEqual(err, $ifaceNil)) || !(rem === \"\")) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = atoiError;\n\t\t\tx = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [x, err];\n\t\t}\n\t\tif (neg) {\n\t\t\tx = -x;\n\t\t}\n\t\t_tmp$2 = x;\n\t\t_tmp$3 = $ifaceNil;\n\t\tx = _tmp$2;\n\t\terr = _tmp$3;\n\t\treturn [x, err];\n\t};\n\tformatNano = function(b, nanosec, n, trim) {\n\t\tvar $ptr, _q, _r$1, b, buf, n, nanosec, start, trim, u, x;\n\t\tu = nanosec;\n\t\tbuf = arrayType$1.zero();\n\t\tstart = 9;\n\t\twhile (true) {\n\t\t\tif (!(start > 0)) { break; }\n\t\t\tstart = start - (1) >> 0;\n\t\t\t((start < 0 || start >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[start] = (((_r$1 = u % 10, _r$1 === _r$1 ? _r$1 : $throwRuntimeError(\"integer divide by zero\")) + 48 >>> 0) << 24 >>> 24));\n\t\t\tu = (_q = u / (10), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t}\n\t\tif (n > 9) {\n\t\t\tn = 9;\n\t\t}\n\t\tif (trim) {\n\t\t\twhile (true) {\n\t\t\t\tif (!(n > 0 && ((x = n - 1 >> 0, ((x < 0 || x >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[x])) === 48))) { break; }\n\t\t\t\tn = n - (1) >> 0;\n\t\t\t}\n\t\t\tif (n === 0) {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\tb = $append(b, 46);\n\t\treturn $appendSlice(b, $subslice(new sliceType$3(buf), 0, n));\n\t};\n\tTime.ptr.prototype.String = function() {\n\t\tvar $ptr, _r$1, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).Format(\"2006-01-02 15:04:05.999999999 -0700 MST\"); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.String }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.String = function() { return this.$val.String(); };\n\tTime.ptr.prototype.Format = function(layout) {\n\t\tvar $ptr, _r$1, b, buf, layout, max, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; b = $f.b; buf = $f.buf; layout = $f.layout; max = $f.max; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tb = sliceType$3.nil;\n\t\tmax = layout.length + 10 >> 0;\n\t\tif (max < 64) {\n\t\t\tbuf = arrayType$2.zero();\n\t\t\tb = $subslice(new sliceType$3(buf), 0, 0);\n\t\t} else {\n\t\t\tb = $makeSlice(sliceType$3, 0, max);\n\t\t}\n\t\t_r$1 = $clone(t, Time).AppendFormat(b, layout); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tb = _r$1;\n\t\t$s = -1; return $bytesToString(b);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Format }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.b = b; $f.buf = buf; $f.layout = layout; $f.max = max; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Format = function(layout) { return this.$val.Format(layout); };\n\tTime.ptr.prototype.AppendFormat = function(b, layout) {\n\t\tvar $ptr, _1, _q, _q$1, _q$2, _q$3, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _tuple$1, _tuple$2, _tuple$3, _tuple$4, abs, absoffset, b, day, hour, hr, hr$1, layout, m, min, month, name, offset, prefix, s, sec, std, suffix, t, y, year, zone$1, zone$2, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _q = $f._q; _q$1 = $f._q$1; _q$2 = $f._q$2; _q$3 = $f._q$3; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; abs = $f.abs; absoffset = $f.absoffset; b = $f.b; day = $f.day; hour = $f.hour; hr = $f.hr; hr$1 = $f.hr$1; layout = $f.layout; m = $f.m; min = $f.min; month = $f.month; name = $f.name; offset = $f.offset; prefix = $f.prefix; s = $f.s; sec = $f.sec; std = $f.std; suffix = $f.suffix; t = $f.t; y = $f.y; year = $f.year; zone$1 = $f.zone$1; zone$2 = $f.zone$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).locabs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tname = _tuple$1[0];\n\t\toffset = _tuple$1[1];\n\t\tabs = _tuple$1[2];\n\t\tyear = -1;\n\t\tmonth = 0;\n\t\tday = 0;\n\t\thour = -1;\n\t\tmin = 0;\n\t\tsec = 0;\n\t\twhile (true) {\n\t\t\tif (!(!(layout === \"\"))) { break; }\n\t\t\t_tuple$2 = nextStdChunk(layout);\n\t\t\tprefix = _tuple$2[0];\n\t\t\tstd = _tuple$2[1];\n\t\t\tsuffix = _tuple$2[2];\n\t\t\tif (!(prefix === \"\")) {\n\t\t\t\tb = $appendSlice(b, prefix);\n\t\t\t}\n\t\t\tif (std === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlayout = suffix;\n\t\t\tif (year < 0 && !(((std & 256) === 0))) {\n\t\t\t\t_tuple$3 = absDate(abs, true);\n\t\t\t\tyear = _tuple$3[0];\n\t\t\t\tmonth = _tuple$3[1];\n\t\t\t\tday = _tuple$3[2];\n\t\t\t}\n\t\t\tif (hour < 0 && !(((std & 512) === 0))) {\n\t\t\t\t_tuple$4 = absClock(abs);\n\t\t\t\thour = _tuple$4[0];\n\t\t\t\tmin = _tuple$4[1];\n\t\t\t\tsec = _tuple$4[2];\n\t\t\t}\n\t\t\tswitch (0) { default:\n\t\t\t\t_1 = std & 65535;\n\t\t\t\tif (_1 === (274)) {\n\t\t\t\t\ty = year;\n\t\t\t\t\tif (y < 0) {\n\t\t\t\t\t\ty = -y;\n\t\t\t\t\t}\n\t\t\t\t\tb = appendInt(b, (_r$2 = y % 100, _r$2 === _r$2 ? _r$2 : $throwRuntimeError(\"integer divide by zero\")), 2);\n\t\t\t\t} else if (_1 === (273)) {\n\t\t\t\t\tb = appendInt(b, year, 4);\n\t\t\t\t} else if (_1 === (258)) {\n\t\t\t\t\tb = $appendSlice(b, $substring(new Month(month).String(), 0, 3));\n\t\t\t\t} else if (_1 === (257)) {\n\t\t\t\t\tm = new Month(month).String();\n\t\t\t\t\tb = $appendSlice(b, m);\n\t\t\t\t} else if (_1 === (259)) {\n\t\t\t\t\tb = appendInt(b, (month >> 0), 0);\n\t\t\t\t} else if (_1 === (260)) {\n\t\t\t\t\tb = appendInt(b, (month >> 0), 2);\n\t\t\t\t} else if (_1 === (262)) {\n\t\t\t\t\tb = $appendSlice(b, $substring(new Weekday(absWeekday(abs)).String(), 0, 3));\n\t\t\t\t} else if (_1 === (261)) {\n\t\t\t\t\ts = new Weekday(absWeekday(abs)).String();\n\t\t\t\t\tb = $appendSlice(b, s);\n\t\t\t\t} else if (_1 === (263)) {\n\t\t\t\t\tb = appendInt(b, day, 0);\n\t\t\t\t} else if (_1 === (264)) {\n\t\t\t\t\tif (day < 10) {\n\t\t\t\t\t\tb = $append(b, 32);\n\t\t\t\t\t}\n\t\t\t\t\tb = appendInt(b, day, 0);\n\t\t\t\t} else if (_1 === (265)) {\n\t\t\t\t\tb = appendInt(b, day, 2);\n\t\t\t\t} else if (_1 === (522)) {\n\t\t\t\t\tb = appendInt(b, hour, 2);\n\t\t\t\t} else if (_1 === (523)) {\n\t\t\t\t\thr = (_r$3 = hour % 12, _r$3 === _r$3 ? _r$3 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t\t\tif (hr === 0) {\n\t\t\t\t\t\thr = 12;\n\t\t\t\t\t}\n\t\t\t\t\tb = appendInt(b, hr, 0);\n\t\t\t\t} else if (_1 === (524)) {\n\t\t\t\t\thr$1 = (_r$4 = hour % 12, _r$4 === _r$4 ? _r$4 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t\t\tif (hr$1 === 0) {\n\t\t\t\t\t\thr$1 = 12;\n\t\t\t\t\t}\n\t\t\t\t\tb = appendInt(b, hr$1, 2);\n\t\t\t\t} else if (_1 === (525)) {\n\t\t\t\t\tb = appendInt(b, min, 0);\n\t\t\t\t} else if (_1 === (526)) {\n\t\t\t\t\tb = appendInt(b, min, 2);\n\t\t\t\t} else if (_1 === (527)) {\n\t\t\t\t\tb = appendInt(b, sec, 0);\n\t\t\t\t} else if (_1 === (528)) {\n\t\t\t\t\tb = appendInt(b, sec, 2);\n\t\t\t\t} else if (_1 === (531)) {\n\t\t\t\t\tif (hour >= 12) {\n\t\t\t\t\t\tb = $appendSlice(b, \"PM\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = $appendSlice(b, \"AM\");\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (532)) {\n\t\t\t\t\tif (hour >= 12) {\n\t\t\t\t\t\tb = $appendSlice(b, \"pm\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = $appendSlice(b, \"am\");\n\t\t\t\t\t}\n\t\t\t\t} else if ((_1 === (22)) || (_1 === (25)) || (_1 === (23)) || (_1 === (24)) || (_1 === (26)) || (_1 === (27)) || (_1 === (30)) || (_1 === (28)) || (_1 === (29)) || (_1 === (31))) {\n\t\t\t\t\tif ((offset === 0) && ((std === 22) || (std === 25) || (std === 23) || (std === 24) || (std === 26))) {\n\t\t\t\t\t\tb = $append(b, 90);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tzone$1 = (_q = offset / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t\t\tabsoffset = offset;\n\t\t\t\t\tif (zone$1 < 0) {\n\t\t\t\t\t\tb = $append(b, 45);\n\t\t\t\t\t\tzone$1 = -zone$1;\n\t\t\t\t\t\tabsoffset = -absoffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = $append(b, 43);\n\t\t\t\t\t}\n\t\t\t\t\tb = appendInt(b, (_q$1 = zone$1 / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError(\"integer divide by zero\")), 2);\n\t\t\t\t\tif ((std === 25) || (std === 30) || (std === 26) || (std === 31)) {\n\t\t\t\t\t\tb = $append(b, 58);\n\t\t\t\t\t}\n\t\t\t\t\tif (!((std === 29)) && !((std === 24))) {\n\t\t\t\t\t\tb = appendInt(b, (_r$5 = zone$1 % 60, _r$5 === _r$5 ? _r$5 : $throwRuntimeError(\"integer divide by zero\")), 2);\n\t\t\t\t\t}\n\t\t\t\t\tif ((std === 23) || (std === 28) || (std === 31) || (std === 26)) {\n\t\t\t\t\t\tif ((std === 31) || (std === 26)) {\n\t\t\t\t\t\t\tb = $append(b, 58);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb = appendInt(b, (_r$6 = absoffset % 60, _r$6 === _r$6 ? _r$6 : $throwRuntimeError(\"integer divide by zero\")), 2);\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (21)) {\n\t\t\t\t\tif (!(name === \"\")) {\n\t\t\t\t\t\tb = $appendSlice(b, name);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tzone$2 = (_q$2 = offset / 60, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t\t\tif (zone$2 < 0) {\n\t\t\t\t\t\tb = $append(b, 45);\n\t\t\t\t\t\tzone$2 = -zone$2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = $append(b, 43);\n\t\t\t\t\t}\n\t\t\t\t\tb = appendInt(b, (_q$3 = zone$2 / 60, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : $throwRuntimeError(\"integer divide by zero\")), 2);\n\t\t\t\t\tb = appendInt(b, (_r$7 = zone$2 % 60, _r$7 === _r$7 ? _r$7 : $throwRuntimeError(\"integer divide by zero\")), 2);\n\t\t\t\t} else if ((_1 === (32)) || (_1 === (33))) {\n\t\t\t\t\tb = formatNano(b, ($clone(t, Time).Nanosecond() >>> 0), std >> 16 >> 0, (std & 65535) === 33);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$s = -1; return b;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.AppendFormat }; } $f.$ptr = $ptr; $f._1 = _1; $f._q = _q; $f._q$1 = _q$1; $f._q$2 = _q$2; $f._q$3 = _q$3; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f.abs = abs; $f.absoffset = absoffset; $f.b = b; $f.day = day; $f.hour = hour; $f.hr = hr; $f.hr$1 = hr$1; $f.layout = layout; $f.m = m; $f.min = min; $f.month = month; $f.name = name; $f.offset = offset; $f.prefix = prefix; $f.s = s; $f.sec = sec; $f.std = std; $f.suffix = suffix; $f.t = t; $f.y = y; $f.year = year; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.AppendFormat = function(b, layout) { return this.$val.AppendFormat(b, layout); };\n\tquote = function(s) {\n\t\tvar $ptr, s;\n\t\treturn \"\\\"\" + s + \"\\\"\";\n\t};\n\tParseError.ptr.prototype.Error = function() {\n\t\tvar $ptr, e;\n\t\te = this;\n\t\tif (e.Message === \"\") {\n\t\t\treturn \"parsing time \" + quote(e.Value) + \" as \" + quote(e.Layout) + \": cannot parse \" + quote(e.ValueElem) + \" as \" + quote(e.LayoutElem);\n\t\t}\n\t\treturn \"parsing time \" + quote(e.Value) + e.Message;\n\t};\n\tParseError.prototype.Error = function() { return this.$val.Error(); };\n\tisDigit = function(s, i) {\n\t\tvar $ptr, c, i, s;\n\t\tif (s.length <= i) {\n\t\t\treturn false;\n\t\t}\n\t\tc = s.charCodeAt(i);\n\t\treturn 48 <= c && c <= 57;\n\t};\n\tgetnum = function(s, fixed) {\n\t\tvar $ptr, fixed, s;\n\t\tif (!isDigit(s, 0)) {\n\t\t\treturn [0, s, errBad];\n\t\t}\n\t\tif (!isDigit(s, 1)) {\n\t\t\tif (fixed) {\n\t\t\t\treturn [0, s, errBad];\n\t\t\t}\n\t\t\treturn [((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0), $substring(s, 1), $ifaceNil];\n\t\t}\n\t\treturn [($imul(((s.charCodeAt(0) - 48 << 24 >>> 24) >> 0), 10)) + ((s.charCodeAt(1) - 48 << 24 >>> 24) >> 0) >> 0, $substring(s, 2), $ifaceNil];\n\t};\n\tcutspace = function(s) {\n\t\tvar $ptr, s;\n\t\twhile (true) {\n\t\t\tif (!(s.length > 0 && (s.charCodeAt(0) === 32))) { break; }\n\t\t\ts = $substring(s, 1);\n\t\t}\n\t\treturn s;\n\t};\n\tskip = function(value, prefix) {\n\t\tvar $ptr, prefix, value;\n\t\twhile (true) {\n\t\t\tif (!(prefix.length > 0)) { break; }\n\t\t\tif (prefix.charCodeAt(0) === 32) {\n\t\t\t\tif (value.length > 0 && !((value.charCodeAt(0) === 32))) {\n\t\t\t\t\treturn [value, errBad];\n\t\t\t\t}\n\t\t\t\tprefix = cutspace(prefix);\n\t\t\t\tvalue = cutspace(value);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((value.length === 0) || !((value.charCodeAt(0) === prefix.charCodeAt(0)))) {\n\t\t\t\treturn [value, errBad];\n\t\t\t}\n\t\t\tprefix = $substring(prefix, 1);\n\t\t\tvalue = $substring(value, 1);\n\t\t}\n\t\treturn [value, $ifaceNil];\n\t};\n\tParse = function(layout, value) {\n\t\tvar $ptr, _r$1, layout, value, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; layout = $f.layout; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r$1 = parse(layout, value, $pkg.UTC, $pkg.Local); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Parse }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.layout = layout; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.Parse = Parse;\n\tparse = function(layout, value, defaultLocation, local) {\n\t\tvar $ptr, _1, _2, _3, _4, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$18, _tmp$19, _tmp$2, _tmp$20, _tmp$21, _tmp$22, _tmp$23, _tmp$24, _tmp$25, _tmp$26, _tmp$27, _tmp$28, _tmp$29, _tmp$3, _tmp$30, _tmp$31, _tmp$32, _tmp$33, _tmp$34, _tmp$35, _tmp$36, _tmp$37, _tmp$38, _tmp$39, _tmp$4, _tmp$40, _tmp$41, _tmp$42, _tmp$43, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple$1, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$15, _tuple$16, _tuple$17, _tuple$18, _tuple$19, _tuple$2, _tuple$20, _tuple$21, _tuple$22, _tuple$23, _tuple$24, _tuple$25, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, alayout, amSet, avalue, day, defaultLocation, err, hour, hour$1, hr, i, layout, local, min, min$1, mm, month, n, n$1, name, ndigit, nsec, offset, offset$1, ok, ok$1, p, pmSet, prefix, rangeErrString, sec, seconds, sign, ss, std, stdstr, suffix, t, t$1, value, x, x$1, x$2, x$3, x$4, x$5, year, z, zoneName, zoneOffset, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$10 = $f._tmp$10; _tmp$11 = $f._tmp$11; _tmp$12 = $f._tmp$12; _tmp$13 = $f._tmp$13; _tmp$14 = $f._tmp$14; _tmp$15 = $f._tmp$15; _tmp$16 = $f._tmp$16; _tmp$17 = $f._tmp$17; _tmp$18 = $f._tmp$18; _tmp$19 = $f._tmp$19; _tmp$2 = $f._tmp$2; _tmp$20 = $f._tmp$20; _tmp$21 = $f._tmp$21; _tmp$22 = $f._tmp$22; _tmp$23 = $f._tmp$23; _tmp$24 = $f._tmp$24; _tmp$25 = $f._tmp$25; _tmp$26 = $f._tmp$26; _tmp$27 = $f._tmp$27; _tmp$28 = $f._tmp$28; _tmp$29 = $f._tmp$29; _tmp$3 = $f._tmp$3; _tmp$30 = $f._tmp$30; _tmp$31 = $f._tmp$31; _tmp$32 = $f._tmp$32; _tmp$33 = $f._tmp$33; _tmp$34 = $f._tmp$34; _tmp$35 = $f._tmp$35; _tmp$36 = $f._tmp$36; _tmp$37 = $f._tmp$37; _tmp$38 = $f._tmp$38; _tmp$39 = $f._tmp$39; _tmp$4 = $f._tmp$4; _tmp$40 = $f._tmp$40; _tmp$41 = $f._tmp$41; _tmp$42 = $f._tmp$42; _tmp$43 = $f._tmp$43; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$12 = $f._tuple$12; _tuple$13 = $f._tuple$13; _tuple$14 = $f._tuple$14; _tuple$15 = $f._tuple$15; _tuple$16 = $f._tuple$16; _tuple$17 = $f._tuple$17; _tuple$18 = $f._tuple$18; _tuple$19 = $f._tuple$19; _tuple$2 = $f._tuple$2; _tuple$20 = $f._tuple$20; _tuple$21 = $f._tuple$21; _tuple$22 = $f._tuple$22; _tuple$23 = $f._tuple$23; _tuple$24 = $f._tuple$24; _tuple$25 = $f._tuple$25; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; alayout = $f.alayout; amSet = $f.amSet; avalue = $f.avalue; day = $f.day; defaultLocation = $f.defaultLocation; err = $f.err; hour = $f.hour; hour$1 = $f.hour$1; hr = $f.hr; i = $f.i; layout = $f.layout; local = $f.local; min = $f.min; min$1 = $f.min$1; mm = $f.mm; month = $f.month; n = $f.n; n$1 = $f.n$1; name = $f.name; ndigit = $f.ndigit; nsec = $f.nsec; offset = $f.offset; offset$1 = $f.offset$1; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; pmSet = $f.pmSet; prefix = $f.prefix; rangeErrString = $f.rangeErrString; sec = $f.sec; seconds = $f.seconds; sign = $f.sign; ss = $f.ss; std = $f.std; stdstr = $f.stdstr; suffix = $f.suffix; t = $f.t; t$1 = $f.t$1; value = $f.value; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; year = $f.year; z = $f.z; zoneName = $f.zoneName; zoneOffset = $f.zoneOffset; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_tmp = layout;\n\t\t_tmp$1 = value;\n\t\talayout = _tmp;\n\t\tavalue = _tmp$1;\n\t\trangeErrString = \"\";\n\t\tamSet = false;\n\t\tpmSet = false;\n\t\tyear = 0;\n\t\tmonth = 1;\n\t\tday = 1;\n\t\thour = 0;\n\t\tmin = 0;\n\t\tsec = 0;\n\t\tnsec = 0;\n\t\tz = ptrType$1.nil;\n\t\tzoneOffset = -1;\n\t\tzoneName = \"\";\n\t\twhile (true) {\n\t\t\terr = $ifaceNil;\n\t\t\t_tuple$1 = nextStdChunk(layout);\n\t\t\tprefix = _tuple$1[0];\n\t\t\tstd = _tuple$1[1];\n\t\t\tsuffix = _tuple$1[2];\n\t\t\tstdstr = $substring(layout, prefix.length, (layout.length - suffix.length >> 0));\n\t\t\t_tuple$2 = skip(value, prefix);\n\t\t\tvalue = _tuple$2[0];\n\t\t\terr = _tuple$2[1];\n\t\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t\t$s = -1; return [new Time.ptr(new $Int64(0, 0), 0, ptrType$1.nil), new ParseError.ptr(alayout, avalue, prefix, value, \"\")];\n\t\t\t}\n\t\t\tif (std === 0) {\n\t\t\t\tif (!((value.length === 0))) {\n\t\t\t\t\t$s = -1; return [new Time.ptr(new $Int64(0, 0), 0, ptrType$1.nil), new ParseError.ptr(alayout, avalue, \"\", value, \": extra text: \" + value)];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlayout = suffix;\n\t\t\tp = \"\";\n\t\t\tswitch (0) { default:\n\t\t\t\t_1 = std & 65535;\n\t\t\t\tif (_1 === (274)) {\n\t\t\t\t\tif (value.length < 2) {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$2 = $substring(value, 0, 2);\n\t\t\t\t\t_tmp$3 = $substring(value, 2);\n\t\t\t\t\tp = _tmp$2;\n\t\t\t\t\tvalue = _tmp$3;\n\t\t\t\t\t_tuple$3 = atoi(p);\n\t\t\t\t\tyear = _tuple$3[0];\n\t\t\t\t\terr = _tuple$3[1];\n\t\t\t\t\tif (year >= 69) {\n\t\t\t\t\t\tyear = year + (1900) >> 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tyear = year + (2000) >> 0;\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (273)) {\n\t\t\t\t\tif (value.length < 4 || !isDigit(value, 0)) {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$4 = $substring(value, 0, 4);\n\t\t\t\t\t_tmp$5 = $substring(value, 4);\n\t\t\t\t\tp = _tmp$4;\n\t\t\t\t\tvalue = _tmp$5;\n\t\t\t\t\t_tuple$4 = atoi(p);\n\t\t\t\t\tyear = _tuple$4[0];\n\t\t\t\t\terr = _tuple$4[1];\n\t\t\t\t} else if (_1 === (258)) {\n\t\t\t\t\t_tuple$5 = lookup(shortMonthNames, value);\n\t\t\t\t\tmonth = _tuple$5[0];\n\t\t\t\t\tvalue = _tuple$5[1];\n\t\t\t\t\terr = _tuple$5[2];\n\t\t\t\t} else if (_1 === (257)) {\n\t\t\t\t\t_tuple$6 = lookup(longMonthNames, value);\n\t\t\t\t\tmonth = _tuple$6[0];\n\t\t\t\t\tvalue = _tuple$6[1];\n\t\t\t\t\terr = _tuple$6[2];\n\t\t\t\t} else if ((_1 === (259)) || (_1 === (260))) {\n\t\t\t\t\t_tuple$7 = getnum(value, std === 260);\n\t\t\t\t\tmonth = _tuple$7[0];\n\t\t\t\t\tvalue = _tuple$7[1];\n\t\t\t\t\terr = _tuple$7[2];\n\t\t\t\t\tif (month <= 0 || 12 < month) {\n\t\t\t\t\t\trangeErrString = \"month\";\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (262)) {\n\t\t\t\t\t_tuple$8 = lookup(shortDayNames, value);\n\t\t\t\t\tvalue = _tuple$8[1];\n\t\t\t\t\terr = _tuple$8[2];\n\t\t\t\t} else if (_1 === (261)) {\n\t\t\t\t\t_tuple$9 = lookup(longDayNames, value);\n\t\t\t\t\tvalue = _tuple$9[1];\n\t\t\t\t\terr = _tuple$9[2];\n\t\t\t\t} else if ((_1 === (263)) || (_1 === (264)) || (_1 === (265))) {\n\t\t\t\t\tif ((std === 264) && value.length > 0 && (value.charCodeAt(0) === 32)) {\n\t\t\t\t\t\tvalue = $substring(value, 1);\n\t\t\t\t\t}\n\t\t\t\t\t_tuple$10 = getnum(value, std === 265);\n\t\t\t\t\tday = _tuple$10[0];\n\t\t\t\t\tvalue = _tuple$10[1];\n\t\t\t\t\terr = _tuple$10[2];\n\t\t\t\t\tif (day < 0) {\n\t\t\t\t\t\trangeErrString = \"day\";\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (522)) {\n\t\t\t\t\t_tuple$11 = getnum(value, false);\n\t\t\t\t\thour = _tuple$11[0];\n\t\t\t\t\tvalue = _tuple$11[1];\n\t\t\t\t\terr = _tuple$11[2];\n\t\t\t\t\tif (hour < 0 || 24 <= hour) {\n\t\t\t\t\t\trangeErrString = \"hour\";\n\t\t\t\t\t}\n\t\t\t\t} else if ((_1 === (523)) || (_1 === (524))) {\n\t\t\t\t\t_tuple$12 = getnum(value, std === 524);\n\t\t\t\t\thour = _tuple$12[0];\n\t\t\t\t\tvalue = _tuple$12[1];\n\t\t\t\t\terr = _tuple$12[2];\n\t\t\t\t\tif (hour < 0 || 12 < hour) {\n\t\t\t\t\t\trangeErrString = \"hour\";\n\t\t\t\t\t}\n\t\t\t\t} else if ((_1 === (525)) || (_1 === (526))) {\n\t\t\t\t\t_tuple$13 = getnum(value, std === 526);\n\t\t\t\t\tmin = _tuple$13[0];\n\t\t\t\t\tvalue = _tuple$13[1];\n\t\t\t\t\terr = _tuple$13[2];\n\t\t\t\t\tif (min < 0 || 60 <= min) {\n\t\t\t\t\t\trangeErrString = \"minute\";\n\t\t\t\t\t}\n\t\t\t\t} else if ((_1 === (527)) || (_1 === (528))) {\n\t\t\t\t\t_tuple$14 = getnum(value, std === 528);\n\t\t\t\t\tsec = _tuple$14[0];\n\t\t\t\t\tvalue = _tuple$14[1];\n\t\t\t\t\terr = _tuple$14[2];\n\t\t\t\t\tif (sec < 0 || 60 <= sec) {\n\t\t\t\t\t\trangeErrString = \"second\";\n\t\t\t\t\t}\n\t\t\t\t\tif (value.length >= 2 && (value.charCodeAt(0) === 46) && isDigit(value, 1)) {\n\t\t\t\t\t\t_tuple$15 = nextStdChunk(layout);\n\t\t\t\t\t\tstd = _tuple$15[1];\n\t\t\t\t\t\tstd = std & (65535);\n\t\t\t\t\t\tif ((std === 32) || (std === 33)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = 2;\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tif (!(n < value.length && isDigit(value, n))) { break; }\n\t\t\t\t\t\t\tn = n + (1) >> 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tuple$16 = parseNanoseconds(value, n);\n\t\t\t\t\t\tnsec = _tuple$16[0];\n\t\t\t\t\t\trangeErrString = _tuple$16[1];\n\t\t\t\t\t\terr = _tuple$16[2];\n\t\t\t\t\t\tvalue = $substring(value, n);\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (531)) {\n\t\t\t\t\tif (value.length < 2) {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$6 = $substring(value, 0, 2);\n\t\t\t\t\t_tmp$7 = $substring(value, 2);\n\t\t\t\t\tp = _tmp$6;\n\t\t\t\t\tvalue = _tmp$7;\n\t\t\t\t\t_2 = p;\n\t\t\t\t\tif (_2 === (\"PM\")) {\n\t\t\t\t\t\tpmSet = true;\n\t\t\t\t\t} else if (_2 === (\"AM\")) {\n\t\t\t\t\t\tamSet = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (532)) {\n\t\t\t\t\tif (value.length < 2) {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$8 = $substring(value, 0, 2);\n\t\t\t\t\t_tmp$9 = $substring(value, 2);\n\t\t\t\t\tp = _tmp$8;\n\t\t\t\t\tvalue = _tmp$9;\n\t\t\t\t\t_3 = p;\n\t\t\t\t\tif (_3 === (\"pm\")) {\n\t\t\t\t\t\tpmSet = true;\n\t\t\t\t\t} else if (_3 === (\"am\")) {\n\t\t\t\t\t\tamSet = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t}\n\t\t\t\t} else if ((_1 === (22)) || (_1 === (25)) || (_1 === (23)) || (_1 === (24)) || (_1 === (26)) || (_1 === (27)) || (_1 === (29)) || (_1 === (30)) || (_1 === (28)) || (_1 === (31))) {\n\t\t\t\t\tif (((std === 22) || (std === 24) || (std === 25)) && value.length >= 1 && (value.charCodeAt(0) === 90)) {\n\t\t\t\t\t\tvalue = $substring(value, 1);\n\t\t\t\t\t\tz = $pkg.UTC;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$10 = \"\";\n\t\t\t\t\t_tmp$11 = \"\";\n\t\t\t\t\t_tmp$12 = \"\";\n\t\t\t\t\t_tmp$13 = \"\";\n\t\t\t\t\tsign = _tmp$10;\n\t\t\t\t\thour$1 = _tmp$11;\n\t\t\t\t\tmin$1 = _tmp$12;\n\t\t\t\t\tseconds = _tmp$13;\n\t\t\t\t\tif ((std === 25) || (std === 30)) {\n\t\t\t\t\t\tif (value.length < 6) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!((value.charCodeAt(3) === 58))) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tmp$14 = $substring(value, 0, 1);\n\t\t\t\t\t\t_tmp$15 = $substring(value, 1, 3);\n\t\t\t\t\t\t_tmp$16 = $substring(value, 4, 6);\n\t\t\t\t\t\t_tmp$17 = \"00\";\n\t\t\t\t\t\t_tmp$18 = $substring(value, 6);\n\t\t\t\t\t\tsign = _tmp$14;\n\t\t\t\t\t\thour$1 = _tmp$15;\n\t\t\t\t\t\tmin$1 = _tmp$16;\n\t\t\t\t\t\tseconds = _tmp$17;\n\t\t\t\t\t\tvalue = _tmp$18;\n\t\t\t\t\t} else if ((std === 29) || (std === 24)) {\n\t\t\t\t\t\tif (value.length < 3) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tmp$19 = $substring(value, 0, 1);\n\t\t\t\t\t\t_tmp$20 = $substring(value, 1, 3);\n\t\t\t\t\t\t_tmp$21 = \"00\";\n\t\t\t\t\t\t_tmp$22 = \"00\";\n\t\t\t\t\t\t_tmp$23 = $substring(value, 3);\n\t\t\t\t\t\tsign = _tmp$19;\n\t\t\t\t\t\thour$1 = _tmp$20;\n\t\t\t\t\t\tmin$1 = _tmp$21;\n\t\t\t\t\t\tseconds = _tmp$22;\n\t\t\t\t\t\tvalue = _tmp$23;\n\t\t\t\t\t} else if ((std === 26) || (std === 31)) {\n\t\t\t\t\t\tif (value.length < 9) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!((value.charCodeAt(3) === 58)) || !((value.charCodeAt(6) === 58))) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tmp$24 = $substring(value, 0, 1);\n\t\t\t\t\t\t_tmp$25 = $substring(value, 1, 3);\n\t\t\t\t\t\t_tmp$26 = $substring(value, 4, 6);\n\t\t\t\t\t\t_tmp$27 = $substring(value, 7, 9);\n\t\t\t\t\t\t_tmp$28 = $substring(value, 9);\n\t\t\t\t\t\tsign = _tmp$24;\n\t\t\t\t\t\thour$1 = _tmp$25;\n\t\t\t\t\t\tmin$1 = _tmp$26;\n\t\t\t\t\t\tseconds = _tmp$27;\n\t\t\t\t\t\tvalue = _tmp$28;\n\t\t\t\t\t} else if ((std === 23) || (std === 28)) {\n\t\t\t\t\t\tif (value.length < 7) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tmp$29 = $substring(value, 0, 1);\n\t\t\t\t\t\t_tmp$30 = $substring(value, 1, 3);\n\t\t\t\t\t\t_tmp$31 = $substring(value, 3, 5);\n\t\t\t\t\t\t_tmp$32 = $substring(value, 5, 7);\n\t\t\t\t\t\t_tmp$33 = $substring(value, 7);\n\t\t\t\t\t\tsign = _tmp$29;\n\t\t\t\t\t\thour$1 = _tmp$30;\n\t\t\t\t\t\tmin$1 = _tmp$31;\n\t\t\t\t\t\tseconds = _tmp$32;\n\t\t\t\t\t\tvalue = _tmp$33;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value.length < 5) {\n\t\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_tmp$34 = $substring(value, 0, 1);\n\t\t\t\t\t\t_tmp$35 = $substring(value, 1, 3);\n\t\t\t\t\t\t_tmp$36 = $substring(value, 3, 5);\n\t\t\t\t\t\t_tmp$37 = \"00\";\n\t\t\t\t\t\t_tmp$38 = $substring(value, 5);\n\t\t\t\t\t\tsign = _tmp$34;\n\t\t\t\t\t\thour$1 = _tmp$35;\n\t\t\t\t\t\tmin$1 = _tmp$36;\n\t\t\t\t\t\tseconds = _tmp$37;\n\t\t\t\t\t\tvalue = _tmp$38;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$39 = 0;\n\t\t\t\t\t_tmp$40 = 0;\n\t\t\t\t\t_tmp$41 = 0;\n\t\t\t\t\thr = _tmp$39;\n\t\t\t\t\tmm = _tmp$40;\n\t\t\t\t\tss = _tmp$41;\n\t\t\t\t\t_tuple$17 = atoi(hour$1);\n\t\t\t\t\thr = _tuple$17[0];\n\t\t\t\t\terr = _tuple$17[1];\n\t\t\t\t\tif ($interfaceIsEqual(err, $ifaceNil)) {\n\t\t\t\t\t\t_tuple$18 = atoi(min$1);\n\t\t\t\t\t\tmm = _tuple$18[0];\n\t\t\t\t\t\terr = _tuple$18[1];\n\t\t\t\t\t}\n\t\t\t\t\tif ($interfaceIsEqual(err, $ifaceNil)) {\n\t\t\t\t\t\t_tuple$19 = atoi(seconds);\n\t\t\t\t\t\tss = _tuple$19[0];\n\t\t\t\t\t\terr = _tuple$19[1];\n\t\t\t\t\t}\n\t\t\t\t\tzoneOffset = ($imul(((($imul(hr, 60)) + mm >> 0)), 60)) + ss >> 0;\n\t\t\t\t\t_4 = sign.charCodeAt(0);\n\t\t\t\t\tif (_4 === (43)) {\n\t\t\t\t\t} else if (_4 === (45)) {\n\t\t\t\t\t\tzoneOffset = -zoneOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t}\n\t\t\t\t} else if (_1 === (21)) {\n\t\t\t\t\tif (value.length >= 3 && $substring(value, 0, 3) === \"UTC\") {\n\t\t\t\t\t\tz = $pkg.UTC;\n\t\t\t\t\t\tvalue = $substring(value, 3);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tuple$20 = parseTimeZone(value);\n\t\t\t\t\tn$1 = _tuple$20[0];\n\t\t\t\t\tok = _tuple$20[1];\n\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tmp$42 = $substring(value, 0, n$1);\n\t\t\t\t\t_tmp$43 = $substring(value, n$1);\n\t\t\t\t\tzoneName = _tmp$42;\n\t\t\t\t\tvalue = _tmp$43;\n\t\t\t\t} else if (_1 === (32)) {\n\t\t\t\t\tndigit = 1 + ((std >> 16 >> 0)) >> 0;\n\t\t\t\t\tif (value.length < ndigit) {\n\t\t\t\t\t\terr = errBad;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_tuple$21 = parseNanoseconds(value, ndigit);\n\t\t\t\t\tnsec = _tuple$21[0];\n\t\t\t\t\trangeErrString = _tuple$21[1];\n\t\t\t\t\terr = _tuple$21[2];\n\t\t\t\t\tvalue = $substring(value, ndigit);\n\t\t\t\t} else if (_1 === (33)) {\n\t\t\t\t\tif (value.length < 2 || !((value.charCodeAt(0) === 46)) || value.charCodeAt(1) < 48 || 57 < value.charCodeAt(1)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!(i < 9 && (i + 1 >> 0) < value.length && 48 <= value.charCodeAt((i + 1 >> 0)) && value.charCodeAt((i + 1 >> 0)) <= 57)) { break; }\n\t\t\t\t\t\ti = i + (1) >> 0;\n\t\t\t\t\t}\n\t\t\t\t\t_tuple$22 = parseNanoseconds(value, 1 + i >> 0);\n\t\t\t\t\tnsec = _tuple$22[0];\n\t\t\t\t\trangeErrString = _tuple$22[1];\n\t\t\t\t\terr = _tuple$22[2];\n\t\t\t\t\tvalue = $substring(value, (1 + i >> 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(rangeErrString === \"\")) {\n\t\t\t\t$s = -1; return [new Time.ptr(new $Int64(0, 0), 0, ptrType$1.nil), new ParseError.ptr(alayout, avalue, stdstr, value, \": \" + rangeErrString + \" out of range\")];\n\t\t\t}\n\t\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t\t$s = -1; return [new Time.ptr(new $Int64(0, 0), 0, ptrType$1.nil), new ParseError.ptr(alayout, avalue, stdstr, value, \"\")];\n\t\t\t}\n\t\t}\n\t\tif (pmSet && hour < 12) {\n\t\t\thour = hour + (12) >> 0;\n\t\t} else if (amSet && (hour === 12)) {\n\t\t\thour = 0;\n\t\t}\n\t\tif (day > daysIn((month >> 0), year)) {\n\t\t\t$s = -1; return [new Time.ptr(new $Int64(0, 0), 0, ptrType$1.nil), new ParseError.ptr(alayout, avalue, \"\", value, \": day out of range\")];\n\t\t}\n\t\t/* */ if (!(z === ptrType$1.nil)) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!(z === ptrType$1.nil)) { */ case 1:\n\t\t\t_r$1 = Date(year, (month >> 0), day, hour, min, sec, nsec, z); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return [_r$1, $ifaceNil];\n\t\t/* } */ case 2:\n\t\t/* */ if (!((zoneOffset === -1))) { $s = 4; continue; }\n\t\t/* */ $s = 5; continue;\n\t\t/* if (!((zoneOffset === -1))) { */ case 4:\n\t\t\t_r$2 = Date(year, (month >> 0), day, hour, min, sec, nsec, $pkg.UTC); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\tt = $clone(_r$2, Time);\n\t\t\tt.sec = (x = t.sec, x$1 = new $Int64(0, zoneOffset), new $Int64(x.$high - x$1.$high, x.$low - x$1.$low));\n\t\t\t_r$3 = local.lookup((x$2 = t.sec, new $Int64(x$2.$high + -15, x$2.$low + 2288912640))); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t_tuple$23 = _r$3;\n\t\t\tname = _tuple$23[0];\n\t\t\toffset = _tuple$23[1];\n\t\t\tif ((offset === zoneOffset) && (zoneName === \"\" || name === zoneName)) {\n\t\t\t\tt.loc = local;\n\t\t\t\t$s = -1; return [t, $ifaceNil];\n\t\t\t}\n\t\t\tt.loc = FixedZone(zoneName, zoneOffset);\n\t\t\t$s = -1; return [t, $ifaceNil];\n\t\t/* } */ case 5:\n\t\t/* */ if (!(zoneName === \"\")) { $s = 8; continue; }\n\t\t/* */ $s = 9; continue;\n\t\t/* if (!(zoneName === \"\")) { */ case 8:\n\t\t\t_r$4 = Date(year, (month >> 0), day, hour, min, sec, nsec, $pkg.UTC); /* */ $s = 10; case 10: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t\tt$1 = $clone(_r$4, Time);\n\t\t\t_r$5 = local.lookupName(zoneName, (x$3 = t$1.sec, new $Int64(x$3.$high + -15, x$3.$low + 2288912640))); /* */ $s = 11; case 11: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }\n\t\t\t_tuple$24 = _r$5;\n\t\t\toffset$1 = _tuple$24[0];\n\t\t\tok$1 = _tuple$24[2];\n\t\t\tif (ok$1) {\n\t\t\t\tt$1.sec = (x$4 = t$1.sec, x$5 = new $Int64(0, offset$1), new $Int64(x$4.$high - x$5.$high, x$4.$low - x$5.$low));\n\t\t\t\tt$1.loc = local;\n\t\t\t\t$s = -1; return [t$1, $ifaceNil];\n\t\t\t}\n\t\t\tif (zoneName.length > 3 && $substring(zoneName, 0, 3) === \"GMT\") {\n\t\t\t\t_tuple$25 = atoi($substring(zoneName, 3));\n\t\t\t\toffset$1 = _tuple$25[0];\n\t\t\t\toffset$1 = $imul(offset$1, (3600));\n\t\t\t}\n\t\t\tt$1.loc = FixedZone(zoneName, offset$1);\n\t\t\t$s = -1; return [t$1, $ifaceNil];\n\t\t/* } */ case 9:\n\t\t_r$6 = Date(year, (month >> 0), day, hour, min, sec, nsec, defaultLocation); /* */ $s = 12; case 12: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }\n\t\t$s = -1; return [_r$6, $ifaceNil];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: parse }; } $f.$ptr = $ptr; $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$10 = _tmp$10; $f._tmp$11 = _tmp$11; $f._tmp$12 = _tmp$12; $f._tmp$13 = _tmp$13; $f._tmp$14 = _tmp$14; $f._tmp$15 = _tmp$15; $f._tmp$16 = _tmp$16; $f._tmp$17 = _tmp$17; $f._tmp$18 = _tmp$18; $f._tmp$19 = _tmp$19; $f._tmp$2 = _tmp$2; $f._tmp$20 = _tmp$20; $f._tmp$21 = _tmp$21; $f._tmp$22 = _tmp$22; $f._tmp$23 = _tmp$23; $f._tmp$24 = _tmp$24; $f._tmp$25 = _tmp$25; $f._tmp$26 = _tmp$26; $f._tmp$27 = _tmp$27; $f._tmp$28 = _tmp$28; $f._tmp$29 = _tmp$29; $f._tmp$3 = _tmp$3; $f._tmp$30 = _tmp$30; $f._tmp$31 = _tmp$31; $f._tmp$32 = _tmp$32; $f._tmp$33 = _tmp$33; $f._tmp$34 = _tmp$34; $f._tmp$35 = _tmp$35; $f._tmp$36 = _tmp$36; $f._tmp$37 = _tmp$37; $f._tmp$38 = _tmp$38; $f._tmp$39 = _tmp$39; $f._tmp$4 = _tmp$4; $f._tmp$40 = _tmp$40; $f._tmp$41 = _tmp$41; $f._tmp$42 = _tmp$42; $f._tmp$43 = _tmp$43; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$12 = _tuple$12; $f._tuple$13 = _tuple$13; $f._tuple$14 = _tuple$14; $f._tuple$15 = _tuple$15; $f._tuple$16 = _tuple$16; $f._tuple$17 = _tuple$17; $f._tuple$18 = _tuple$18; $f._tuple$19 = _tuple$19; $f._tuple$2 = _tuple$2; $f._tuple$20 = _tuple$20; $f._tuple$21 = _tuple$21; $f._tuple$22 = _tuple$22; $f._tuple$23 = _tuple$23; $f._tuple$24 = _tuple$24; $f._tuple$25 = _tuple$25; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.alayout = alayout; $f.amSet = amSet; $f.avalue = avalue; $f.day = day; $f.defaultLocation = defaultLocation; $f.err = err; $f.hour = hour; $f.hour$1 = hour$1; $f.hr = hr; $f.i = i; $f.layout = layout; $f.local = local; $f.min = min; $f.min$1 = min$1; $f.mm = mm; $f.month = month; $f.n = n; $f.n$1 = n$1; $f.name = name; $f.ndigit = ndigit; $f.nsec = nsec; $f.offset = offset; $f.offset$1 = offset$1; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.pmSet = pmSet; $f.prefix = prefix; $f.rangeErrString = rangeErrString; $f.sec = sec; $f.seconds = seconds; $f.sign = sign; $f.ss = ss; $f.std = std; $f.stdstr = stdstr; $f.suffix = suffix; $f.t = t; $f.t$1 = t$1; $f.value = value; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.year = year; $f.z = z; $f.zoneName = zoneName; $f.zoneOffset = zoneOffset; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tparseTimeZone = function(value) {\n\t\tvar $ptr, _1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, c, length, nUpper, ok, value;\n\t\tlength = 0;\n\t\tok = false;\n\t\tif (value.length < 3) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = false;\n\t\t\tlength = _tmp;\n\t\t\tok = _tmp$1;\n\t\t\treturn [length, ok];\n\t\t}\n\t\tif (value.length >= 4 && ($substring(value, 0, 4) === \"ChST\" || $substring(value, 0, 4) === \"MeST\")) {\n\t\t\t_tmp$2 = 4;\n\t\t\t_tmp$3 = true;\n\t\t\tlength = _tmp$2;\n\t\t\tok = _tmp$3;\n\t\t\treturn [length, ok];\n\t\t}\n\t\tif ($substring(value, 0, 3) === \"GMT\") {\n\t\t\tlength = parseGMT(value);\n\t\t\t_tmp$4 = length;\n\t\t\t_tmp$5 = true;\n\t\t\tlength = _tmp$4;\n\t\t\tok = _tmp$5;\n\t\t\treturn [length, ok];\n\t\t}\n\t\tnUpper = 0;\n\t\tnUpper = 0;\n\t\twhile (true) {\n\t\t\tif (!(nUpper < 6)) { break; }\n\t\t\tif (nUpper >= value.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = value.charCodeAt(nUpper);\n\t\t\tif (c < 65 || 90 < c) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnUpper = nUpper + (1) >> 0;\n\t\t}\n\t\t_1 = nUpper;\n\t\tif ((_1 === (0)) || (_1 === (1)) || (_1 === (2)) || (_1 === (6))) {\n\t\t\t_tmp$6 = 0;\n\t\t\t_tmp$7 = false;\n\t\t\tlength = _tmp$6;\n\t\t\tok = _tmp$7;\n\t\t\treturn [length, ok];\n\t\t} else if (_1 === (5)) {\n\t\t\tif (value.charCodeAt(4) === 84) {\n\t\t\t\t_tmp$8 = 5;\n\t\t\t\t_tmp$9 = true;\n\t\t\t\tlength = _tmp$8;\n\t\t\t\tok = _tmp$9;\n\t\t\t\treturn [length, ok];\n\t\t\t}\n\t\t} else if (_1 === (4)) {\n\t\t\tif (value.charCodeAt(3) === 84) {\n\t\t\t\t_tmp$10 = 4;\n\t\t\t\t_tmp$11 = true;\n\t\t\t\tlength = _tmp$10;\n\t\t\t\tok = _tmp$11;\n\t\t\t\treturn [length, ok];\n\t\t\t}\n\t\t} else if (_1 === (3)) {\n\t\t\t_tmp$12 = 3;\n\t\t\t_tmp$13 = true;\n\t\t\tlength = _tmp$12;\n\t\t\tok = _tmp$13;\n\t\t\treturn [length, ok];\n\t\t}\n\t\t_tmp$14 = 0;\n\t\t_tmp$15 = false;\n\t\tlength = _tmp$14;\n\t\tok = _tmp$15;\n\t\treturn [length, ok];\n\t};\n\tparseGMT = function(value) {\n\t\tvar $ptr, _tuple$1, err, rem, sign, value, x;\n\t\tvalue = $substring(value, 3);\n\t\tif (value.length === 0) {\n\t\t\treturn 3;\n\t\t}\n\t\tsign = value.charCodeAt(0);\n\t\tif (!((sign === 45)) && !((sign === 43))) {\n\t\t\treturn 3;\n\t\t}\n\t\t_tuple$1 = leadingInt($substring(value, 1));\n\t\tx = _tuple$1[0];\n\t\trem = _tuple$1[1];\n\t\terr = _tuple$1[2];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\treturn 3;\n\t\t}\n\t\tif (sign === 45) {\n\t\t\tx = new $Int64(-x.$high, -x.$low);\n\t\t}\n\t\tif ((x.$high === 0 && x.$low === 0) || (x.$high < -1 || (x.$high === -1 && x.$low < 4294967282)) || (0 < x.$high || (0 === x.$high && 12 < x.$low))) {\n\t\t\treturn 3;\n\t\t}\n\t\treturn (3 + value.length >> 0) - rem.length >> 0;\n\t};\n\tparseNanoseconds = function(value, nbytes) {\n\t\tvar $ptr, _tuple$1, err, i, nbytes, ns, rangeErrString, scaleDigits, value;\n\t\tns = 0;\n\t\trangeErrString = \"\";\n\t\terr = $ifaceNil;\n\t\tif (!((value.charCodeAt(0) === 46))) {\n\t\t\terr = errBad;\n\t\t\treturn [ns, rangeErrString, err];\n\t\t}\n\t\t_tuple$1 = atoi($substring(value, 1, nbytes));\n\t\tns = _tuple$1[0];\n\t\terr = _tuple$1[1];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\treturn [ns, rangeErrString, err];\n\t\t}\n\t\tif (ns < 0 || 1000000000 <= ns) {\n\t\t\trangeErrString = \"fractional second\";\n\t\t\treturn [ns, rangeErrString, err];\n\t\t}\n\t\tscaleDigits = 10 - nbytes >> 0;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < scaleDigits)) { break; }\n\t\t\tns = $imul(ns, (10));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\treturn [ns, rangeErrString, err];\n\t};\n\tleadingInt = function(s) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, c, err, i, rem, s, x, x$1, x$2, x$3;\n\t\tx = new $Int64(0, 0);\n\t\trem = \"\";\n\t\terr = $ifaceNil;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < s.length)) { break; }\n\t\t\tc = s.charCodeAt(i);\n\t\t\tif (c < 48 || c > 57) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((x.$high > 214748364 || (x.$high === 214748364 && x.$low > 3435973836))) {\n\t\t\t\t_tmp = new $Int64(0, 0);\n\t\t\t\t_tmp$1 = \"\";\n\t\t\t\t_tmp$2 = errLeadingInt;\n\t\t\t\tx = _tmp;\n\t\t\t\trem = _tmp$1;\n\t\t\t\terr = _tmp$2;\n\t\t\t\treturn [x, rem, err];\n\t\t\t}\n\t\t\tx = (x$1 = (x$2 = $mul64(x, new $Int64(0, 10)), x$3 = new $Int64(0, c), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low)), new $Int64(x$1.$high - 0, x$1.$low - 48));\n\t\t\tif ((x.$high < 0 || (x.$high === 0 && x.$low < 0))) {\n\t\t\t\t_tmp$3 = new $Int64(0, 0);\n\t\t\t\t_tmp$4 = \"\";\n\t\t\t\t_tmp$5 = errLeadingInt;\n\t\t\t\tx = _tmp$3;\n\t\t\t\trem = _tmp$4;\n\t\t\t\terr = _tmp$5;\n\t\t\t\treturn [x, rem, err];\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\t_tmp$6 = x;\n\t\t_tmp$7 = $substring(s, i);\n\t\t_tmp$8 = $ifaceNil;\n\t\tx = _tmp$6;\n\t\trem = _tmp$7;\n\t\terr = _tmp$8;\n\t\treturn [x, rem, err];\n\t};\n\tTime.ptr.prototype.After = function(u) {\n\t\tvar $ptr, t, u, x, x$1, x$2, x$3;\n\t\tt = this;\n\t\treturn (x = t.sec, x$1 = u.sec, (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low > x$1.$low))) || (x$2 = t.sec, x$3 = u.sec, (x$2.$high === x$3.$high && x$2.$low === x$3.$low)) && t.nsec > u.nsec;\n\t};\n\tTime.prototype.After = function(u) { return this.$val.After(u); };\n\tTime.ptr.prototype.Before = function(u) {\n\t\tvar $ptr, t, u, x, x$1, x$2, x$3;\n\t\tt = this;\n\t\treturn (x = t.sec, x$1 = u.sec, (x.$high < x$1.$high || (x.$high === x$1.$high && x.$low < x$1.$low))) || (x$2 = t.sec, x$3 = u.sec, (x$2.$high === x$3.$high && x$2.$low === x$3.$low)) && t.nsec < u.nsec;\n\t};\n\tTime.prototype.Before = function(u) { return this.$val.Before(u); };\n\tTime.ptr.prototype.Equal = function(u) {\n\t\tvar $ptr, t, u, x, x$1;\n\t\tt = this;\n\t\treturn (x = t.sec, x$1 = u.sec, (x.$high === x$1.$high && x.$low === x$1.$low)) && (t.nsec === u.nsec);\n\t};\n\tTime.prototype.Equal = function(u) { return this.$val.Equal(u); };\n\tMonth.prototype.String = function() {\n\t\tvar $ptr, m, x;\n\t\tm = this.$val;\n\t\treturn (x = m - 1 >> 0, ((x < 0 || x >= months.length) ? $throwRuntimeError(\"index out of range\") : months[x]));\n\t};\n\t$ptrType(Month).prototype.String = function() { return new Month(this.$get()).String(); };\n\tWeekday.prototype.String = function() {\n\t\tvar $ptr, d;\n\t\td = this.$val;\n\t\treturn ((d < 0 || d >= days.length) ? $throwRuntimeError(\"index out of range\") : days[d]);\n\t};\n\t$ptrType(Weekday).prototype.String = function() { return new Weekday(this.$get()).String(); };\n\tTime.ptr.prototype.IsZero = function() {\n\t\tvar $ptr, t, x;\n\t\tt = this;\n\t\treturn (x = t.sec, (x.$high === 0 && x.$low === 0)) && (t.nsec === 0);\n\t};\n\tTime.prototype.IsZero = function() { return this.$val.IsZero(); };\n\tTime.ptr.prototype.abs = function() {\n\t\tvar $ptr, _r$1, _r$2, _tuple$1, l, offset, sec, t, x, x$1, x$2, x$3, x$4, x$5, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple$1 = $f._tuple$1; l = $f.l; offset = $f.offset; sec = $f.sec; t = $f.t; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tl = t.loc;\n\t\t/* */ if (l === ptrType$1.nil || l === localLoc) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (l === ptrType$1.nil || l === localLoc) { */ case 1:\n\t\t\t_r$1 = l.get(); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\tl = _r$1;\n\t\t/* } */ case 2:\n\t\tsec = (x = t.sec, new $Int64(x.$high + -15, x.$low + 2288912640));\n\t\t/* */ if (!(l === utcLoc)) { $s = 4; continue; }\n\t\t/* */ $s = 5; continue;\n\t\t/* if (!(l === utcLoc)) { */ case 4:\n\t\t\t/* */ if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { $s = 6; continue; }\n\t\t\t/* */ $s = 7; continue;\n\t\t\t/* if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { */ case 6:\n\t\t\t\tsec = (x$3 = new $Int64(0, l.cacheZone.offset), new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else { */ case 7:\n\t\t\t\t_r$2 = l.lookup(sec); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_tuple$1 = _r$2;\n\t\t\t\toffset = _tuple$1[1];\n\t\t\t\tsec = (x$4 = new $Int64(0, offset), new $Int64(sec.$high + x$4.$high, sec.$low + x$4.$low));\n\t\t\t/* } */ case 8:\n\t\t/* } */ case 5:\n\t\t$s = -1; return (x$5 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384), new $Uint64(x$5.$high, x$5.$low));\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.abs }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple$1 = _tuple$1; $f.l = l; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.abs = function() { return this.$val.abs(); };\n\tTime.ptr.prototype.locabs = function() {\n\t\tvar $ptr, _r$1, _r$2, _tuple$1, abs, l, name, offset, sec, t, x, x$1, x$2, x$3, x$4, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple$1 = $f._tuple$1; abs = $f.abs; l = $f.l; name = $f.name; offset = $f.offset; sec = $f.sec; t = $f.t; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tname = \"\";\n\t\toffset = 0;\n\t\tabs = new $Uint64(0, 0);\n\t\tt = this;\n\t\tl = t.loc;\n\t\t/* */ if (l === ptrType$1.nil || l === localLoc) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (l === ptrType$1.nil || l === localLoc) { */ case 1:\n\t\t\t_r$1 = l.get(); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\tl = _r$1;\n\t\t/* } */ case 2:\n\t\tsec = (x = t.sec, new $Int64(x.$high + -15, x.$low + 2288912640));\n\t\t/* */ if (!(l === utcLoc)) { $s = 4; continue; }\n\t\t/* */ $s = 5; continue;\n\t\t/* if (!(l === utcLoc)) { */ case 4:\n\t\t\t/* */ if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { $s = 7; continue; }\n\t\t\t/* */ $s = 8; continue;\n\t\t\t/* if (!(l.cacheZone === ptrType.nil) && (x$1 = l.cacheStart, (x$1.$high < sec.$high || (x$1.$high === sec.$high && x$1.$low <= sec.$low))) && (x$2 = l.cacheEnd, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) { */ case 7:\n\t\t\t\tname = l.cacheZone.name;\n\t\t\t\toffset = l.cacheZone.offset;\n\t\t\t\t$s = 9; continue;\n\t\t\t/* } else { */ case 8:\n\t\t\t\t_r$2 = l.lookup(sec); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_tuple$1 = _r$2;\n\t\t\t\tname = _tuple$1[0];\n\t\t\t\toffset = _tuple$1[1];\n\t\t\t/* } */ case 9:\n\t\t\tsec = (x$3 = new $Int64(0, offset), new $Int64(sec.$high + x$3.$high, sec.$low + x$3.$low));\n\t\t\t$s = 6; continue;\n\t\t/* } else { */ case 5:\n\t\t\tname = \"UTC\";\n\t\t/* } */ case 6:\n\t\tabs = (x$4 = new $Int64(sec.$high + 2147483646, sec.$low + 450480384), new $Uint64(x$4.$high, x$4.$low));\n\t\t$s = -1; return [name, offset, abs];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.locabs }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple$1 = _tuple$1; $f.abs = abs; $f.l = l; $f.name = name; $f.offset = offset; $f.sec = sec; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.locabs = function() { return this.$val.locabs(); };\n\tTime.ptr.prototype.Date = function() {\n\t\tvar $ptr, _r$1, _tuple$1, day, month, t, year, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; day = $f.day; month = $f.month; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tyear = 0;\n\t\tmonth = 0;\n\t\tday = 0;\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tyear = _tuple$1[0];\n\t\tmonth = _tuple$1[1];\n\t\tday = _tuple$1[2];\n\t\t$s = -1; return [year, month, day];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Date }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.day = day; $f.month = month; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Date = function() { return this.$val.Date(); };\n\tTime.ptr.prototype.Year = function() {\n\t\tvar $ptr, _r$1, _tuple$1, t, year, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; t = $f.t; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).date(false); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tyear = _tuple$1[0];\n\t\t$s = -1; return year;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Year }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.t = t; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Year = function() { return this.$val.Year(); };\n\tTime.ptr.prototype.Month = function() {\n\t\tvar $ptr, _r$1, _tuple$1, month, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; month = $f.month; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tmonth = _tuple$1[1];\n\t\t$s = -1; return month;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Month }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.month = month; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Month = function() { return this.$val.Month(); };\n\tTime.ptr.prototype.Day = function() {\n\t\tvar $ptr, _r$1, _tuple$1, day, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; day = $f.day; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tday = _tuple$1[2];\n\t\t$s = -1; return day;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Day }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.day = day; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Day = function() { return this.$val.Day(); };\n\tTime.ptr.prototype.Weekday = function() {\n\t\tvar $ptr, _r$1, _r$2, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_r$2 = absWeekday(_r$1); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$2;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Weekday }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Weekday = function() { return this.$val.Weekday(); };\n\tabsWeekday = function(abs) {\n\t\tvar $ptr, _q, abs, sec;\n\t\tsec = $div64((new $Uint64(abs.$high + 0, abs.$low + 86400)), new $Uint64(0, 604800), true);\n\t\treturn ((_q = (sec.$low >> 0) / 86400, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) >> 0);\n\t};\n\tTime.ptr.prototype.ISOWeek = function() {\n\t\tvar $ptr, _q, _r$1, _r$2, _r$3, _r$4, _r$5, _tuple$1, day, dec31wday, jan1wday, month, t, wday, week, yday, year, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _q = $f._q; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _tuple$1 = $f._tuple$1; day = $f.day; dec31wday = $f.dec31wday; jan1wday = $f.jan1wday; month = $f.month; t = $f.t; wday = $f.wday; week = $f.week; yday = $f.yday; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tyear = 0;\n\t\tweek = 0;\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).date(true); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tyear = _tuple$1[0];\n\t\tmonth = _tuple$1[1];\n\t\tday = _tuple$1[2];\n\t\tyday = _tuple$1[3];\n\t\t_r$3 = $clone(t, Time).Weekday(); /* */ $s = 2; case 2: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\twday = (_r$2 = ((_r$3 + 6 >> 0) >> 0) % 7, _r$2 === _r$2 ? _r$2 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tweek = (_q = (((yday - wday >> 0) + 7 >> 0)) / 7, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tjan1wday = (_r$4 = (((wday - yday >> 0) + 371 >> 0)) % 7, _r$4 === _r$4 ? _r$4 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tif (1 <= jan1wday && jan1wday <= 3) {\n\t\t\tweek = week + (1) >> 0;\n\t\t}\n\t\tif (week === 0) {\n\t\t\tyear = year - (1) >> 0;\n\t\t\tweek = 52;\n\t\t\tif ((jan1wday === 4) || ((jan1wday === 5) && isLeap(year))) {\n\t\t\t\tweek = week + (1) >> 0;\n\t\t\t}\n\t\t}\n\t\tif ((month === 12) && day >= 29 && wday < 3) {\n\t\t\tdec31wday = (_r$5 = (((wday + 31 >> 0) - day >> 0)) % 7, _r$5 === _r$5 ? _r$5 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\tif (0 <= dec31wday && dec31wday <= 2) {\n\t\t\t\tyear = year + (1) >> 0;\n\t\t\t\tweek = 1;\n\t\t\t}\n\t\t}\n\t\t$s = -1; return [year, week];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.ISOWeek }; } $f.$ptr = $ptr; $f._q = _q; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._tuple$1 = _tuple$1; $f.day = day; $f.dec31wday = dec31wday; $f.jan1wday = jan1wday; $f.month = month; $f.t = t; $f.wday = wday; $f.week = week; $f.yday = yday; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.ISOWeek = function() { return this.$val.ISOWeek(); };\n\tTime.ptr.prototype.Clock = function() {\n\t\tvar $ptr, _r$1, _r$2, _tuple$1, hour, min, sec, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple$1 = $f._tuple$1; hour = $f.hour; min = $f.min; sec = $f.sec; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\thour = 0;\n\t\tmin = 0;\n\t\tsec = 0;\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_r$2 = absClock(_r$1); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$2;\n\t\thour = _tuple$1[0];\n\t\tmin = _tuple$1[1];\n\t\tsec = _tuple$1[2];\n\t\t$s = -1; return [hour, min, sec];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Clock }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple$1 = _tuple$1; $f.hour = hour; $f.min = min; $f.sec = sec; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Clock = function() { return this.$val.Clock(); };\n\tabsClock = function(abs) {\n\t\tvar $ptr, _q, _q$1, abs, hour, min, sec;\n\t\thour = 0;\n\t\tmin = 0;\n\t\tsec = 0;\n\t\tsec = ($div64(abs, new $Uint64(0, 86400), true).$low >> 0);\n\t\thour = (_q = sec / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tsec = sec - (($imul(hour, 3600))) >> 0;\n\t\tmin = (_q$1 = sec / 60, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tsec = sec - (($imul(min, 60))) >> 0;\n\t\treturn [hour, min, sec];\n\t};\n\tTime.ptr.prototype.Hour = function() {\n\t\tvar $ptr, _q, _r$1, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _q = $f._q; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return (_q = ($div64(_r$1, new $Uint64(0, 86400), true).$low >> 0) / 3600, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Hour }; } $f.$ptr = $ptr; $f._q = _q; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Hour = function() { return this.$val.Hour(); };\n\tTime.ptr.prototype.Minute = function() {\n\t\tvar $ptr, _q, _r$1, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _q = $f._q; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return (_q = ($div64(_r$1, new $Uint64(0, 3600), true).$low >> 0) / 60, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Minute }; } $f.$ptr = $ptr; $f._q = _q; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Minute = function() { return this.$val.Minute(); };\n\tTime.ptr.prototype.Second = function() {\n\t\tvar $ptr, _r$1, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return ($div64(_r$1, new $Uint64(0, 60), true).$low >> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Second }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Second = function() { return this.$val.Second(); };\n\tTime.ptr.prototype.Nanosecond = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn (t.nsec >> 0);\n\t};\n\tTime.prototype.Nanosecond = function() { return this.$val.Nanosecond(); };\n\tTime.ptr.prototype.YearDay = function() {\n\t\tvar $ptr, _r$1, _tuple$1, t, yday, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; t = $f.t; yday = $f.yday; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).date(false); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tyday = _tuple$1[3];\n\t\t$s = -1; return yday + 1 >> 0;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.YearDay }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.t = t; $f.yday = yday; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.YearDay = function() { return this.$val.YearDay(); };\n\tDuration.prototype.String = function() {\n\t\tvar $ptr, _tuple$1, _tuple$2, buf, d, neg, prec, u, w;\n\t\td = this;\n\t\tbuf = arrayType$4.zero();\n\t\tw = 32;\n\t\tu = new $Uint64(d.$high, d.$low);\n\t\tneg = (d.$high < 0 || (d.$high === 0 && d.$low < 0));\n\t\tif (neg) {\n\t\t\tu = new $Uint64(-u.$high, -u.$low);\n\t\t}\n\t\tif ((u.$high < 0 || (u.$high === 0 && u.$low < 1000000000))) {\n\t\t\tprec = 0;\n\t\t\tw = w - (1) >> 0;\n\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 115);\n\t\t\tw = w - (1) >> 0;\n\t\t\tif ((u.$high === 0 && u.$low === 0)) {\n\t\t\t\treturn \"0s\";\n\t\t\t} else if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000))) {\n\t\t\t\tprec = 0;\n\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 110);\n\t\t\t} else if ((u.$high < 0 || (u.$high === 0 && u.$low < 1000000))) {\n\t\t\t\tprec = 3;\n\t\t\t\tw = w - (1) >> 0;\n\t\t\t\t$copyString($subslice(new sliceType$3(buf), w), \"\\xC2\\xB5\");\n\t\t\t} else {\n\t\t\t\tprec = 6;\n\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 109);\n\t\t\t}\n\t\t\t_tuple$1 = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, prec);\n\t\t\tw = _tuple$1[0];\n\t\t\tu = _tuple$1[1];\n\t\t\tw = fmtInt($subslice(new sliceType$3(buf), 0, w), u);\n\t\t} else {\n\t\t\tw = w - (1) >> 0;\n\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 115);\n\t\t\t_tuple$2 = fmtFrac($subslice(new sliceType$3(buf), 0, w), u, 9);\n\t\t\tw = _tuple$2[0];\n\t\t\tu = _tuple$2[1];\n\t\t\tw = fmtInt($subslice(new sliceType$3(buf), 0, w), $div64(u, new $Uint64(0, 60), true));\n\t\t\tu = $div64(u, (new $Uint64(0, 60)), false);\n\t\t\tif ((u.$high > 0 || (u.$high === 0 && u.$low > 0))) {\n\t\t\t\tw = w - (1) >> 0;\n\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 109);\n\t\t\t\tw = fmtInt($subslice(new sliceType$3(buf), 0, w), $div64(u, new $Uint64(0, 60), true));\n\t\t\t\tu = $div64(u, (new $Uint64(0, 60)), false);\n\t\t\t\tif ((u.$high > 0 || (u.$high === 0 && u.$low > 0))) {\n\t\t\t\t\tw = w - (1) >> 0;\n\t\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 104);\n\t\t\t\t\tw = fmtInt($subslice(new sliceType$3(buf), 0, w), u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (neg) {\n\t\t\tw = w - (1) >> 0;\n\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 45);\n\t\t}\n\t\treturn $bytesToString($subslice(new sliceType$3(buf), w));\n\t};\n\t$ptrType(Duration).prototype.String = function() { return this.$get().String(); };\n\tfmtFrac = function(buf, v, prec) {\n\t\tvar $ptr, _tmp, _tmp$1, buf, digit, i, nv, nw, prec, print, v, w;\n\t\tnw = 0;\n\t\tnv = new $Uint64(0, 0);\n\t\tw = buf.$length;\n\t\tprint = false;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < prec)) { break; }\n\t\t\tdigit = $div64(v, new $Uint64(0, 10), true);\n\t\t\tprint = print || !((digit.$high === 0 && digit.$low === 0));\n\t\t\tif (print) {\n\t\t\t\tw = w - (1) >> 0;\n\t\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = ((digit.$low << 24 >>> 24) + 48 << 24 >>> 24));\n\t\t\t}\n\t\t\tv = $div64(v, (new $Uint64(0, 10)), false);\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\tif (print) {\n\t\t\tw = w - (1) >> 0;\n\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = 46);\n\t\t}\n\t\t_tmp = w;\n\t\t_tmp$1 = v;\n\t\tnw = _tmp;\n\t\tnv = _tmp$1;\n\t\treturn [nw, nv];\n\t};\n\tfmtInt = function(buf, v) {\n\t\tvar $ptr, buf, v, w;\n\t\tw = buf.$length;\n\t\tif ((v.$high === 0 && v.$low === 0)) {\n\t\t\tw = w - (1) >> 0;\n\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = 48);\n\t\t} else {\n\t\t\twhile (true) {\n\t\t\t\tif (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }\n\t\t\t\tw = w - (1) >> 0;\n\t\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = (($div64(v, new $Uint64(0, 10), true).$low << 24 >>> 24) + 48 << 24 >>> 24));\n\t\t\t\tv = $div64(v, (new $Uint64(0, 10)), false);\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t};\n\tDuration.prototype.Nanoseconds = function() {\n\t\tvar $ptr, d;\n\t\td = this;\n\t\treturn new $Int64(d.$high, d.$low);\n\t};\n\t$ptrType(Duration).prototype.Nanoseconds = function() { return this.$get().Nanoseconds(); };\n\tDuration.prototype.Seconds = function() {\n\t\tvar $ptr, d, nsec, sec;\n\t\td = this;\n\t\tsec = $div64(d, new Duration(0, 1000000000), false);\n\t\tnsec = $div64(d, new Duration(0, 1000000000), true);\n\t\treturn $flatten64(sec) + $flatten64(nsec) * 1e-09;\n\t};\n\t$ptrType(Duration).prototype.Seconds = function() { return this.$get().Seconds(); };\n\tDuration.prototype.Minutes = function() {\n\t\tvar $ptr, d, min, nsec;\n\t\td = this;\n\t\tmin = $div64(d, new Duration(13, 4165425152), false);\n\t\tnsec = $div64(d, new Duration(13, 4165425152), true);\n\t\treturn $flatten64(min) + $flatten64(nsec) * 1.6666666666666667e-11;\n\t};\n\t$ptrType(Duration).prototype.Minutes = function() { return this.$get().Minutes(); };\n\tDuration.prototype.Hours = function() {\n\t\tvar $ptr, d, hour, nsec;\n\t\td = this;\n\t\thour = $div64(d, new Duration(838, 817405952), false);\n\t\tnsec = $div64(d, new Duration(838, 817405952), true);\n\t\treturn $flatten64(hour) + $flatten64(nsec) * 2.777777777777778e-13;\n\t};\n\t$ptrType(Duration).prototype.Hours = function() { return this.$get().Hours(); };\n\tTime.ptr.prototype.Add = function(d) {\n\t\tvar $ptr, d, nsec, t, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;\n\t\tt = this;\n\t\tt.sec = (x = t.sec, x$1 = (x$2 = $div64(d, new Duration(0, 1000000000), false), new $Int64(x$2.$high, x$2.$low)), new $Int64(x.$high + x$1.$high, x.$low + x$1.$low));\n\t\tnsec = t.nsec + ((x$3 = $div64(d, new Duration(0, 1000000000), true), x$3.$low + ((x$3.$high >> 31) * 4294967296)) >> 0) >> 0;\n\t\tif (nsec >= 1000000000) {\n\t\t\tt.sec = (x$4 = t.sec, x$5 = new $Int64(0, 1), new $Int64(x$4.$high + x$5.$high, x$4.$low + x$5.$low));\n\t\t\tnsec = nsec - (1000000000) >> 0;\n\t\t} else if (nsec < 0) {\n\t\t\tt.sec = (x$6 = t.sec, x$7 = new $Int64(0, 1), new $Int64(x$6.$high - x$7.$high, x$6.$low - x$7.$low));\n\t\t\tnsec = nsec + (1000000000) >> 0;\n\t\t}\n\t\tt.nsec = nsec;\n\t\treturn t;\n\t};\n\tTime.prototype.Add = function(d) { return this.$val.Add(d); };\n\tTime.ptr.prototype.Sub = function(u) {\n\t\tvar $ptr, d, t, u, x, x$1, x$2, x$3, x$4;\n\t\tt = this;\n\t\td = (x = $mul64((x$1 = (x$2 = t.sec, x$3 = u.sec, new $Int64(x$2.$high - x$3.$high, x$2.$low - x$3.$low)), new Duration(x$1.$high, x$1.$low)), new Duration(0, 1000000000)), x$4 = new Duration(0, (t.nsec - u.nsec >> 0)), new Duration(x.$high + x$4.$high, x.$low + x$4.$low));\n\t\tif ($clone($clone(u, Time).Add(d), Time).Equal($clone(t, Time))) {\n\t\t\treturn d;\n\t\t} else if ($clone(t, Time).Before($clone(u, Time))) {\n\t\t\treturn new Duration(-2147483648, 0);\n\t\t} else {\n\t\t\treturn new Duration(2147483647, 4294967295);\n\t\t}\n\t};\n\tTime.prototype.Sub = function(u) { return this.$val.Sub(u); };\n\tTime.ptr.prototype.AddDate = function(years, months$1, days$1) {\n\t\tvar $ptr, _r$1, _r$2, _r$3, _tuple$1, _tuple$2, day, days$1, hour, min, month, months$1, sec, t, year, years, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; day = $f.day; days$1 = $f.days$1; hour = $f.hour; min = $f.min; month = $f.month; months$1 = $f.months$1; sec = $f.sec; t = $f.t; year = $f.year; years = $f.years; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).Date(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tyear = _tuple$1[0];\n\t\tmonth = _tuple$1[1];\n\t\tday = _tuple$1[2];\n\t\t_r$2 = $clone(t, Time).Clock(); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t_tuple$2 = _r$2;\n\t\thour = _tuple$2[0];\n\t\tmin = _tuple$2[1];\n\t\tsec = _tuple$2[2];\n\t\t_r$3 = Date(year + years >> 0, month + (months$1 >> 0) >> 0, day + days$1 >> 0, hour, min, sec, (t.nsec >> 0), t.loc); /* */ $s = 3; case 3: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$3;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.AddDate }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.day = day; $f.days$1 = days$1; $f.hour = hour; $f.min = min; $f.month = month; $f.months$1 = months$1; $f.sec = sec; $f.t = t; $f.year = year; $f.years = years; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.AddDate = function(years, months$1, days$1) { return this.$val.AddDate(years, months$1, days$1); };\n\tTime.ptr.prototype.date = function(full) {\n\t\tvar $ptr, _r$1, _r$2, _tuple$1, day, full, month, t, yday, year, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple$1 = $f._tuple$1; day = $f.day; full = $f.full; month = $f.month; t = $f.t; yday = $f.yday; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tyear = 0;\n\t\tmonth = 0;\n\t\tday = 0;\n\t\tyday = 0;\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).abs(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_r$2 = absDate(_r$1, full); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$2;\n\t\tyear = _tuple$1[0];\n\t\tmonth = _tuple$1[1];\n\t\tday = _tuple$1[2];\n\t\tyday = _tuple$1[3];\n\t\t$s = -1; return [year, month, day, yday];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.date }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple$1 = _tuple$1; $f.day = day; $f.full = full; $f.month = month; $f.t = t; $f.yday = yday; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.date = function(full) { return this.$val.date(full); };\n\tabsDate = function(abs, full) {\n\t\tvar $ptr, _q, abs, begin, d, day, end, full, month, n, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, yday, year;\n\t\tyear = 0;\n\t\tmonth = 0;\n\t\tday = 0;\n\t\tyday = 0;\n\t\td = $div64(abs, new $Uint64(0, 86400), false);\n\t\tn = $div64(d, new $Uint64(0, 146097), false);\n\t\ty = $mul64(new $Uint64(0, 400), n);\n\t\td = (x = $mul64(new $Uint64(0, 146097), n), new $Uint64(d.$high - x.$high, d.$low - x.$low));\n\t\tn = $div64(d, new $Uint64(0, 36524), false);\n\t\tn = (x$1 = $shiftRightUint64(n, 2), new $Uint64(n.$high - x$1.$high, n.$low - x$1.$low));\n\t\ty = (x$2 = $mul64(new $Uint64(0, 100), n), new $Uint64(y.$high + x$2.$high, y.$low + x$2.$low));\n\t\td = (x$3 = $mul64(new $Uint64(0, 36524), n), new $Uint64(d.$high - x$3.$high, d.$low - x$3.$low));\n\t\tn = $div64(d, new $Uint64(0, 1461), false);\n\t\ty = (x$4 = $mul64(new $Uint64(0, 4), n), new $Uint64(y.$high + x$4.$high, y.$low + x$4.$low));\n\t\td = (x$5 = $mul64(new $Uint64(0, 1461), n), new $Uint64(d.$high - x$5.$high, d.$low - x$5.$low));\n\t\tn = $div64(d, new $Uint64(0, 365), false);\n\t\tn = (x$6 = $shiftRightUint64(n, 2), new $Uint64(n.$high - x$6.$high, n.$low - x$6.$low));\n\t\ty = (x$7 = n, new $Uint64(y.$high + x$7.$high, y.$low + x$7.$low));\n\t\td = (x$8 = $mul64(new $Uint64(0, 365), n), new $Uint64(d.$high - x$8.$high, d.$low - x$8.$low));\n\t\tyear = ((x$9 = (x$10 = new $Int64(y.$high, y.$low), new $Int64(x$10.$high + -69, x$10.$low + 4075721025)), x$9.$low + ((x$9.$high >> 31) * 4294967296)) >> 0);\n\t\tyday = (d.$low >> 0);\n\t\tif (!full) {\n\t\t\treturn [year, month, day, yday];\n\t\t}\n\t\tday = yday;\n\t\tif (isLeap(year)) {\n\t\t\tif (day > 59) {\n\t\t\t\tday = day - (1) >> 0;\n\t\t\t} else if ((day === 59)) {\n\t\t\t\tmonth = 2;\n\t\t\t\tday = 29;\n\t\t\t\treturn [year, month, day, yday];\n\t\t\t}\n\t\t}\n\t\tmonth = ((_q = day / 31, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) >> 0);\n\t\tend = ((x$11 = month + 1 >> 0, ((x$11 < 0 || x$11 >= daysBefore.length) ? $throwRuntimeError(\"index out of range\") : daysBefore[x$11])) >> 0);\n\t\tbegin = 0;\n\t\tif (day >= end) {\n\t\t\tmonth = month + (1) >> 0;\n\t\t\tbegin = end;\n\t\t} else {\n\t\t\tbegin = (((month < 0 || month >= daysBefore.length) ? $throwRuntimeError(\"index out of range\") : daysBefore[month]) >> 0);\n\t\t}\n\t\tmonth = month + (1) >> 0;\n\t\tday = (day - begin >> 0) + 1 >> 0;\n\t\treturn [year, month, day, yday];\n\t};\n\tdaysIn = function(m, year) {\n\t\tvar $ptr, m, x, year;\n\t\tif ((m === 2) && isLeap(year)) {\n\t\t\treturn 29;\n\t\t}\n\t\treturn ((((m < 0 || m >= daysBefore.length) ? $throwRuntimeError(\"index out of range\") : daysBefore[m]) - (x = m - 1 >> 0, ((x < 0 || x >= daysBefore.length) ? $throwRuntimeError(\"index out of range\") : daysBefore[x])) >> 0) >> 0);\n\t};\n\tTime.ptr.prototype.UTC = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\tt.loc = $pkg.UTC;\n\t\treturn t;\n\t};\n\tTime.prototype.UTC = function() { return this.$val.UTC(); };\n\tTime.ptr.prototype.Local = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\tt.loc = $pkg.Local;\n\t\treturn t;\n\t};\n\tTime.prototype.Local = function() { return this.$val.Local(); };\n\tTime.ptr.prototype.In = function(loc) {\n\t\tvar $ptr, loc, t;\n\t\tt = this;\n\t\tif (loc === ptrType$1.nil) {\n\t\t\t$panic(new $String(\"time: missing Location in call to Time.In\"));\n\t\t}\n\t\tt.loc = loc;\n\t\treturn t;\n\t};\n\tTime.prototype.In = function(loc) { return this.$val.In(loc); };\n\tTime.ptr.prototype.Location = function() {\n\t\tvar $ptr, l, t;\n\t\tt = this;\n\t\tl = t.loc;\n\t\tif (l === ptrType$1.nil) {\n\t\t\tl = $pkg.UTC;\n\t\t}\n\t\treturn l;\n\t};\n\tTime.prototype.Location = function() { return this.$val.Location(); };\n\tTime.ptr.prototype.Zone = function() {\n\t\tvar $ptr, _r$1, _tuple$1, name, offset, t, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; name = $f.name; offset = $f.offset; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tname = \"\";\n\t\toffset = 0;\n\t\tt = this;\n\t\t_r$1 = t.loc.lookup((x = t.sec, new $Int64(x.$high + -15, x.$low + 2288912640))); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tname = _tuple$1[0];\n\t\toffset = _tuple$1[1];\n\t\t$s = -1; return [name, offset];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.Zone }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.name = name; $f.offset = offset; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.Zone = function() { return this.$val.Zone(); };\n\tTime.ptr.prototype.Unix = function() {\n\t\tvar $ptr, t, x;\n\t\tt = this;\n\t\treturn (x = t.sec, new $Int64(x.$high + -15, x.$low + 2288912640));\n\t};\n\tTime.prototype.Unix = function() { return this.$val.Unix(); };\n\tTime.ptr.prototype.UnixNano = function() {\n\t\tvar $ptr, t, x, x$1, x$2;\n\t\tt = this;\n\t\treturn (x = $mul64(((x$1 = t.sec, new $Int64(x$1.$high + -15, x$1.$low + 2288912640))), new $Int64(0, 1000000000)), x$2 = new $Int64(0, t.nsec), new $Int64(x.$high + x$2.$high, x.$low + x$2.$low));\n\t};\n\tTime.prototype.UnixNano = function() { return this.$val.UnixNano(); };\n\tTime.ptr.prototype.MarshalBinary = function() {\n\t\tvar $ptr, _q, _r$1, _r$2, _tuple$1, enc, offset, offsetMin, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _q = $f._q; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple$1 = $f._tuple$1; enc = $f.enc; offset = $f.offset; offsetMin = $f.offsetMin; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\toffsetMin = 0;\n\t\t/* */ if ($clone(t, Time).Location() === utcLoc) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if ($clone(t, Time).Location() === utcLoc) { */ case 1:\n\t\t\toffsetMin = -1;\n\t\t\t$s = 3; continue;\n\t\t/* } else { */ case 2:\n\t\t\t_r$1 = $clone(t, Time).Zone(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t_tuple$1 = _r$1;\n\t\t\toffset = _tuple$1[1];\n\t\t\tif (!(((_r$2 = offset % 60, _r$2 === _r$2 ? _r$2 : $throwRuntimeError(\"integer divide by zero\")) === 0))) {\n\t\t\t\t$s = -1; return [sliceType$3.nil, errors.New(\"Time.MarshalBinary: zone offset has fractional minute\")];\n\t\t\t}\n\t\t\toffset = (_q = offset / (60), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\tif (offset < -32768 || (offset === -1) || offset > 32767) {\n\t\t\t\t$s = -1; return [sliceType$3.nil, errors.New(\"Time.MarshalBinary: unexpected zone offset\")];\n\t\t\t}\n\t\t\toffsetMin = (offset << 16 >> 16);\n\t\t/* } */ case 3:\n\t\tenc = new sliceType$3([1, ($shiftRightInt64(t.sec, 56).$low << 24 >>> 24), ($shiftRightInt64(t.sec, 48).$low << 24 >>> 24), ($shiftRightInt64(t.sec, 40).$low << 24 >>> 24), ($shiftRightInt64(t.sec, 32).$low << 24 >>> 24), ($shiftRightInt64(t.sec, 24).$low << 24 >>> 24), ($shiftRightInt64(t.sec, 16).$low << 24 >>> 24), ($shiftRightInt64(t.sec, 8).$low << 24 >>> 24), (t.sec.$low << 24 >>> 24), ((t.nsec >> 24 >> 0) << 24 >>> 24), ((t.nsec >> 16 >> 0) << 24 >>> 24), ((t.nsec >> 8 >> 0) << 24 >>> 24), (t.nsec << 24 >>> 24), ((offsetMin >> 8 << 16 >> 16) << 24 >>> 24), (offsetMin << 24 >>> 24)]);\n\t\t$s = -1; return [enc, $ifaceNil];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalBinary }; } $f.$ptr = $ptr; $f._q = _q; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple$1 = _tuple$1; $f.enc = enc; $f.offset = offset; $f.offsetMin = offsetMin; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.MarshalBinary = function() { return this.$val.MarshalBinary(); };\n\tTime.ptr.prototype.UnmarshalBinary = function(data$1) {\n\t\tvar $ptr, _r$1, _tuple$1, buf, data$1, localoff, offset, t, x, x$1, x$10, x$11, x$12, x$13, x$14, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; buf = $f.buf; data$1 = $f.data$1; localoff = $f.localoff; offset = $f.offset; t = $f.t; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tbuf = data$1;\n\t\tif (buf.$length === 0) {\n\t\t\t$s = -1; return errors.New(\"Time.UnmarshalBinary: no data\");\n\t\t}\n\t\tif (!(((0 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 0]) === 1))) {\n\t\t\t$s = -1; return errors.New(\"Time.UnmarshalBinary: unsupported version\");\n\t\t}\n\t\tif (!((buf.$length === 15))) {\n\t\t\t$s = -1; return errors.New(\"Time.UnmarshalBinary: invalid length\");\n\t\t}\n\t\tbuf = $subslice(buf, 1);\n\t\tt.sec = (x = (x$1 = (x$2 = (x$3 = (x$4 = (x$5 = (x$6 = new $Int64(0, (7 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 7])), x$7 = $shiftLeft64(new $Int64(0, (6 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 6])), 8), new $Int64(x$6.$high | x$7.$high, (x$6.$low | x$7.$low) >>> 0)), x$8 = $shiftLeft64(new $Int64(0, (5 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 5])), 16), new $Int64(x$5.$high | x$8.$high, (x$5.$low | x$8.$low) >>> 0)), x$9 = $shiftLeft64(new $Int64(0, (4 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 4])), 24), new $Int64(x$4.$high | x$9.$high, (x$4.$low | x$9.$low) >>> 0)), x$10 = $shiftLeft64(new $Int64(0, (3 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 3])), 32), new $Int64(x$3.$high | x$10.$high, (x$3.$low | x$10.$low) >>> 0)), x$11 = $shiftLeft64(new $Int64(0, (2 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 2])), 40), new $Int64(x$2.$high | x$11.$high, (x$2.$low | x$11.$low) >>> 0)), x$12 = $shiftLeft64(new $Int64(0, (1 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 1])), 48), new $Int64(x$1.$high | x$12.$high, (x$1.$low | x$12.$low) >>> 0)), x$13 = $shiftLeft64(new $Int64(0, (0 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 0])), 56), new $Int64(x.$high | x$13.$high, (x.$low | x$13.$low) >>> 0));\n\t\tbuf = $subslice(buf, 8);\n\t\tt.nsec = ((((3 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 3]) >> 0) | (((2 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 2]) >> 0) << 8 >> 0)) | (((1 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 1]) >> 0) << 16 >> 0)) | (((0 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 0]) >> 0) << 24 >> 0);\n\t\tbuf = $subslice(buf, 4);\n\t\toffset = $imul(((((1 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 1]) << 16 >> 16) | (((0 >= buf.$length ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + 0]) << 16 >> 16) << 8 << 16 >> 16)) >> 0), 60);\n\t\t/* */ if (offset === -60) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (offset === -60) { */ case 1:\n\t\t\tt.loc = utcLoc;\n\t\t\t$s = 3; continue;\n\t\t/* } else { */ case 2:\n\t\t\t_r$1 = $pkg.Local.lookup((x$14 = t.sec, new $Int64(x$14.$high + -15, x$14.$low + 2288912640))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t_tuple$1 = _r$1;\n\t\t\tlocaloff = _tuple$1[1];\n\t\t\tif (offset === localoff) {\n\t\t\t\tt.loc = $pkg.Local;\n\t\t\t} else {\n\t\t\t\tt.loc = FixedZone(\"\", offset);\n\t\t\t}\n\t\t/* } */ case 3:\n\t\t$s = -1; return $ifaceNil;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalBinary }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.buf = buf; $f.data$1 = data$1; $f.localoff = localoff; $f.offset = offset; $f.t = t; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.UnmarshalBinary = function(data$1) { return this.$val.UnmarshalBinary(data$1); };\n\tTime.ptr.prototype.GobEncode = function() {\n\t\tvar $ptr, _r$1, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).MarshalBinary(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.GobEncode }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.GobEncode = function() { return this.$val.GobEncode(); };\n\tTime.ptr.prototype.GobDecode = function(data$1) {\n\t\tvar $ptr, _r$1, data$1, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; data$1 = $f.data$1; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = t.UnmarshalBinary(data$1); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.GobDecode }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.data$1 = data$1; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.GobDecode = function(data$1) { return this.$val.GobDecode(data$1); };\n\tTime.ptr.prototype.MarshalJSON = function() {\n\t\tvar $ptr, _r$1, _r$2, b, t, y, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; b = $f.b; t = $f.t; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\ty = _r$1;\n\t\tif (y < 0 || y >= 10000) {\n\t\t\t$s = -1; return [sliceType$3.nil, errors.New(\"Time.MarshalJSON: year outside of range [0,9999]\")];\n\t\t}\n\t\tb = $makeSlice(sliceType$3, 0, 37);\n\t\tb = $append(b, 34);\n\t\t_r$2 = $clone(t, Time).AppendFormat(b, \"2006-01-02T15:04:05.999999999Z07:00\"); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\tb = _r$2;\n\t\tb = $append(b, 34);\n\t\t$s = -1; return [b, $ifaceNil];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalJSON }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.b = b; $f.t = t; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.MarshalJSON = function() { return this.$val.MarshalJSON(); };\n\tTime.ptr.prototype.UnmarshalJSON = function(data$1) {\n\t\tvar $ptr, _r$1, _tuple$1, data$1, err, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; data$1 = $f.data$1; err = $f.err; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\terr = $ifaceNil;\n\t\t_r$1 = Parse(\"\\\"2006-01-02T15:04:05Z07:00\\\"\", $bytesToString(data$1)); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tTime.copy(t, _tuple$1[0]);\n\t\terr = _tuple$1[1];\n\t\t$s = -1; return err;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalJSON }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.data$1 = data$1; $f.err = err; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.UnmarshalJSON = function(data$1) { return this.$val.UnmarshalJSON(data$1); };\n\tTime.ptr.prototype.MarshalText = function() {\n\t\tvar $ptr, _r$1, _r$2, b, t, y, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; b = $f.b; t = $f.t; y = $f.y; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t_r$1 = $clone(t, Time).Year(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\ty = _r$1;\n\t\tif (y < 0 || y >= 10000) {\n\t\t\t$s = -1; return [sliceType$3.nil, errors.New(\"Time.MarshalText: year outside of range [0,9999]\")];\n\t\t}\n\t\tb = $makeSlice(sliceType$3, 0, 35);\n\t\t_r$2 = $clone(t, Time).AppendFormat(b, \"2006-01-02T15:04:05.999999999Z07:00\"); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t$s = -1; return [_r$2, $ifaceNil];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.MarshalText }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.b = b; $f.t = t; $f.y = y; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.MarshalText = function() { return this.$val.MarshalText(); };\n\tTime.ptr.prototype.UnmarshalText = function(data$1) {\n\t\tvar $ptr, _r$1, _tuple$1, data$1, err, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _tuple$1 = $f._tuple$1; data$1 = $f.data$1; err = $f.err; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\terr = $ifaceNil;\n\t\t_r$1 = Parse(\"2006-01-02T15:04:05Z07:00\", $bytesToString(data$1)); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$1 = _r$1;\n\t\tTime.copy(t, _tuple$1[0]);\n\t\terr = _tuple$1[1];\n\t\t$s = -1; return err;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Time.ptr.prototype.UnmarshalText }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._tuple$1 = _tuple$1; $f.data$1 = data$1; $f.err = err; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tTime.prototype.UnmarshalText = function(data$1) { return this.$val.UnmarshalText(data$1); };\n\tUnix = function(sec, nsec) {\n\t\tvar $ptr, n, nsec, sec, x, x$1, x$2, x$3;\n\t\tif ((nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0)) || (nsec.$high > 0 || (nsec.$high === 0 && nsec.$low >= 1000000000))) {\n\t\t\tn = $div64(nsec, new $Int64(0, 1000000000), false);\n\t\t\tsec = (x = n, new $Int64(sec.$high + x.$high, sec.$low + x.$low));\n\t\t\tnsec = (x$1 = $mul64(n, new $Int64(0, 1000000000)), new $Int64(nsec.$high - x$1.$high, nsec.$low - x$1.$low));\n\t\t\tif ((nsec.$high < 0 || (nsec.$high === 0 && nsec.$low < 0))) {\n\t\t\t\tnsec = (x$2 = new $Int64(0, 1000000000), new $Int64(nsec.$high + x$2.$high, nsec.$low + x$2.$low));\n\t\t\t\tsec = (x$3 = new $Int64(0, 1), new $Int64(sec.$high - x$3.$high, sec.$low - x$3.$low));\n\t\t\t}\n\t\t}\n\t\treturn new Time.ptr(new $Int64(sec.$high + 14, sec.$low + 2006054656), ((nsec.$low + ((nsec.$high >> 31) * 4294967296)) >> 0), $pkg.Local);\n\t};\n\t$pkg.Unix = Unix;\n\tisLeap = function(year) {\n\t\tvar $ptr, _r$1, _r$2, _r$3, year;\n\t\treturn ((_r$1 = year % 4, _r$1 === _r$1 ? _r$1 : $throwRuntimeError(\"integer divide by zero\")) === 0) && (!(((_r$2 = year % 100, _r$2 === _r$2 ? _r$2 : $throwRuntimeError(\"integer divide by zero\")) === 0)) || ((_r$3 = year % 400, _r$3 === _r$3 ? _r$3 : $throwRuntimeError(\"integer divide by zero\")) === 0));\n\t};\n\tnorm = function(hi, lo, base) {\n\t\tvar $ptr, _q, _q$1, _tmp, _tmp$1, base, hi, lo, n, n$1, nhi, nlo;\n\t\tnhi = 0;\n\t\tnlo = 0;\n\t\tif (lo < 0) {\n\t\t\tn = (_q = ((-lo - 1 >> 0)) / base, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) + 1 >> 0;\n\t\t\thi = hi - (n) >> 0;\n\t\t\tlo = lo + (($imul(n, base))) >> 0;\n\t\t}\n\t\tif (lo >= base) {\n\t\t\tn$1 = (_q$1 = lo / base, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\thi = hi + (n$1) >> 0;\n\t\t\tlo = lo - (($imul(n$1, base))) >> 0;\n\t\t}\n\t\t_tmp = hi;\n\t\t_tmp$1 = lo;\n\t\tnhi = _tmp;\n\t\tnlo = _tmp$1;\n\t\treturn [nhi, nlo];\n\t};\n\tDate = function(year, month, day, hour, min, sec, nsec, loc) {\n\t\tvar $ptr, _r$1, _r$2, _r$3, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, abs, d, day, end, hour, loc, m, min, month, n, nsec, offset, sec, start, unix, utc, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y, year, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; abs = $f.abs; d = $f.d; day = $f.day; end = $f.end; hour = $f.hour; loc = $f.loc; m = $f.m; min = $f.min; month = $f.month; n = $f.n; nsec = $f.nsec; offset = $f.offset; sec = $f.sec; start = $f.start; unix = $f.unix; utc = $f.utc; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$13 = $f.x$13; x$14 = $f.x$14; x$15 = $f.x$15; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; y = $f.y; year = $f.year; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tif (loc === ptrType$1.nil) {\n\t\t\t$panic(new $String(\"time: missing Location in call to Date\"));\n\t\t}\n\t\tm = (month >> 0) - 1 >> 0;\n\t\t_tuple$1 = norm(year, m, 12);\n\t\tyear = _tuple$1[0];\n\t\tm = _tuple$1[1];\n\t\tmonth = (m >> 0) + 1 >> 0;\n\t\t_tuple$2 = norm(sec, nsec, 1000000000);\n\t\tsec = _tuple$2[0];\n\t\tnsec = _tuple$2[1];\n\t\t_tuple$3 = norm(min, sec, 60);\n\t\tmin = _tuple$3[0];\n\t\tsec = _tuple$3[1];\n\t\t_tuple$4 = norm(hour, min, 60);\n\t\thour = _tuple$4[0];\n\t\tmin = _tuple$4[1];\n\t\t_tuple$5 = norm(day, hour, 24);\n\t\tday = _tuple$5[0];\n\t\thour = _tuple$5[1];\n\t\ty = (x = (x$1 = new $Int64(0, year), new $Int64(x$1.$high - -69, x$1.$low - 4075721025)), new $Uint64(x.$high, x.$low));\n\t\tn = $div64(y, new $Uint64(0, 400), false);\n\t\ty = (x$2 = $mul64(new $Uint64(0, 400), n), new $Uint64(y.$high - x$2.$high, y.$low - x$2.$low));\n\t\td = $mul64(new $Uint64(0, 146097), n);\n\t\tn = $div64(y, new $Uint64(0, 100), false);\n\t\ty = (x$3 = $mul64(new $Uint64(0, 100), n), new $Uint64(y.$high - x$3.$high, y.$low - x$3.$low));\n\t\td = (x$4 = $mul64(new $Uint64(0, 36524), n), new $Uint64(d.$high + x$4.$high, d.$low + x$4.$low));\n\t\tn = $div64(y, new $Uint64(0, 4), false);\n\t\ty = (x$5 = $mul64(new $Uint64(0, 4), n), new $Uint64(y.$high - x$5.$high, y.$low - x$5.$low));\n\t\td = (x$6 = $mul64(new $Uint64(0, 1461), n), new $Uint64(d.$high + x$6.$high, d.$low + x$6.$low));\n\t\tn = y;\n\t\td = (x$7 = $mul64(new $Uint64(0, 365), n), new $Uint64(d.$high + x$7.$high, d.$low + x$7.$low));\n\t\td = (x$8 = new $Uint64(0, (x$9 = month - 1 >> 0, ((x$9 < 0 || x$9 >= daysBefore.length) ? $throwRuntimeError(\"index out of range\") : daysBefore[x$9]))), new $Uint64(d.$high + x$8.$high, d.$low + x$8.$low));\n\t\tif (isLeap(year) && month >= 3) {\n\t\t\td = (x$10 = new $Uint64(0, 1), new $Uint64(d.$high + x$10.$high, d.$low + x$10.$low));\n\t\t}\n\t\td = (x$11 = new $Uint64(0, (day - 1 >> 0)), new $Uint64(d.$high + x$11.$high, d.$low + x$11.$low));\n\t\tabs = $mul64(d, new $Uint64(0, 86400));\n\t\tabs = (x$12 = new $Uint64(0, ((($imul(hour, 3600)) + ($imul(min, 60)) >> 0) + sec >> 0)), new $Uint64(abs.$high + x$12.$high, abs.$low + x$12.$low));\n\t\tunix = (x$13 = new $Int64(abs.$high, abs.$low), new $Int64(x$13.$high + -2147483647, x$13.$low + 3844486912));\n\t\t_r$1 = loc.lookup(unix); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple$6 = _r$1;\n\t\toffset = _tuple$6[1];\n\t\tstart = _tuple$6[3];\n\t\tend = _tuple$6[4];\n\t\t/* */ if (!((offset === 0))) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (!((offset === 0))) { */ case 2:\n\t\t\t\tutc = (x$14 = new $Int64(0, offset), new $Int64(unix.$high - x$14.$high, unix.$low - x$14.$low));\n\t\t\t\t/* */ if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low))) { $s = 5; continue; }\n\t\t\t\t/* */ if ((utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { $s = 6; continue; }\n\t\t\t\t/* */ $s = 7; continue;\n\t\t\t\t/* if ((utc.$high < start.$high || (utc.$high === start.$high && utc.$low < start.$low))) { */ case 5:\n\t\t\t\t\t_r$2 = loc.lookup(new $Int64(start.$high - 0, start.$low - 1)); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t\t_tuple$7 = _r$2;\n\t\t\t\t\toffset = _tuple$7[1];\n\t\t\t\t\t$s = 7; continue;\n\t\t\t\t/* } else if ((utc.$high > end.$high || (utc.$high === end.$high && utc.$low >= end.$low))) { */ case 6:\n\t\t\t\t\t_r$3 = loc.lookup(end); /* */ $s = 9; case 9: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t\t\t_tuple$8 = _r$3;\n\t\t\t\t\toffset = _tuple$8[1];\n\t\t\t\t/* } */ case 7:\n\t\t\tcase 4:\n\t\t\tunix = (x$15 = new $Int64(0, offset), new $Int64(unix.$high - x$15.$high, unix.$low - x$15.$low));\n\t\t/* } */ case 3:\n\t\t$s = -1; return new Time.ptr(new $Int64(unix.$high + 14, unix.$low + 2006054656), (nsec >> 0), loc);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Date }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f.abs = abs; $f.d = d; $f.day = day; $f.end = end; $f.hour = hour; $f.loc = loc; $f.m = m; $f.min = min; $f.month = month; $f.n = n; $f.nsec = nsec; $f.offset = offset; $f.sec = sec; $f.start = start; $f.unix = unix; $f.utc = utc; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$13 = x$13; $f.x$14 = x$14; $f.x$15 = x$15; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.y = y; $f.year = year; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.Date = Date;\n\tTime.ptr.prototype.Truncate = function(d) {\n\t\tvar $ptr, _tuple$1, d, r, t;\n\t\tt = this;\n\t\tif ((d.$high < 0 || (d.$high === 0 && d.$low <= 0))) {\n\t\t\treturn t;\n\t\t}\n\t\t_tuple$1 = div($clone(t, Time), d);\n\t\tr = _tuple$1[1];\n\t\treturn $clone(t, Time).Add(new Duration(-r.$high, -r.$low));\n\t};\n\tTime.prototype.Truncate = function(d) { return this.$val.Truncate(d); };\n\tTime.ptr.prototype.Round = function(d) {\n\t\tvar $ptr, _tuple$1, d, r, t, x;\n\t\tt = this;\n\t\tif ((d.$high < 0 || (d.$high === 0 && d.$low <= 0))) {\n\t\t\treturn t;\n\t\t}\n\t\t_tuple$1 = div($clone(t, Time), d);\n\t\tr = _tuple$1[1];\n\t\tif ((x = new Duration(r.$high + r.$high, r.$low + r.$low), (x.$high < d.$high || (x.$high === d.$high && x.$low < d.$low)))) {\n\t\t\treturn $clone(t, Time).Add(new Duration(-r.$high, -r.$low));\n\t\t}\n\t\treturn $clone(t, Time).Add(new Duration(d.$high - r.$high, d.$low - r.$low));\n\t};\n\tTime.prototype.Round = function(d) { return this.$val.Round(d); };\n\tdiv = function(t, d) {\n\t\tvar $ptr, _q, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, d, d0, d1, d1$1, neg, nsec, qmod2, r, sec, t, tmp, u0, u0x, u1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;\n\t\tqmod2 = 0;\n\t\tr = new Duration(0, 0);\n\t\tneg = false;\n\t\tnsec = t.nsec;\n\t\tif ((x = t.sec, (x.$high < 0 || (x.$high === 0 && x.$low < 0)))) {\n\t\t\tneg = true;\n\t\t\tt.sec = (x$1 = t.sec, new $Int64(-x$1.$high, -x$1.$low));\n\t\t\tnsec = -nsec;\n\t\t\tif (nsec < 0) {\n\t\t\t\tnsec = nsec + (1000000000) >> 0;\n\t\t\t\tt.sec = (x$2 = t.sec, x$3 = new $Int64(0, 1), new $Int64(x$2.$high - x$3.$high, x$2.$low - x$3.$low));\n\t\t\t}\n\t\t}\n\t\tif ((d.$high < 0 || (d.$high === 0 && d.$low < 1000000000)) && (x$4 = $div64(new Duration(0, 1000000000), (new Duration(d.$high + d.$high, d.$low + d.$low)), true), (x$4.$high === 0 && x$4.$low === 0))) {\n\t\t\tqmod2 = ((_q = nsec / ((d.$low + ((d.$high >> 31) * 4294967296)) >> 0), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) >> 0) & 1;\n\t\t\tr = new Duration(0, (_r$1 = nsec % ((d.$low + ((d.$high >> 31) * 4294967296)) >> 0), _r$1 === _r$1 ? _r$1 : $throwRuntimeError(\"integer divide by zero\")));\n\t\t} else if ((x$5 = $div64(d, new Duration(0, 1000000000), true), (x$5.$high === 0 && x$5.$low === 0))) {\n\t\t\td1 = (x$6 = $div64(d, new Duration(0, 1000000000), false), new $Int64(x$6.$high, x$6.$low));\n\t\t\tqmod2 = ((x$7 = $div64(t.sec, d1, false), x$7.$low + ((x$7.$high >> 31) * 4294967296)) >> 0) & 1;\n\t\t\tr = (x$8 = $mul64((x$9 = $div64(t.sec, d1, true), new Duration(x$9.$high, x$9.$low)), new Duration(0, 1000000000)), x$10 = new Duration(0, nsec), new Duration(x$8.$high + x$10.$high, x$8.$low + x$10.$low));\n\t\t} else {\n\t\t\tsec = (x$11 = t.sec, new $Uint64(x$11.$high, x$11.$low));\n\t\t\ttmp = $mul64(($shiftRightUint64(sec, 32)), new $Uint64(0, 1000000000));\n\t\t\tu1 = $shiftRightUint64(tmp, 32);\n\t\t\tu0 = $shiftLeft64(tmp, 32);\n\t\t\ttmp = $mul64((new $Uint64(sec.$high & 0, (sec.$low & 4294967295) >>> 0)), new $Uint64(0, 1000000000));\n\t\t\t_tmp = u0;\n\t\t\t_tmp$1 = new $Uint64(u0.$high + tmp.$high, u0.$low + tmp.$low);\n\t\t\tu0x = _tmp;\n\t\t\tu0 = _tmp$1;\n\t\t\tif ((u0.$high < u0x.$high || (u0.$high === u0x.$high && u0.$low < u0x.$low))) {\n\t\t\t\tu1 = (x$12 = new $Uint64(0, 1), new $Uint64(u1.$high + x$12.$high, u1.$low + x$12.$low));\n\t\t\t}\n\t\t\t_tmp$2 = u0;\n\t\t\t_tmp$3 = (x$13 = new $Uint64(0, nsec), new $Uint64(u0.$high + x$13.$high, u0.$low + x$13.$low));\n\t\t\tu0x = _tmp$2;\n\t\t\tu0 = _tmp$3;\n\t\t\tif ((u0.$high < u0x.$high || (u0.$high === u0x.$high && u0.$low < u0x.$low))) {\n\t\t\t\tu1 = (x$14 = new $Uint64(0, 1), new $Uint64(u1.$high + x$14.$high, u1.$low + x$14.$low));\n\t\t\t}\n\t\t\td1$1 = new $Uint64(d.$high, d.$low);\n\t\t\twhile (true) {\n\t\t\t\tif (!(!((x$15 = $shiftRightUint64(d1$1, 63), (x$15.$high === 0 && x$15.$low === 1))))) { break; }\n\t\t\t\td1$1 = $shiftLeft64(d1$1, (1));\n\t\t\t}\n\t\t\td0 = new $Uint64(0, 0);\n\t\t\twhile (true) {\n\t\t\t\tqmod2 = 0;\n\t\t\t\tif ((u1.$high > d1$1.$high || (u1.$high === d1$1.$high && u1.$low > d1$1.$low)) || (u1.$high === d1$1.$high && u1.$low === d1$1.$low) && (u0.$high > d0.$high || (u0.$high === d0.$high && u0.$low >= d0.$low))) {\n\t\t\t\t\tqmod2 = 1;\n\t\t\t\t\t_tmp$4 = u0;\n\t\t\t\t\t_tmp$5 = new $Uint64(u0.$high - d0.$high, u0.$low - d0.$low);\n\t\t\t\t\tu0x = _tmp$4;\n\t\t\t\t\tu0 = _tmp$5;\n\t\t\t\t\tif ((u0.$high > u0x.$high || (u0.$high === u0x.$high && u0.$low > u0x.$low))) {\n\t\t\t\t\t\tu1 = (x$16 = new $Uint64(0, 1), new $Uint64(u1.$high - x$16.$high, u1.$low - x$16.$low));\n\t\t\t\t\t}\n\t\t\t\t\tu1 = (x$17 = d1$1, new $Uint64(u1.$high - x$17.$high, u1.$low - x$17.$low));\n\t\t\t\t}\n\t\t\t\tif ((d1$1.$high === 0 && d1$1.$low === 0) && (x$18 = new $Uint64(d.$high, d.$low), (d0.$high === x$18.$high && d0.$low === x$18.$low))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td0 = $shiftRightUint64(d0, (1));\n\t\t\t\td0 = (x$19 = $shiftLeft64((new $Uint64(d1$1.$high & 0, (d1$1.$low & 1) >>> 0)), 63), new $Uint64(d0.$high | x$19.$high, (d0.$low | x$19.$low) >>> 0));\n\t\t\t\td1$1 = $shiftRightUint64(d1$1, (1));\n\t\t\t}\n\t\t\tr = new Duration(u0.$high, u0.$low);\n\t\t}\n\t\tif (neg && !((r.$high === 0 && r.$low === 0))) {\n\t\t\tqmod2 = (qmod2 ^ (1)) >> 0;\n\t\t\tr = new Duration(d.$high - r.$high, d.$low - r.$low);\n\t\t}\n\t\treturn [qmod2, r];\n\t};\n\tLocation.ptr.prototype.get = function() {\n\t\tvar $ptr, l, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; l = $f.l; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tl = this;\n\t\tif (l === ptrType$1.nil) {\n\t\t\t$s = -1; return utcLoc;\n\t\t}\n\t\t/* */ if (l === localLoc) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (l === localLoc) { */ case 1:\n\t\t\t$r = localOnce.Do(initLocal); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* } */ case 2:\n\t\t$s = -1; return l;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.get }; } $f.$ptr = $ptr; $f.l = l; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tLocation.prototype.get = function() { return this.$val.get(); };\n\tLocation.ptr.prototype.String = function() {\n\t\tvar $ptr, _r$1, l, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; l = $f.l; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tl = this;\n\t\t_r$1 = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1.name;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.String }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f.l = l; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tLocation.prototype.String = function() { return this.$val.String(); };\n\tFixedZone = function(name, offset) {\n\t\tvar $ptr, l, name, offset, x;\n\t\tl = new Location.ptr(name, new sliceType([new zone.ptr(name, offset, false)]), new sliceType$1([new zoneTrans.ptr(new $Int64(-2147483648, 0), 0, false, false)]), new $Int64(-2147483648, 0), new $Int64(2147483647, 4294967295), ptrType.nil);\n\t\tl.cacheZone = (x = l.zone, (0 >= x.$length ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + 0]));\n\t\treturn l;\n\t};\n\t$pkg.FixedZone = FixedZone;\n\tLocation.ptr.prototype.lookup = function(sec) {\n\t\tvar $ptr, _q, _r$1, end, hi, isDST, l, lim, lo, m, name, offset, sec, start, tx, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, zone$1, zone$2, zone$3, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _q = $f._q; _r$1 = $f._r$1; end = $f.end; hi = $f.hi; isDST = $f.isDST; l = $f.l; lim = $f.lim; lo = $f.lo; m = $f.m; name = $f.name; offset = $f.offset; sec = $f.sec; start = $f.start; tx = $f.tx; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; zone$1 = $f.zone$1; zone$2 = $f.zone$2; zone$3 = $f.zone$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tname = \"\";\n\t\toffset = 0;\n\t\tisDST = false;\n\t\tstart = new $Int64(0, 0);\n\t\tend = new $Int64(0, 0);\n\t\tl = this;\n\t\t_r$1 = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tl = _r$1;\n\t\tif (l.zone.$length === 0) {\n\t\t\tname = \"UTC\";\n\t\t\toffset = 0;\n\t\t\tisDST = false;\n\t\t\tstart = new $Int64(-2147483648, 0);\n\t\t\tend = new $Int64(2147483647, 4294967295);\n\t\t\t$s = -1; return [name, offset, isDST, start, end];\n\t\t}\n\t\tzone$1 = l.cacheZone;\n\t\tif (!(zone$1 === ptrType.nil) && (x = l.cacheStart, (x.$high < sec.$high || (x.$high === sec.$high && x.$low <= sec.$low))) && (x$1 = l.cacheEnd, (sec.$high < x$1.$high || (sec.$high === x$1.$high && sec.$low < x$1.$low)))) {\n\t\t\tname = zone$1.name;\n\t\t\toffset = zone$1.offset;\n\t\t\tisDST = zone$1.isDST;\n\t\t\tstart = l.cacheStart;\n\t\t\tend = l.cacheEnd;\n\t\t\t$s = -1; return [name, offset, isDST, start, end];\n\t\t}\n\t\tif ((l.tx.$length === 0) || (x$2 = (x$3 = l.tx, (0 >= x$3.$length ? $throwRuntimeError(\"index out of range\") : x$3.$array[x$3.$offset + 0])).when, (sec.$high < x$2.$high || (sec.$high === x$2.$high && sec.$low < x$2.$low)))) {\n\t\t\tzone$2 = (x$4 = l.zone, x$5 = l.lookupFirstZone(), ((x$5 < 0 || x$5 >= x$4.$length) ? $throwRuntimeError(\"index out of range\") : x$4.$array[x$4.$offset + x$5]));\n\t\t\tname = zone$2.name;\n\t\t\toffset = zone$2.offset;\n\t\t\tisDST = zone$2.isDST;\n\t\t\tstart = new $Int64(-2147483648, 0);\n\t\t\tif (l.tx.$length > 0) {\n\t\t\t\tend = (x$6 = l.tx, (0 >= x$6.$length ? $throwRuntimeError(\"index out of range\") : x$6.$array[x$6.$offset + 0])).when;\n\t\t\t} else {\n\t\t\t\tend = new $Int64(2147483647, 4294967295);\n\t\t\t}\n\t\t\t$s = -1; return [name, offset, isDST, start, end];\n\t\t}\n\t\ttx = l.tx;\n\t\tend = new $Int64(2147483647, 4294967295);\n\t\tlo = 0;\n\t\thi = tx.$length;\n\t\twhile (true) {\n\t\t\tif (!((hi - lo >> 0) > 1)) { break; }\n\t\t\tm = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) >> 0;\n\t\t\tlim = ((m < 0 || m >= tx.$length) ? $throwRuntimeError(\"index out of range\") : tx.$array[tx.$offset + m]).when;\n\t\t\tif ((sec.$high < lim.$high || (sec.$high === lim.$high && sec.$low < lim.$low))) {\n\t\t\t\tend = lim;\n\t\t\t\thi = m;\n\t\t\t} else {\n\t\t\t\tlo = m;\n\t\t\t}\n\t\t}\n\t\tzone$3 = (x$7 = l.zone, x$8 = ((lo < 0 || lo >= tx.$length) ? $throwRuntimeError(\"index out of range\") : tx.$array[tx.$offset + lo]).index, ((x$8 < 0 || x$8 >= x$7.$length) ? $throwRuntimeError(\"index out of range\") : x$7.$array[x$7.$offset + x$8]));\n\t\tname = zone$3.name;\n\t\toffset = zone$3.offset;\n\t\tisDST = zone$3.isDST;\n\t\tstart = ((lo < 0 || lo >= tx.$length) ? $throwRuntimeError(\"index out of range\") : tx.$array[tx.$offset + lo]).when;\n\t\t$s = -1; return [name, offset, isDST, start, end];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.lookup }; } $f.$ptr = $ptr; $f._q = _q; $f._r$1 = _r$1; $f.end = end; $f.hi = hi; $f.isDST = isDST; $f.l = l; $f.lim = lim; $f.lo = lo; $f.m = m; $f.name = name; $f.offset = offset; $f.sec = sec; $f.start = start; $f.tx = tx; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.zone$3 = zone$3; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tLocation.prototype.lookup = function(sec) { return this.$val.lookup(sec); };\n\tLocation.ptr.prototype.lookupFirstZone = function() {\n\t\tvar $ptr, _i, _ref, l, x, x$1, x$2, x$3, x$4, x$5, zi, zi$1;\n\t\tl = this;\n\t\tif (!l.firstZoneUsed()) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (l.tx.$length > 0 && (x = l.zone, x$1 = (x$2 = l.tx, (0 >= x$2.$length ? $throwRuntimeError(\"index out of range\") : x$2.$array[x$2.$offset + 0])).index, ((x$1 < 0 || x$1 >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + x$1])).isDST) {\n\t\t\tzi = ((x$3 = l.tx, (0 >= x$3.$length ? $throwRuntimeError(\"index out of range\") : x$3.$array[x$3.$offset + 0])).index >> 0) - 1 >> 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(zi >= 0)) { break; }\n\t\t\t\tif (!(x$4 = l.zone, ((zi < 0 || zi >= x$4.$length) ? $throwRuntimeError(\"index out of range\") : x$4.$array[x$4.$offset + zi])).isDST) {\n\t\t\t\t\treturn zi;\n\t\t\t\t}\n\t\t\t\tzi = zi - (1) >> 0;\n\t\t\t}\n\t\t}\n\t\t_ref = l.zone;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\tzi$1 = _i;\n\t\t\tif (!(x$5 = l.zone, ((zi$1 < 0 || zi$1 >= x$5.$length) ? $throwRuntimeError(\"index out of range\") : x$5.$array[x$5.$offset + zi$1])).isDST) {\n\t\t\t\treturn zi$1;\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\treturn 0;\n\t};\n\tLocation.prototype.lookupFirstZone = function() { return this.$val.lookupFirstZone(); };\n\tLocation.ptr.prototype.firstZoneUsed = function() {\n\t\tvar $ptr, _i, _ref, l, tx;\n\t\tl = this;\n\t\t_ref = l.tx;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ttx = $clone(((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]), zoneTrans);\n\t\t\tif (tx.index === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\treturn false;\n\t};\n\tLocation.prototype.firstZoneUsed = function() { return this.$val.firstZoneUsed(); };\n\tLocation.ptr.prototype.lookupName = function(name, unix) {\n\t\tvar $ptr, _i, _i$1, _r$1, _r$2, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple$1, i, i$1, isDST, isDST$1, l, nam, name, offset, offset$1, ok, unix, x, x$1, x$2, zone$1, zone$2, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _i$1 = $f._i$1; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple$1 = $f._tuple$1; i = $f.i; i$1 = $f.i$1; isDST = $f.isDST; isDST$1 = $f.isDST$1; l = $f.l; nam = $f.nam; name = $f.name; offset = $f.offset; offset$1 = $f.offset$1; ok = $f.ok; unix = $f.unix; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; zone$1 = $f.zone$1; zone$2 = $f.zone$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\toffset = 0;\n\t\tisDST = false;\n\t\tok = false;\n\t\tl = this;\n\t\t_r$1 = l.get(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tl = _r$1;\n\t\t_ref = l.zone;\n\t\t_i = 0;\n\t\t/* while (true) { */ case 2:\n\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }\n\t\t\ti = _i;\n\t\t\tzone$1 = (x = l.zone, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\t/* */ if (zone$1.name === name) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if (zone$1.name === name) { */ case 4:\n\t\t\t\t_r$2 = l.lookup((x$1 = new $Int64(0, zone$1.offset), new $Int64(unix.$high - x$1.$high, unix.$low - x$1.$low))); /* */ $s = 6; case 6: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_tuple$1 = _r$2;\n\t\t\t\tnam = _tuple$1[0];\n\t\t\t\toffset$1 = _tuple$1[1];\n\t\t\t\tisDST$1 = _tuple$1[2];\n\t\t\t\tif (nam === zone$1.name) {\n\t\t\t\t\t_tmp = offset$1;\n\t\t\t\t\t_tmp$1 = isDST$1;\n\t\t\t\t\t_tmp$2 = true;\n\t\t\t\t\toffset = _tmp;\n\t\t\t\t\tisDST = _tmp$1;\n\t\t\t\t\tok = _tmp$2;\n\t\t\t\t\t$s = -1; return [offset, isDST, ok];\n\t\t\t\t}\n\t\t\t/* } */ case 5:\n\t\t\t_i++;\n\t\t/* } */ $s = 2; continue; case 3:\n\t\t_ref$1 = l.zone;\n\t\t_i$1 = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\ti$1 = _i$1;\n\t\t\tzone$2 = (x$2 = l.zone, ((i$1 < 0 || i$1 >= x$2.$length) ? $throwRuntimeError(\"index out of range\") : x$2.$array[x$2.$offset + i$1]));\n\t\t\tif (zone$2.name === name) {\n\t\t\t\t_tmp$3 = zone$2.offset;\n\t\t\t\t_tmp$4 = zone$2.isDST;\n\t\t\t\t_tmp$5 = true;\n\t\t\t\toffset = _tmp$3;\n\t\t\t\tisDST = _tmp$4;\n\t\t\t\tok = _tmp$5;\n\t\t\t\t$s = -1; return [offset, isDST, ok];\n\t\t\t}\n\t\t\t_i$1++;\n\t\t}\n\t\t$s = -1; return [offset, isDST, ok];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Location.ptr.prototype.lookupName }; } $f.$ptr = $ptr; $f._i = _i; $f._i$1 = _i$1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple$1 = _tuple$1; $f.i = i; $f.i$1 = i$1; $f.isDST = isDST; $f.isDST$1 = isDST$1; $f.l = l; $f.nam = nam; $f.name = name; $f.offset = offset; $f.offset$1 = offset$1; $f.ok = ok; $f.unix = unix; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.zone$1 = zone$1; $f.zone$2 = zone$2; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tLocation.prototype.lookupName = function(name, unix) { return this.$val.lookupName(name, unix); };\n\tptrType$3.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tTime.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Format\", name: \"Format\", pkg: \"\", typ: $funcType([$String], [$String], false)}, {prop: \"AppendFormat\", name: \"AppendFormat\", pkg: \"\", typ: $funcType([sliceType$3, $String], [sliceType$3], false)}, {prop: \"After\", name: \"After\", pkg: \"\", typ: $funcType([Time], [$Bool], false)}, {prop: \"Before\", name: \"Before\", pkg: \"\", typ: $funcType([Time], [$Bool], false)}, {prop: \"Equal\", name: \"Equal\", pkg: \"\", typ: $funcType([Time], [$Bool], false)}, {prop: \"IsZero\", name: \"IsZero\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"abs\", name: \"abs\", pkg: \"time\", typ: $funcType([], [$Uint64], false)}, {prop: \"locabs\", name: \"locabs\", pkg: \"time\", typ: $funcType([], [$String, $Int, $Uint64], false)}, {prop: \"Date\", name: \"Date\", pkg: \"\", typ: $funcType([], [$Int, Month, $Int], false)}, {prop: \"Year\", name: \"Year\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Month\", name: \"Month\", pkg: \"\", typ: $funcType([], [Month], false)}, {prop: \"Day\", name: \"Day\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Weekday\", name: \"Weekday\", pkg: \"\", typ: $funcType([], [Weekday], false)}, {prop: \"ISOWeek\", name: \"ISOWeek\", pkg: \"\", typ: $funcType([], [$Int, $Int], false)}, {prop: \"Clock\", name: \"Clock\", pkg: \"\", typ: $funcType([], [$Int, $Int, $Int], false)}, {prop: \"Hour\", name: \"Hour\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Minute\", name: \"Minute\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Second\", name: \"Second\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Nanosecond\", name: \"Nanosecond\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"YearDay\", name: \"YearDay\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Add\", name: \"Add\", pkg: \"\", typ: $funcType([Duration], [Time], false)}, {prop: \"Sub\", name: \"Sub\", pkg: \"\", typ: $funcType([Time], [Duration], false)}, {prop: \"AddDate\", name: \"AddDate\", pkg: \"\", typ: $funcType([$Int, $Int, $Int], [Time], false)}, {prop: \"date\", name: \"date\", pkg: \"time\", typ: $funcType([$Bool], [$Int, Month, $Int, $Int], false)}, {prop: \"UTC\", name: \"UTC\", pkg: \"\", typ: $funcType([], [Time], false)}, {prop: \"Local\", name: \"Local\", pkg: \"\", typ: $funcType([], [Time], false)}, {prop: \"In\", name: \"In\", pkg: \"\", typ: $funcType([ptrType$1], [Time], false)}, {prop: \"Location\", name: \"Location\", pkg: \"\", typ: $funcType([], [ptrType$1], false)}, {prop: \"Zone\", name: \"Zone\", pkg: \"\", typ: $funcType([], [$String, $Int], false)}, {prop: \"Unix\", name: \"Unix\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"UnixNano\", name: \"UnixNano\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"MarshalBinary\", name: \"MarshalBinary\", pkg: \"\", typ: $funcType([], [sliceType$3, $error], false)}, {prop: \"GobEncode\", name: \"GobEncode\", pkg: \"\", typ: $funcType([], [sliceType$3, $error], false)}, {prop: \"MarshalJSON\", name: \"MarshalJSON\", pkg: \"\", typ: $funcType([], [sliceType$3, $error], false)}, {prop: \"MarshalText\", name: \"MarshalText\", pkg: \"\", typ: $funcType([], [sliceType$3, $error], false)}, {prop: \"Truncate\", name: \"Truncate\", pkg: \"\", typ: $funcType([Duration], [Time], false)}, {prop: \"Round\", name: \"Round\", pkg: \"\", typ: $funcType([Duration], [Time], false)}];\n\tptrType$6.methods = [{prop: \"UnmarshalBinary\", name: \"UnmarshalBinary\", pkg: \"\", typ: $funcType([sliceType$3], [$error], false)}, {prop: \"GobDecode\", name: \"GobDecode\", pkg: \"\", typ: $funcType([sliceType$3], [$error], false)}, {prop: \"UnmarshalJSON\", name: \"UnmarshalJSON\", pkg: \"\", typ: $funcType([sliceType$3], [$error], false)}, {prop: \"UnmarshalText\", name: \"UnmarshalText\", pkg: \"\", typ: $funcType([sliceType$3], [$error], false)}];\n\tMonth.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tWeekday.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tDuration.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Nanoseconds\", name: \"Nanoseconds\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"Seconds\", name: \"Seconds\", pkg: \"\", typ: $funcType([], [$Float64], false)}, {prop: \"Minutes\", name: \"Minutes\", pkg: \"\", typ: $funcType([], [$Float64], false)}, {prop: \"Hours\", name: \"Hours\", pkg: \"\", typ: $funcType([], [$Float64], false)}];\n\tptrType$1.methods = [{prop: \"get\", name: \"get\", pkg: \"time\", typ: $funcType([], [ptrType$1], false)}, {prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"lookup\", name: \"lookup\", pkg: \"time\", typ: $funcType([$Int64], [$String, $Int, $Bool, $Int64, $Int64], false)}, {prop: \"lookupFirstZone\", name: \"lookupFirstZone\", pkg: \"time\", typ: $funcType([], [$Int], false)}, {prop: \"firstZoneUsed\", name: \"firstZoneUsed\", pkg: \"time\", typ: $funcType([], [$Bool], false)}, {prop: \"lookupName\", name: \"lookupName\", pkg: \"time\", typ: $funcType([$String, $Int64], [$Int, $Bool, $Bool], false)}];\n\tParseError.init(\"\", [{prop: \"Layout\", name: \"Layout\", exported: true, typ: $String, tag: \"\"}, {prop: \"Value\", name: \"Value\", exported: true, typ: $String, tag: \"\"}, {prop: \"LayoutElem\", name: \"LayoutElem\", exported: true, typ: $String, tag: \"\"}, {prop: \"ValueElem\", name: \"ValueElem\", exported: true, typ: $String, tag: \"\"}, {prop: \"Message\", name: \"Message\", exported: true, typ: $String, tag: \"\"}]);\n\tTime.init(\"time\", [{prop: \"sec\", name: \"sec\", exported: false, typ: $Int64, tag: \"\"}, {prop: \"nsec\", name: \"nsec\", exported: false, typ: $Int32, tag: \"\"}, {prop: \"loc\", name: \"loc\", exported: false, typ: ptrType$1, tag: \"\"}]);\n\tLocation.init(\"time\", [{prop: \"name\", name: \"name\", exported: false, typ: $String, tag: \"\"}, {prop: \"zone\", name: \"zone\", exported: false, typ: sliceType, tag: \"\"}, {prop: \"tx\", name: \"tx\", exported: false, typ: sliceType$1, tag: \"\"}, {prop: \"cacheStart\", name: \"cacheStart\", exported: false, typ: $Int64, tag: \"\"}, {prop: \"cacheEnd\", name: \"cacheEnd\", exported: false, typ: $Int64, tag: \"\"}, {prop: \"cacheZone\", name: \"cacheZone\", exported: false, typ: ptrType, tag: \"\"}]);\n\tzone.init(\"time\", [{prop: \"name\", name: \"name\", exported: false, typ: $String, tag: \"\"}, {prop: \"offset\", name: \"offset\", exported: false, typ: $Int, tag: \"\"}, {prop: \"isDST\", name: \"isDST\", exported: false, typ: $Bool, tag: \"\"}]);\n\tzoneTrans.init(\"time\", [{prop: \"when\", name: \"when\", exported: false, typ: $Int64, tag: \"\"}, {prop: \"index\", name: \"index\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"isstd\", name: \"isstd\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"isutc\", name: \"isutc\", exported: false, typ: $Bool, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = nosync.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = syscall.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tlocalLoc = new Location.ptr(\"\", sliceType.nil, sliceType$1.nil, new $Int64(0, 0), new $Int64(0, 0), ptrType.nil);\n\t\tlocalOnce = new nosync.Once.ptr(false, false);\n\t\tstd0x = $toNativeArray($kindInt, [260, 265, 524, 526, 528, 274]);\n\t\tlongDayNames = new sliceType$2([\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]);\n\t\tshortDayNames = new sliceType$2([\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]);\n\t\tshortMonthNames = new sliceType$2([\"---\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]);\n\t\tlongMonthNames = new sliceType$2([\"---\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]);\n\t\tatoiError = errors.New(\"time: invalid number\");\n\t\terrBad = errors.New(\"bad value for field\");\n\t\terrLeadingInt = errors.New(\"time: bad [0-9]*\");\n\t\tmonths = $toNativeArray($kindString, [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]);\n\t\tdays = $toNativeArray($kindString, [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]);\n\t\tdaysBefore = $toNativeArray($kindInt32, [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]);\n\t\tutcLoc = new Location.ptr(\"UTC\", sliceType.nil, sliceType$1.nil, new $Int64(0, 0), new $Int64(0, 0), ptrType.nil);\n\t\t$pkg.UTC = utcLoc;\n\t\t$pkg.Local = localLoc;\n\t\t_r = syscall.Getenv(\"ZONEINFO\"); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tzoneinfo = _tuple[0];\n\t\tbadData = errors.New(\"malformed time zone information\");\n\t\tinit();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"os\"] = (function() {\n\tvar $pkg = {}, $init, errors, js, io, runtime, sync, atomic, syscall, time, PathError, SyscallError, LinkError, File, file, dirInfo, FileInfo, FileMode, fileStat, sliceType, ptrType, sliceType$1, ptrType$1, sliceType$2, ptrType$2, ptrType$3, ptrType$4, arrayType, ptrType$12, funcType$1, ptrType$13, arrayType$2, arrayType$5, ptrType$15, errFinished, lstat, useSyscallwd, supportsCloseOnExec, runtime_args, init, NewSyscallError, IsNotExist, isNotExist, fixCount, sigpipe, syscallMode, NewFile, epipecheck, Lstat, basename, init$1, useSyscallwdDarwin, init$2, fillFileStatFromSys, timespecToTime, init$3;\n\terrors = $packages[\"errors\"];\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tio = $packages[\"io\"];\n\truntime = $packages[\"runtime\"];\n\tsync = $packages[\"sync\"];\n\tatomic = $packages[\"sync/atomic\"];\n\tsyscall = $packages[\"syscall\"];\n\ttime = $packages[\"time\"];\n\tPathError = $pkg.PathError = $newType(0, $kindStruct, \"os.PathError\", true, \"os\", true, function(Op_, Path_, Err_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Op = \"\";\n\t\t\tthis.Path = \"\";\n\t\t\tthis.Err = $ifaceNil;\n\t\t\treturn;\n\t\t}\n\t\tthis.Op = Op_;\n\t\tthis.Path = Path_;\n\t\tthis.Err = Err_;\n\t});\n\tSyscallError = $pkg.SyscallError = $newType(0, $kindStruct, \"os.SyscallError\", true, \"os\", true, function(Syscall_, Err_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Syscall = \"\";\n\t\t\tthis.Err = $ifaceNil;\n\t\t\treturn;\n\t\t}\n\t\tthis.Syscall = Syscall_;\n\t\tthis.Err = Err_;\n\t});\n\tLinkError = $pkg.LinkError = $newType(0, $kindStruct, \"os.LinkError\", true, \"os\", true, function(Op_, Old_, New_, Err_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Op = \"\";\n\t\t\tthis.Old = \"\";\n\t\t\tthis.New = \"\";\n\t\t\tthis.Err = $ifaceNil;\n\t\t\treturn;\n\t\t}\n\t\tthis.Op = Op_;\n\t\tthis.Old = Old_;\n\t\tthis.New = New_;\n\t\tthis.Err = Err_;\n\t});\n\tFile = $pkg.File = $newType(0, $kindStruct, \"os.File\", true, \"os\", true, function(file_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.file = ptrType$12.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.file = file_;\n\t});\n\tfile = $pkg.file = $newType(0, $kindStruct, \"os.file\", true, \"os\", false, function(fd_, name_, dirinfo_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.fd = 0;\n\t\t\tthis.name = \"\";\n\t\t\tthis.dirinfo = ptrType.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.fd = fd_;\n\t\tthis.name = name_;\n\t\tthis.dirinfo = dirinfo_;\n\t});\n\tdirInfo = $pkg.dirInfo = $newType(0, $kindStruct, \"os.dirInfo\", true, \"os\", false, function(buf_, nbuf_, bufp_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.buf = sliceType$1.nil;\n\t\t\tthis.nbuf = 0;\n\t\t\tthis.bufp = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.buf = buf_;\n\t\tthis.nbuf = nbuf_;\n\t\tthis.bufp = bufp_;\n\t});\n\tFileInfo = $pkg.FileInfo = $newType(8, $kindInterface, \"os.FileInfo\", true, \"os\", true, null);\n\tFileMode = $pkg.FileMode = $newType(4, $kindUint32, \"os.FileMode\", true, \"os\", true, null);\n\tfileStat = $pkg.fileStat = $newType(0, $kindStruct, \"os.fileStat\", true, \"os\", false, function(name_, size_, mode_, modTime_, sys_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = \"\";\n\t\t\tthis.size = new $Int64(0, 0);\n\t\t\tthis.mode = 0;\n\t\t\tthis.modTime = new time.Time.ptr(new $Int64(0, 0), 0, ptrType$13.nil);\n\t\t\tthis.sys = new syscall.Stat_t.ptr(0, 0, 0, new $Uint64(0, 0), 0, 0, 0, arrayType.zero(), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new $Int64(0, 0), new $Int64(0, 0), 0, 0, 0, 0, arrayType$2.zero());\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.size = size_;\n\t\tthis.mode = mode_;\n\t\tthis.modTime = modTime_;\n\t\tthis.sys = sys_;\n\t});\n\tsliceType = $sliceType($String);\n\tptrType = $ptrType(dirInfo);\n\tsliceType$1 = $sliceType($Uint8);\n\tptrType$1 = $ptrType(File);\n\tsliceType$2 = $sliceType(FileInfo);\n\tptrType$2 = $ptrType(PathError);\n\tptrType$3 = $ptrType(LinkError);\n\tptrType$4 = $ptrType(SyscallError);\n\tarrayType = $arrayType($Uint8, 4);\n\tptrType$12 = $ptrType(file);\n\tfuncType$1 = $funcType([ptrType$12], [$error], false);\n\tptrType$13 = $ptrType(time.Location);\n\tarrayType$2 = $arrayType($Int64, 2);\n\tarrayType$5 = $arrayType($Uint8, 32);\n\tptrType$15 = $ptrType(fileStat);\n\truntime_args = function() {\n\t\tvar $ptr;\n\t\treturn $pkg.Args;\n\t};\n\tinit = function() {\n\t\tvar $ptr, argv, i, process;\n\t\tprocess = $global.process;\n\t\tif (!(process === undefined)) {\n\t\t\targv = process.argv;\n\t\t\t$pkg.Args = $makeSlice(sliceType, ($parseInt(argv.length) - 1 >> 0));\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < ($parseInt(argv.length) - 1 >> 0))) { break; }\n\t\t\t\t((i < 0 || i >= $pkg.Args.$length) ? $throwRuntimeError(\"index out of range\") : $pkg.Args.$array[$pkg.Args.$offset + i] = $internalize(argv[(i + 1 >> 0)], $String));\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t}\n\t\tif ($pkg.Args.$length === 0) {\n\t\t\t$pkg.Args = new sliceType([\"?\"]);\n\t\t}\n\t};\n\tFile.ptr.prototype.readdirnames = function(n) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, d, err, errno, f, n, names, nb, nc, size;\n\t\tnames = sliceType.nil;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f.file.dirinfo === ptrType.nil) {\n\t\t\tf.file.dirinfo = new dirInfo.ptr(sliceType$1.nil, 0, 0);\n\t\t\tf.file.dirinfo.buf = $makeSlice(sliceType$1, 4096);\n\t\t}\n\t\td = f.file.dirinfo;\n\t\tsize = n;\n\t\tif (size <= 0) {\n\t\t\tsize = 100;\n\t\t\tn = -1;\n\t\t}\n\t\tnames = $makeSlice(sliceType, 0, size);\n\t\twhile (true) {\n\t\t\tif (!(!((n === 0)))) { break; }\n\t\t\tif (d.bufp >= d.nbuf) {\n\t\t\t\td.bufp = 0;\n\t\t\t\terrno = $ifaceNil;\n\t\t\t\t_tuple$1 = syscall.ReadDirent(f.file.fd, d.buf);\n\t\t\t\t_tuple = fixCount(_tuple$1[0], _tuple$1[1]);\n\t\t\t\td.nbuf = _tuple[0];\n\t\t\t\terrno = _tuple[1];\n\t\t\t\tif (!($interfaceIsEqual(errno, $ifaceNil))) {\n\t\t\t\t\t_tmp = names;\n\t\t\t\t\t_tmp$1 = NewSyscallError(\"readdirent\", errno);\n\t\t\t\t\tnames = _tmp;\n\t\t\t\t\terr = _tmp$1;\n\t\t\t\t\treturn [names, err];\n\t\t\t\t}\n\t\t\t\tif (d.nbuf <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_tmp$2 = 0;\n\t\t\t_tmp$3 = 0;\n\t\t\tnb = _tmp$2;\n\t\t\tnc = _tmp$3;\n\t\t\t_tuple$2 = syscall.ParseDirent($subslice(d.buf, d.bufp, d.nbuf), n, names);\n\t\t\tnb = _tuple$2[0];\n\t\t\tnc = _tuple$2[1];\n\t\t\tnames = _tuple$2[2];\n\t\t\td.bufp = d.bufp + (nb) >> 0;\n\t\t\tn = n - (nc) >> 0;\n\t\t}\n\t\tif (n >= 0 && (names.$length === 0)) {\n\t\t\t_tmp$4 = names;\n\t\t\t_tmp$5 = io.EOF;\n\t\t\tnames = _tmp$4;\n\t\t\terr = _tmp$5;\n\t\t\treturn [names, err];\n\t\t}\n\t\t_tmp$6 = names;\n\t\t_tmp$7 = $ifaceNil;\n\t\tnames = _tmp$6;\n\t\terr = _tmp$7;\n\t\treturn [names, err];\n\t};\n\tFile.prototype.readdirnames = function(n) { return this.$val.readdirnames(n); };\n\tFile.ptr.prototype.Readdir = function(n) {\n\t\tvar $ptr, _r, f, n, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; f = $f.f; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t$s = -1; return [sliceType$2.nil, $pkg.ErrInvalid];\n\t\t}\n\t\t_r = f.readdir(n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.Readdir }; } $f.$ptr = $ptr; $f._r = _r; $f.f = f; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tFile.prototype.Readdir = function(n) { return this.$val.Readdir(n); };\n\tFile.ptr.prototype.Readdirnames = function(n) {\n\t\tvar $ptr, _tmp, _tmp$1, _tuple, err, f, n, names;\n\t\tnames = sliceType.nil;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = sliceType.nil;\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tnames = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [names, err];\n\t\t}\n\t\t_tuple = f.readdirnames(n);\n\t\tnames = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [names, err];\n\t};\n\tFile.prototype.Readdirnames = function(n) { return this.$val.Readdirnames(n); };\n\tPathError.ptr.prototype.Error = function() {\n\t\tvar $ptr, _r, e, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\te = this;\n\t\t_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return e.Op + \" \" + e.Path + \": \" + _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: PathError.ptr.prototype.Error }; } $f.$ptr = $ptr; $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tPathError.prototype.Error = function() { return this.$val.Error(); };\n\tSyscallError.ptr.prototype.Error = function() {\n\t\tvar $ptr, _r, e, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\te = this;\n\t\t_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return e.Syscall + \": \" + _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: SyscallError.ptr.prototype.Error }; } $f.$ptr = $ptr; $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tSyscallError.prototype.Error = function() { return this.$val.Error(); };\n\tNewSyscallError = function(syscall$1, err) {\n\t\tvar $ptr, err, syscall$1;\n\t\tif ($interfaceIsEqual(err, $ifaceNil)) {\n\t\t\treturn $ifaceNil;\n\t\t}\n\t\treturn new SyscallError.ptr(syscall$1, err);\n\t};\n\t$pkg.NewSyscallError = NewSyscallError;\n\tIsNotExist = function(err) {\n\t\tvar $ptr, err;\n\t\treturn isNotExist(err);\n\t};\n\t$pkg.IsNotExist = IsNotExist;\n\tisNotExist = function(err) {\n\t\tvar $ptr, _ref, err, pe, pe$1, pe$2, pe$3;\n\t\t_ref = err;\n\t\tif (_ref === $ifaceNil) {\n\t\t\tpe = _ref;\n\t\t\treturn false;\n\t\t} else if ($assertType(_ref, ptrType$2, true)[1]) {\n\t\t\tpe$1 = _ref.$val;\n\t\t\terr = pe$1.Err;\n\t\t} else if ($assertType(_ref, ptrType$3, true)[1]) {\n\t\t\tpe$2 = _ref.$val;\n\t\t\terr = pe$2.Err;\n\t\t} else if ($assertType(_ref, ptrType$4, true)[1]) {\n\t\t\tpe$3 = _ref.$val;\n\t\t\terr = pe$3.Err;\n\t\t}\n\t\treturn $interfaceIsEqual(err, new syscall.Errno(2)) || $interfaceIsEqual(err, $pkg.ErrNotExist);\n\t};\n\tFile.ptr.prototype.Name = function() {\n\t\tvar $ptr, f;\n\t\tf = this;\n\t\treturn f.file.name;\n\t};\n\tFile.prototype.Name = function() { return this.$val.Name(); };\n\tLinkError.ptr.prototype.Error = function() {\n\t\tvar $ptr, _r, e, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\te = this;\n\t\t_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return e.Op + \" \" + e.Old + \" \" + e.New + \": \" + _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: LinkError.ptr.prototype.Error }; } $f.$ptr = $ptr; $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tLinkError.prototype.Error = function() { return this.$val.Error(); };\n\tFile.ptr.prototype.Read = function(b) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, b, e, err, f, n;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tn = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [n, err];\n\t\t}\n\t\t_tuple = f.read(b);\n\t\tn = _tuple[0];\n\t\te = _tuple[1];\n\t\tif ((n === 0) && b.$length > 0 && $interfaceIsEqual(e, $ifaceNil)) {\n\t\t\t_tmp$2 = 0;\n\t\t\t_tmp$3 = io.EOF;\n\t\t\tn = _tmp$2;\n\t\t\terr = _tmp$3;\n\t\t\treturn [n, err];\n\t\t}\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\terr = new PathError.ptr(\"read\", f.file.name, e);\n\t\t}\n\t\t_tmp$4 = n;\n\t\t_tmp$5 = err;\n\t\tn = _tmp$4;\n\t\terr = _tmp$5;\n\t\treturn [n, err];\n\t};\n\tFile.prototype.Read = function(b) { return this.$val.Read(b); };\n\tFile.ptr.prototype.ReadAt = function(b, off) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, f, m, n, off, x;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tn = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [n, err];\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!(b.$length > 0)) { break; }\n\t\t\t_tuple = f.pread(b, off);\n\t\t\tm = _tuple[0];\n\t\t\te = _tuple[1];\n\t\t\tif ((m === 0) && $interfaceIsEqual(e, $ifaceNil)) {\n\t\t\t\t_tmp$2 = n;\n\t\t\t\t_tmp$3 = io.EOF;\n\t\t\t\tn = _tmp$2;\n\t\t\t\terr = _tmp$3;\n\t\t\t\treturn [n, err];\n\t\t\t}\n\t\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\t\terr = new PathError.ptr(\"read\", f.file.name, e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n + (m) >> 0;\n\t\t\tb = $subslice(b, m);\n\t\t\toff = (x = new $Int64(0, m), new $Int64(off.$high + x.$high, off.$low + x.$low));\n\t\t}\n\t\treturn [n, err];\n\t};\n\tFile.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };\n\tFile.ptr.prototype.Write = function(b) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, f, n;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tn = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [n, err];\n\t\t}\n\t\t_tuple = f.write(b);\n\t\tn = _tuple[0];\n\t\te = _tuple[1];\n\t\tif (n < 0) {\n\t\t\tn = 0;\n\t\t}\n\t\tif (!((n === b.$length))) {\n\t\t\terr = io.ErrShortWrite;\n\t\t}\n\t\tepipecheck(f, e);\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\terr = new PathError.ptr(\"write\", f.file.name, e);\n\t\t}\n\t\t_tmp$2 = n;\n\t\t_tmp$3 = err;\n\t\tn = _tmp$2;\n\t\terr = _tmp$3;\n\t\treturn [n, err];\n\t};\n\tFile.prototype.Write = function(b) { return this.$val.Write(b); };\n\tFile.ptr.prototype.WriteAt = function(b, off) {\n\t\tvar $ptr, _tmp, _tmp$1, _tuple, b, e, err, f, m, n, off, x;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tn = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [n, err];\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!(b.$length > 0)) { break; }\n\t\t\t_tuple = f.pwrite(b, off);\n\t\t\tm = _tuple[0];\n\t\t\te = _tuple[1];\n\t\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\t\terr = new PathError.ptr(\"write\", f.file.name, e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n + (m) >> 0;\n\t\t\tb = $subslice(b, m);\n\t\t\toff = (x = new $Int64(0, m), new $Int64(off.$high + x.$high, off.$low + x.$low));\n\t\t}\n\t\treturn [n, err];\n\t};\n\tFile.prototype.WriteAt = function(b, off) { return this.$val.WriteAt(b, off); };\n\tFile.ptr.prototype.Seek = function(offset, whence) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, e, err, f, offset, r, ret, whence;\n\t\tret = new $Int64(0, 0);\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = new $Int64(0, 0);\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tret = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [ret, err];\n\t\t}\n\t\t_tuple = f.seek(offset, whence);\n\t\tr = _tuple[0];\n\t\te = _tuple[1];\n\t\tif ($interfaceIsEqual(e, $ifaceNil) && !(f.file.dirinfo === ptrType.nil) && !((r.$high === 0 && r.$low === 0))) {\n\t\t\te = new syscall.Errno(21);\n\t\t}\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\t_tmp$2 = new $Int64(0, 0);\n\t\t\t_tmp$3 = new PathError.ptr(\"seek\", f.file.name, e);\n\t\t\tret = _tmp$2;\n\t\t\terr = _tmp$3;\n\t\t\treturn [ret, err];\n\t\t}\n\t\t_tmp$4 = r;\n\t\t_tmp$5 = $ifaceNil;\n\t\tret = _tmp$4;\n\t\terr = _tmp$5;\n\t\treturn [ret, err];\n\t};\n\tFile.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };\n\tFile.ptr.prototype.WriteString = function(s) {\n\t\tvar $ptr, _tmp, _tmp$1, _tuple, err, f, n, s;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = $pkg.ErrInvalid;\n\t\t\tn = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [n, err];\n\t\t}\n\t\t_tuple = f.Write(new sliceType$1($stringToBytes(s)));\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [n, err];\n\t};\n\tFile.prototype.WriteString = function(s) { return this.$val.WriteString(s); };\n\tFile.ptr.prototype.Chdir = function() {\n\t\tvar $ptr, e, f;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn $pkg.ErrInvalid;\n\t\t}\n\t\te = syscall.Fchdir(f.file.fd);\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\treturn new PathError.ptr(\"chdir\", f.file.name, e);\n\t\t}\n\t\treturn $ifaceNil;\n\t};\n\tFile.prototype.Chdir = function() { return this.$val.Chdir(); };\n\tfixCount = function(n, err) {\n\t\tvar $ptr, err, n;\n\t\tif (n < 0) {\n\t\t\tn = 0;\n\t\t}\n\t\treturn [n, err];\n\t};\n\tsigpipe = function() {\n\t\t$throwRuntimeError(\"native function not implemented: os.sigpipe\");\n\t};\n\tsyscallMode = function(i) {\n\t\tvar $ptr, i, o;\n\t\to = 0;\n\t\to = (o | ((new FileMode(i).Perm() >>> 0))) >>> 0;\n\t\tif (!((((i & 8388608) >>> 0) === 0))) {\n\t\t\to = (o | (2048)) >>> 0;\n\t\t}\n\t\tif (!((((i & 4194304) >>> 0) === 0))) {\n\t\t\to = (o | (1024)) >>> 0;\n\t\t}\n\t\tif (!((((i & 1048576) >>> 0) === 0))) {\n\t\t\to = (o | (512)) >>> 0;\n\t\t}\n\t\treturn o;\n\t};\n\tFile.ptr.prototype.Chmod = function(mode) {\n\t\tvar $ptr, e, f, mode;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn $pkg.ErrInvalid;\n\t\t}\n\t\te = syscall.Fchmod(f.file.fd, syscallMode(mode));\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\treturn new PathError.ptr(\"chmod\", f.file.name, e);\n\t\t}\n\t\treturn $ifaceNil;\n\t};\n\tFile.prototype.Chmod = function(mode) { return this.$val.Chmod(mode); };\n\tFile.ptr.prototype.Chown = function(uid, gid) {\n\t\tvar $ptr, e, f, gid, uid;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn $pkg.ErrInvalid;\n\t\t}\n\t\te = syscall.Fchown(f.file.fd, uid, gid);\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\treturn new PathError.ptr(\"chown\", f.file.name, e);\n\t\t}\n\t\treturn $ifaceNil;\n\t};\n\tFile.prototype.Chown = function(uid, gid) { return this.$val.Chown(uid, gid); };\n\tFile.ptr.prototype.Truncate = function(size) {\n\t\tvar $ptr, e, f, size;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn $pkg.ErrInvalid;\n\t\t}\n\t\te = syscall.Ftruncate(f.file.fd, size);\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\treturn new PathError.ptr(\"truncate\", f.file.name, e);\n\t\t}\n\t\treturn $ifaceNil;\n\t};\n\tFile.prototype.Truncate = function(size) { return this.$val.Truncate(size); };\n\tFile.ptr.prototype.Sync = function() {\n\t\tvar $ptr, e, f;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn $pkg.ErrInvalid;\n\t\t}\n\t\te = syscall.Fsync(f.file.fd);\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\treturn NewSyscallError(\"fsync\", e);\n\t\t}\n\t\treturn $ifaceNil;\n\t};\n\tFile.prototype.Sync = function() { return this.$val.Sync(); };\n\tFile.ptr.prototype.Fd = function() {\n\t\tvar $ptr, f;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn 4294967295;\n\t\t}\n\t\treturn (f.file.fd >>> 0);\n\t};\n\tFile.prototype.Fd = function() { return this.$val.Fd(); };\n\tNewFile = function(fd, name) {\n\t\tvar $ptr, f, fd, fdi, name;\n\t\tfdi = (fd >> 0);\n\t\tif (fdi < 0) {\n\t\t\treturn ptrType$1.nil;\n\t\t}\n\t\tf = new File.ptr(new file.ptr(fdi, name, ptrType.nil));\n\t\truntime.SetFinalizer(f.file, new funcType$1($methodExpr(ptrType$12, \"close\")));\n\t\treturn f;\n\t};\n\t$pkg.NewFile = NewFile;\n\tepipecheck = function(file$1, e) {\n\t\tvar $ptr, e, file$1;\n\t\tif ($interfaceIsEqual(e, new syscall.Errno(32)) && ((file$1.file.fd === 1) || (file$1.file.fd === 2))) {\n\t\t\tsigpipe();\n\t\t}\n\t};\n\tFile.ptr.prototype.Close = function() {\n\t\tvar $ptr, f;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn $pkg.ErrInvalid;\n\t\t}\n\t\treturn f.file.close();\n\t};\n\tFile.prototype.Close = function() { return this.$val.Close(); };\n\tfile.ptr.prototype.close = function() {\n\t\tvar $ptr, e, err, file$1;\n\t\tfile$1 = this;\n\t\tif (file$1 === ptrType$12.nil || file$1.fd < 0) {\n\t\t\treturn new syscall.Errno(22);\n\t\t}\n\t\terr = $ifaceNil;\n\t\te = syscall.Close(file$1.fd);\n\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\terr = new PathError.ptr(\"close\", file$1.name, e);\n\t\t}\n\t\tfile$1.fd = -1;\n\t\truntime.SetFinalizer(file$1, $ifaceNil);\n\t\treturn err;\n\t};\n\tfile.prototype.close = function() { return this.$val.close(); };\n\tFile.ptr.prototype.Stat = function() {\n\t\tvar $ptr, err, f, fs;\n\t\tf = this;\n\t\tif (f === ptrType$1.nil) {\n\t\t\treturn [$ifaceNil, $pkg.ErrInvalid];\n\t\t}\n\t\tfs = new fileStat.ptr(\"\", new $Int64(0, 0), 0, new time.Time.ptr(new $Int64(0, 0), 0, ptrType$13.nil), new syscall.Stat_t.ptr(0, 0, 0, new $Uint64(0, 0), 0, 0, 0, arrayType.zero(), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new $Int64(0, 0), new $Int64(0, 0), 0, 0, 0, 0, arrayType$2.zero()));\n\t\terr = syscall.Fstat(f.file.fd, fs.sys);\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\treturn [$ifaceNil, new PathError.ptr(\"stat\", f.file.name, err)];\n\t\t}\n\t\tfillFileStatFromSys(fs, f.file.name);\n\t\treturn [fs, $ifaceNil];\n\t};\n\tFile.prototype.Stat = function() { return this.$val.Stat(); };\n\tLstat = function(name) {\n\t\tvar $ptr, err, fs, name;\n\t\tfs = new fileStat.ptr(\"\", new $Int64(0, 0), 0, new time.Time.ptr(new $Int64(0, 0), 0, ptrType$13.nil), new syscall.Stat_t.ptr(0, 0, 0, new $Uint64(0, 0), 0, 0, 0, arrayType.zero(), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new syscall.Timespec.ptr(new $Int64(0, 0), new $Int64(0, 0)), new $Int64(0, 0), new $Int64(0, 0), 0, 0, 0, 0, arrayType$2.zero()));\n\t\terr = syscall.Lstat(name, fs.sys);\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\treturn [$ifaceNil, new PathError.ptr(\"lstat\", name, err)];\n\t\t}\n\t\tfillFileStatFromSys(fs, name);\n\t\treturn [fs, $ifaceNil];\n\t};\n\t$pkg.Lstat = Lstat;\n\tFile.ptr.prototype.readdir = function(n) {\n\t\tvar $ptr, _i, _r, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, dirname, err, f, fi, filename, fip, lerr, n, names, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; dirname = $f.dirname; err = $f.err; f = $f.f; fi = $f.fi; filename = $f.filename; fip = $f.fip; lerr = $f.lerr; n = $f.n; names = $f.names; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tfi = sliceType$2.nil;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tdirname = f.file.name;\n\t\tif (dirname === \"\") {\n\t\t\tdirname = \".\";\n\t\t}\n\t\t_tuple = f.Readdirnames(n);\n\t\tnames = _tuple[0];\n\t\terr = _tuple[1];\n\t\tfi = $makeSlice(sliceType$2, 0, names.$length);\n\t\t_ref = names;\n\t\t_i = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }\n\t\t\tfilename = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t_r = lstat(dirname + \"/\" + filename); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t_tuple$1 = _r;\n\t\t\tfip = _tuple$1[0];\n\t\t\tlerr = _tuple$1[1];\n\t\t\tif (IsNotExist(lerr)) {\n\t\t\t\t_i++;\n\t\t\t\t/* continue; */ $s = 1; continue;\n\t\t\t}\n\t\t\tif (!($interfaceIsEqual(lerr, $ifaceNil))) {\n\t\t\t\t_tmp = fi;\n\t\t\t\t_tmp$1 = lerr;\n\t\t\t\tfi = _tmp;\n\t\t\t\terr = _tmp$1;\n\t\t\t\t$s = -1; return [fi, err];\n\t\t\t}\n\t\t\tfi = $append(fi, fip);\n\t\t\t_i++;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t_tmp$2 = fi;\n\t\t_tmp$3 = err;\n\t\tfi = _tmp$2;\n\t\terr = _tmp$3;\n\t\t$s = -1; return [fi, err];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: File.ptr.prototype.readdir }; } $f.$ptr = $ptr; $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.dirname = dirname; $f.err = err; $f.f = f; $f.fi = fi; $f.filename = filename; $f.fip = fip; $f.lerr = lerr; $f.n = n; $f.names = names; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tFile.prototype.readdir = function(n) { return this.$val.readdir(n); };\n\tFile.ptr.prototype.read = function(b) {\n\t\tvar $ptr, _tuple, _tuple$1, b, err, f, n;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (true && b.$length > 1073741824) {\n\t\t\tb = $subslice(b, 0, 1073741824);\n\t\t}\n\t\t_tuple$1 = syscall.Read(f.file.fd, b);\n\t\t_tuple = fixCount(_tuple$1[0], _tuple$1[1]);\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [n, err];\n\t};\n\tFile.prototype.read = function(b) { return this.$val.read(b); };\n\tFile.ptr.prototype.pread = function(b, off) {\n\t\tvar $ptr, _tuple, _tuple$1, b, err, f, n, off;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (true && b.$length > 1073741824) {\n\t\t\tb = $subslice(b, 0, 1073741824);\n\t\t}\n\t\t_tuple$1 = syscall.Pread(f.file.fd, b, off);\n\t\t_tuple = fixCount(_tuple$1[0], _tuple$1[1]);\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [n, err];\n\t};\n\tFile.prototype.pread = function(b, off) { return this.$val.pread(b, off); };\n\tFile.ptr.prototype.write = function(b) {\n\t\tvar $ptr, _tmp, _tmp$1, _tuple, _tuple$1, b, bcap, err, err$1, f, m, n;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\twhile (true) {\n\t\t\tbcap = b;\n\t\t\tif (true && bcap.$length > 1073741824) {\n\t\t\t\tbcap = $subslice(bcap, 0, 1073741824);\n\t\t\t}\n\t\t\t_tuple$1 = syscall.Write(f.file.fd, bcap);\n\t\t\t_tuple = fixCount(_tuple$1[0], _tuple$1[1]);\n\t\t\tm = _tuple[0];\n\t\t\terr$1 = _tuple[1];\n\t\t\tn = n + (m) >> 0;\n\t\t\tif (0 < m && m < bcap.$length || $interfaceIsEqual(err$1, new syscall.Errno(4))) {\n\t\t\t\tb = $subslice(b, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (true && !((bcap.$length === b.$length)) && $interfaceIsEqual(err$1, $ifaceNil)) {\n\t\t\t\tb = $subslice(b, m);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t_tmp = n;\n\t\t\t_tmp$1 = err$1;\n\t\t\tn = _tmp;\n\t\t\terr = _tmp$1;\n\t\t\treturn [n, err];\n\t\t}\n\t};\n\tFile.prototype.write = function(b) { return this.$val.write(b); };\n\tFile.ptr.prototype.pwrite = function(b, off) {\n\t\tvar $ptr, _tuple, _tuple$1, b, err, f, n, off;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\tif (true && b.$length > 1073741824) {\n\t\t\tb = $subslice(b, 0, 1073741824);\n\t\t}\n\t\t_tuple$1 = syscall.Pwrite(f.file.fd, b, off);\n\t\t_tuple = fixCount(_tuple$1[0], _tuple$1[1]);\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [n, err];\n\t};\n\tFile.prototype.pwrite = function(b, off) { return this.$val.pwrite(b, off); };\n\tFile.ptr.prototype.seek = function(offset, whence) {\n\t\tvar $ptr, _tuple, err, f, offset, ret, whence;\n\t\tret = new $Int64(0, 0);\n\t\terr = $ifaceNil;\n\t\tf = this;\n\t\t_tuple = syscall.Seek(f.file.fd, offset, whence);\n\t\tret = _tuple[0];\n\t\terr = _tuple[1];\n\t\treturn [ret, err];\n\t};\n\tFile.prototype.seek = function(offset, whence) { return this.$val.seek(offset, whence); };\n\tbasename = function(name) {\n\t\tvar $ptr, i, name;\n\t\ti = name.length - 1 >> 0;\n\t\twhile (true) {\n\t\t\tif (!(i > 0 && (name.charCodeAt(i) === 47))) { break; }\n\t\t\tname = $substring(name, 0, i);\n\t\t\ti = i - (1) >> 0;\n\t\t}\n\t\ti = i - (1) >> 0;\n\t\twhile (true) {\n\t\t\tif (!(i >= 0)) { break; }\n\t\t\tif (name.charCodeAt(i) === 47) {\n\t\t\t\tname = $substring(name, (i + 1 >> 0));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = i - (1) >> 0;\n\t\t}\n\t\treturn name;\n\t};\n\tinit$1 = function() {\n\t\tvar $ptr;\n\t\tuseSyscallwd = useSyscallwdDarwin;\n\t};\n\tuseSyscallwdDarwin = function(err) {\n\t\tvar $ptr, err;\n\t\treturn !($interfaceIsEqual(err, new syscall.Errno(45)));\n\t};\n\tinit$2 = function() {\n\t\tvar $ptr;\n\t\tif (false) {\n\t\t\treturn;\n\t\t}\n\t\t$pkg.Args = runtime_args();\n\t};\n\tfillFileStatFromSys = function(fs, name) {\n\t\tvar $ptr, _1, fs, name;\n\t\tfs.name = basename(name);\n\t\tfs.size = fs.sys.Size;\n\t\ttime.Time.copy(fs.modTime, timespecToTime($clone(fs.sys.Mtimespec, syscall.Timespec)));\n\t\tfs.mode = (((fs.sys.Mode & 511) >>> 0) >>> 0);\n\t\t_1 = (fs.sys.Mode & 61440) >>> 0;\n\t\tif ((_1 === (24576)) || (_1 === (57344))) {\n\t\t\tfs.mode = (fs.mode | (67108864)) >>> 0;\n\t\t} else if (_1 === (8192)) {\n\t\t\tfs.mode = (fs.mode | (69206016)) >>> 0;\n\t\t} else if (_1 === (16384)) {\n\t\t\tfs.mode = (fs.mode | (2147483648)) >>> 0;\n\t\t} else if (_1 === (4096)) {\n\t\t\tfs.mode = (fs.mode | (33554432)) >>> 0;\n\t\t} else if (_1 === (40960)) {\n\t\t\tfs.mode = (fs.mode | (134217728)) >>> 0;\n\t\t} else if (_1 === (32768)) {\n\t\t} else if (_1 === (49152)) {\n\t\t\tfs.mode = (fs.mode | (16777216)) >>> 0;\n\t\t}\n\t\tif (!((((fs.sys.Mode & 1024) >>> 0) === 0))) {\n\t\t\tfs.mode = (fs.mode | (4194304)) >>> 0;\n\t\t}\n\t\tif (!((((fs.sys.Mode & 2048) >>> 0) === 0))) {\n\t\t\tfs.mode = (fs.mode | (8388608)) >>> 0;\n\t\t}\n\t\tif (!((((fs.sys.Mode & 512) >>> 0) === 0))) {\n\t\t\tfs.mode = (fs.mode | (1048576)) >>> 0;\n\t\t}\n\t};\n\ttimespecToTime = function(ts) {\n\t\tvar $ptr, ts;\n\t\treturn time.Unix(ts.Sec, ts.Nsec);\n\t};\n\tinit$3 = function() {\n\t\tvar $ptr, _i, _ref, _rune, _tuple, err, i, osver;\n\t\t_tuple = syscall.Sysctl(\"kern.osrelease\");\n\t\tosver = _tuple[0];\n\t\terr = _tuple[1];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\treturn;\n\t\t}\n\t\ti = 0;\n\t\t_ref = osver;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.length)) { break; }\n\t\t\t_rune = $decodeRune(_ref, _i);\n\t\t\ti = _i;\n\t\t\tif (!((osver.charCodeAt(i) === 46))) {\n\t\t\t\t_i += _rune[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t_i += _rune[1];\n\t\t}\n\t\tif (i > 2 || (i === 2) && osver.charCodeAt(0) >= 49 && osver.charCodeAt(1) >= 49) {\n\t\t\tsupportsCloseOnExec = true;\n\t\t}\n\t};\n\tFileMode.prototype.String = function() {\n\t\tvar $ptr, _i, _i$1, _ref, _ref$1, _rune, _rune$1, buf, c, c$1, i, i$1, m, w, y, y$1;\n\t\tm = this.$val;\n\t\tbuf = arrayType$5.zero();\n\t\tw = 0;\n\t\t_ref = \"dalTLDpSugct\";\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.length)) { break; }\n\t\t\t_rune = $decodeRune(_ref, _i);\n\t\t\ti = _i;\n\t\t\tc = _rune[0];\n\t\t\tif (!((((m & (((y = ((31 - i >> 0) >>> 0), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0) === 0))) {\n\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = (c << 24 >>> 24));\n\t\t\t\tw = w + (1) >> 0;\n\t\t\t}\n\t\t\t_i += _rune[1];\n\t\t}\n\t\tif (w === 0) {\n\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 45);\n\t\t\tw = w + (1) >> 0;\n\t\t}\n\t\t_ref$1 = \"rwxrwxrwx\";\n\t\t_i$1 = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i$1 < _ref$1.length)) { break; }\n\t\t\t_rune$1 = $decodeRune(_ref$1, _i$1);\n\t\t\ti$1 = _i$1;\n\t\t\tc$1 = _rune$1[0];\n\t\t\tif (!((((m & (((y$1 = ((8 - i$1 >> 0) >>> 0), y$1 < 32 ? (1 << y$1) : 0) >>> 0))) >>> 0) === 0))) {\n\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = (c$1 << 24 >>> 24));\n\t\t\t} else {\n\t\t\t\t((w < 0 || w >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[w] = 45);\n\t\t\t}\n\t\t\tw = w + (1) >> 0;\n\t\t\t_i$1 += _rune$1[1];\n\t\t}\n\t\treturn $bytesToString($subslice(new sliceType$1(buf), 0, w));\n\t};\n\t$ptrType(FileMode).prototype.String = function() { return new FileMode(this.$get()).String(); };\n\tFileMode.prototype.IsDir = function() {\n\t\tvar $ptr, m;\n\t\tm = this.$val;\n\t\treturn !((((m & 2147483648) >>> 0) === 0));\n\t};\n\t$ptrType(FileMode).prototype.IsDir = function() { return new FileMode(this.$get()).IsDir(); };\n\tFileMode.prototype.IsRegular = function() {\n\t\tvar $ptr, m;\n\t\tm = this.$val;\n\t\treturn ((m & 2399141888) >>> 0) === 0;\n\t};\n\t$ptrType(FileMode).prototype.IsRegular = function() { return new FileMode(this.$get()).IsRegular(); };\n\tFileMode.prototype.Perm = function() {\n\t\tvar $ptr, m;\n\t\tm = this.$val;\n\t\treturn (m & 511) >>> 0;\n\t};\n\t$ptrType(FileMode).prototype.Perm = function() { return new FileMode(this.$get()).Perm(); };\n\tfileStat.ptr.prototype.Name = function() {\n\t\tvar $ptr, fs;\n\t\tfs = this;\n\t\treturn fs.name;\n\t};\n\tfileStat.prototype.Name = function() { return this.$val.Name(); };\n\tfileStat.ptr.prototype.IsDir = function() {\n\t\tvar $ptr, fs;\n\t\tfs = this;\n\t\treturn new FileMode(fs.Mode()).IsDir();\n\t};\n\tfileStat.prototype.IsDir = function() { return this.$val.IsDir(); };\n\tfileStat.ptr.prototype.Size = function() {\n\t\tvar $ptr, fs;\n\t\tfs = this;\n\t\treturn fs.size;\n\t};\n\tfileStat.prototype.Size = function() { return this.$val.Size(); };\n\tfileStat.ptr.prototype.Mode = function() {\n\t\tvar $ptr, fs;\n\t\tfs = this;\n\t\treturn fs.mode;\n\t};\n\tfileStat.prototype.Mode = function() { return this.$val.Mode(); };\n\tfileStat.ptr.prototype.ModTime = function() {\n\t\tvar $ptr, fs;\n\t\tfs = this;\n\t\treturn fs.modTime;\n\t};\n\tfileStat.prototype.ModTime = function() { return this.$val.ModTime(); };\n\tfileStat.ptr.prototype.Sys = function() {\n\t\tvar $ptr, fs;\n\t\tfs = this;\n\t\treturn fs.sys;\n\t};\n\tfileStat.prototype.Sys = function() { return this.$val.Sys(); };\n\tptrType$2.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tptrType$4.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tptrType$3.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tptrType$1.methods = [{prop: \"readdirnames\", name: \"readdirnames\", pkg: \"os\", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: \"Readdir\", name: \"Readdir\", pkg: \"\", typ: $funcType([$Int], [sliceType$2, $error], false)}, {prop: \"Readdirnames\", name: \"Readdirnames\", pkg: \"\", typ: $funcType([$Int], [sliceType, $error], false)}, {prop: \"Name\", name: \"Name\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Read\", name: \"Read\", pkg: \"\", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: \"ReadAt\", name: \"ReadAt\", pkg: \"\", typ: $funcType([sliceType$1, $Int64], [$Int, $error], false)}, {prop: \"Write\", name: \"Write\", pkg: \"\", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: \"WriteAt\", name: \"WriteAt\", pkg: \"\", typ: $funcType([sliceType$1, $Int64], [$Int, $error], false)}, {prop: \"Seek\", name: \"Seek\", pkg: \"\", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: \"WriteString\", name: \"WriteString\", pkg: \"\", typ: $funcType([$String], [$Int, $error], false)}, {prop: \"Chdir\", name: \"Chdir\", pkg: \"\", typ: $funcType([], [$error], false)}, {prop: \"Chmod\", name: \"Chmod\", pkg: \"\", typ: $funcType([FileMode], [$error], false)}, {prop: \"Chown\", name: \"Chown\", pkg: \"\", typ: $funcType([$Int, $Int], [$error], false)}, {prop: \"Truncate\", name: \"Truncate\", pkg: \"\", typ: $funcType([$Int64], [$error], false)}, {prop: \"Sync\", name: \"Sync\", pkg: \"\", typ: $funcType([], [$error], false)}, {prop: \"Fd\", name: \"Fd\", pkg: \"\", typ: $funcType([], [$Uintptr], false)}, {prop: \"Close\", name: \"Close\", pkg: \"\", typ: $funcType([], [$error], false)}, {prop: \"Stat\", name: \"Stat\", pkg: \"\", typ: $funcType([], [FileInfo, $error], false)}, {prop: \"readdir\", name: \"readdir\", pkg: \"os\", typ: $funcType([$Int], [sliceType$2, $error], false)}, {prop: \"read\", name: \"read\", pkg: \"os\", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: \"pread\", name: \"pread\", pkg: \"os\", typ: $funcType([sliceType$1, $Int64], [$Int, $error], false)}, {prop: \"write\", name: \"write\", pkg: \"os\", typ: $funcType([sliceType$1], [$Int, $error], false)}, {prop: \"pwrite\", name: \"pwrite\", pkg: \"os\", typ: $funcType([sliceType$1, $Int64], [$Int, $error], false)}, {prop: \"seek\", name: \"seek\", pkg: \"os\", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}];\n\tptrType$12.methods = [{prop: \"close\", name: \"close\", pkg: \"os\", typ: $funcType([], [$error], false)}];\n\tFileMode.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"IsDir\", name: \"IsDir\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"IsRegular\", name: \"IsRegular\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Perm\", name: \"Perm\", pkg: \"\", typ: $funcType([], [FileMode], false)}];\n\tptrType$15.methods = [{prop: \"Name\", name: \"Name\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"IsDir\", name: \"IsDir\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Size\", name: \"Size\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"Mode\", name: \"Mode\", pkg: \"\", typ: $funcType([], [FileMode], false)}, {prop: \"ModTime\", name: \"ModTime\", pkg: \"\", typ: $funcType([], [time.Time], false)}, {prop: \"Sys\", name: \"Sys\", pkg: \"\", typ: $funcType([], [$emptyInterface], false)}];\n\tPathError.init(\"\", [{prop: \"Op\", name: \"Op\", exported: true, typ: $String, tag: \"\"}, {prop: \"Path\", name: \"Path\", exported: true, typ: $String, tag: \"\"}, {prop: \"Err\", name: \"Err\", exported: true, typ: $error, tag: \"\"}]);\n\tSyscallError.init(\"\", [{prop: \"Syscall\", name: \"Syscall\", exported: true, typ: $String, tag: \"\"}, {prop: \"Err\", name: \"Err\", exported: true, typ: $error, tag: \"\"}]);\n\tLinkError.init(\"\", [{prop: \"Op\", name: \"Op\", exported: true, typ: $String, tag: \"\"}, {prop: \"Old\", name: \"Old\", exported: true, typ: $String, tag: \"\"}, {prop: \"New\", name: \"New\", exported: true, typ: $String, tag: \"\"}, {prop: \"Err\", name: \"Err\", exported: true, typ: $error, tag: \"\"}]);\n\tFile.init(\"os\", [{prop: \"file\", name: \"\", exported: false, typ: ptrType$12, tag: \"\"}]);\n\tfile.init(\"os\", [{prop: \"fd\", name: \"fd\", exported: false, typ: $Int, tag: \"\"}, {prop: \"name\", name: \"name\", exported: false, typ: $String, tag: \"\"}, {prop: \"dirinfo\", name: \"dirinfo\", exported: false, typ: ptrType, tag: \"\"}]);\n\tdirInfo.init(\"os\", [{prop: \"buf\", name: \"buf\", exported: false, typ: sliceType$1, tag: \"\"}, {prop: \"nbuf\", name: \"nbuf\", exported: false, typ: $Int, tag: \"\"}, {prop: \"bufp\", name: \"bufp\", exported: false, typ: $Int, tag: \"\"}]);\n\tFileInfo.init([{prop: \"IsDir\", name: \"IsDir\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"ModTime\", name: \"ModTime\", pkg: \"\", typ: $funcType([], [time.Time], false)}, {prop: \"Mode\", name: \"Mode\", pkg: \"\", typ: $funcType([], [FileMode], false)}, {prop: \"Name\", name: \"Name\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Size\", name: \"Size\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"Sys\", name: \"Sys\", pkg: \"\", typ: $funcType([], [$emptyInterface], false)}]);\n\tfileStat.init(\"os\", [{prop: \"name\", name: \"name\", exported: false, typ: $String, tag: \"\"}, {prop: \"size\", name: \"size\", exported: false, typ: $Int64, tag: \"\"}, {prop: \"mode\", name: \"mode\", exported: false, typ: FileMode, tag: \"\"}, {prop: \"modTime\", name: \"modTime\", exported: false, typ: time.Time, tag: \"\"}, {prop: \"sys\", name: \"sys\", exported: false, typ: syscall.Stat_t, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = sync.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = atomic.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = syscall.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = time.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$pkg.Args = sliceType.nil;\n\t\tsupportsCloseOnExec = false;\n\t\t$pkg.ErrInvalid = errors.New(\"invalid argument\");\n\t\t$pkg.ErrPermission = errors.New(\"permission denied\");\n\t\t$pkg.ErrExist = errors.New(\"file already exists\");\n\t\t$pkg.ErrNotExist = errors.New(\"file does not exist\");\n\t\terrFinished = errors.New(\"os: process already finished\");\n\t\t$pkg.Stdin = NewFile((syscall.Stdin >>> 0), \"/dev/stdin\");\n\t\t$pkg.Stdout = NewFile((syscall.Stdout >>> 0), \"/dev/stdout\");\n\t\t$pkg.Stderr = NewFile((syscall.Stderr >>> 0), \"/dev/stderr\");\n\t\tuseSyscallwd = (function(param) {\n\t\t\tvar $ptr, param;\n\t\t\treturn true;\n\t\t});\n\t\tlstat = Lstat;\n\t\tinit();\n\t\tinit$1();\n\t\tinit$2();\n\t\tinit$3();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"unicode/utf8\"] = (function() {\n\tvar $pkg = {}, $init, acceptRange, first, acceptRanges, DecodeRuneInString, RuneLen, EncodeRune, RuneCount, RuneCountInString, ValidRune;\n\tacceptRange = $pkg.acceptRange = $newType(0, $kindStruct, \"utf8.acceptRange\", true, \"unicode/utf8\", false, function(lo_, hi_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.lo = 0;\n\t\t\tthis.hi = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.lo = lo_;\n\t\tthis.hi = hi_;\n\t});\n\tDecodeRuneInString = function(s) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, mask, n, r, s, s0, s1, s2, s3, size, sz, x, x$1;\n\t\tr = 0;\n\t\tsize = 0;\n\t\tn = s.length;\n\t\tif (n < 1) {\n\t\t\t_tmp = 65533;\n\t\t\t_tmp$1 = 0;\n\t\t\tr = _tmp;\n\t\t\tsize = _tmp$1;\n\t\t\treturn [r, size];\n\t\t}\n\t\ts0 = s.charCodeAt(0);\n\t\tx = ((s0 < 0 || s0 >= first.length) ? $throwRuntimeError(\"index out of range\") : first[s0]);\n\t\tif (x >= 240) {\n\t\t\tmask = ((x >> 0) << 31 >> 0) >> 31 >> 0;\n\t\t\t_tmp$2 = (((s.charCodeAt(0) >> 0) & ~mask) >> 0) | (65533 & mask);\n\t\t\t_tmp$3 = 1;\n\t\t\tr = _tmp$2;\n\t\t\tsize = _tmp$3;\n\t\t\treturn [r, size];\n\t\t}\n\t\tsz = (x & 7) >>> 0;\n\t\taccept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? $throwRuntimeError(\"index out of range\") : acceptRanges[x$1])), acceptRange);\n\t\tif (n < (sz >> 0)) {\n\t\t\t_tmp$4 = 65533;\n\t\t\t_tmp$5 = 1;\n\t\t\tr = _tmp$4;\n\t\t\tsize = _tmp$5;\n\t\t\treturn [r, size];\n\t\t}\n\t\ts1 = s.charCodeAt(1);\n\t\tif (s1 < accept.lo || accept.hi < s1) {\n\t\t\t_tmp$6 = 65533;\n\t\t\t_tmp$7 = 1;\n\t\t\tr = _tmp$6;\n\t\t\tsize = _tmp$7;\n\t\t\treturn [r, size];\n\t\t}\n\t\tif (sz === 2) {\n\t\t\t_tmp$8 = ((((s0 & 31) >>> 0) >> 0) << 6 >> 0) | (((s1 & 63) >>> 0) >> 0);\n\t\t\t_tmp$9 = 2;\n\t\t\tr = _tmp$8;\n\t\t\tsize = _tmp$9;\n\t\t\treturn [r, size];\n\t\t}\n\t\ts2 = s.charCodeAt(2);\n\t\tif (s2 < 128 || 191 < s2) {\n\t\t\t_tmp$10 = 65533;\n\t\t\t_tmp$11 = 1;\n\t\t\tr = _tmp$10;\n\t\t\tsize = _tmp$11;\n\t\t\treturn [r, size];\n\t\t}\n\t\tif (sz === 3) {\n\t\t\t_tmp$12 = (((((s0 & 15) >>> 0) >> 0) << 12 >> 0) | ((((s1 & 63) >>> 0) >> 0) << 6 >> 0)) | (((s2 & 63) >>> 0) >> 0);\n\t\t\t_tmp$13 = 3;\n\t\t\tr = _tmp$12;\n\t\t\tsize = _tmp$13;\n\t\t\treturn [r, size];\n\t\t}\n\t\ts3 = s.charCodeAt(3);\n\t\tif (s3 < 128 || 191 < s3) {\n\t\t\t_tmp$14 = 65533;\n\t\t\t_tmp$15 = 1;\n\t\t\tr = _tmp$14;\n\t\t\tsize = _tmp$15;\n\t\t\treturn [r, size];\n\t\t}\n\t\t_tmp$16 = ((((((s0 & 7) >>> 0) >> 0) << 18 >> 0) | ((((s1 & 63) >>> 0) >> 0) << 12 >> 0)) | ((((s2 & 63) >>> 0) >> 0) << 6 >> 0)) | (((s3 & 63) >>> 0) >> 0);\n\t\t_tmp$17 = 4;\n\t\tr = _tmp$16;\n\t\tsize = _tmp$17;\n\t\treturn [r, size];\n\t};\n\t$pkg.DecodeRuneInString = DecodeRuneInString;\n\tRuneLen = function(r) {\n\t\tvar $ptr, r;\n\t\tif (r < 0) {\n\t\t\treturn -1;\n\t\t} else if (r <= 127) {\n\t\t\treturn 1;\n\t\t} else if (r <= 2047) {\n\t\t\treturn 2;\n\t\t} else if (55296 <= r && r <= 57343) {\n\t\t\treturn -1;\n\t\t} else if (r <= 65535) {\n\t\t\treturn 3;\n\t\t} else if (r <= 1114111) {\n\t\t\treturn 4;\n\t\t}\n\t\treturn -1;\n\t};\n\t$pkg.RuneLen = RuneLen;\n\tEncodeRune = function(p, r) {\n\t\tvar $ptr, i, p, r;\n\t\ti = (r >>> 0);\n\t\tif (i <= 127) {\n\t\t\t(0 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 0] = (r << 24 >>> 24));\n\t\t\treturn 1;\n\t\t} else if (i <= 2047) {\n\t\t\t(0 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 0] = ((192 | ((r >> 6 >> 0) << 24 >>> 24)) >>> 0));\n\t\t\t(1 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 1] = ((128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\treturn 2;\n\t\t} else if ((i > 1114111) || (55296 <= i && i <= 57343)) {\n\t\t\tr = 65533;\n\t\t\t(0 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 0] = ((224 | ((r >> 12 >> 0) << 24 >>> 24)) >>> 0));\n\t\t\t(1 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 1] = ((128 | ((((r >> 6 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\t(2 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 2] = ((128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\treturn 3;\n\t\t} else if (i <= 65535) {\n\t\t\t(0 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 0] = ((224 | ((r >> 12 >> 0) << 24 >>> 24)) >>> 0));\n\t\t\t(1 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 1] = ((128 | ((((r >> 6 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\t(2 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 2] = ((128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\treturn 3;\n\t\t} else {\n\t\t\t(0 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 0] = ((240 | ((r >> 18 >> 0) << 24 >>> 24)) >>> 0));\n\t\t\t(1 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 1] = ((128 | ((((r >> 12 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\t(2 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 2] = ((128 | ((((r >> 6 >> 0) << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\t(3 >= p.$length ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + 3] = ((128 | (((r << 24 >>> 24) & 63) >>> 0)) >>> 0));\n\t\t\treturn 4;\n\t\t}\n\t};\n\t$pkg.EncodeRune = EncodeRune;\n\tRuneCount = function(p) {\n\t\tvar $ptr, accept, c, c$1, c$2, c$3, i, n, np, p, size, x, x$1, x$2, x$3, x$4;\n\t\tnp = p.$length;\n\t\tn = 0;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < np)) { break; }\n\t\t\tn = n + (1) >> 0;\n\t\t\tc = ((i < 0 || i >= p.$length) ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + i]);\n\t\t\tif (c < 128) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx = ((c < 0 || c >= first.length) ? $throwRuntimeError(\"index out of range\") : first[c]);\n\t\t\tif (x === 241) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsize = (((x & 7) >>> 0) >> 0);\n\t\t\tif ((i + size >> 0) > np) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taccept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? $throwRuntimeError(\"index out of range\") : acceptRanges[x$1])), acceptRange);\n\t\t\tc$1 = (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + x$2]));\n\t\t\tif (c$1 < accept.lo || accept.hi < c$1) {\n\t\t\t\tsize = 1;\n\t\t\t} else if (size === 2) {\n\t\t\t} else {\n\t\t\t\tc$2 = (x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + x$3]));\n\t\t\t\tif (c$2 < 128 || 191 < c$2) {\n\t\t\t\t\tsize = 1;\n\t\t\t\t} else if (size === 3) {\n\t\t\t\t} else {\n\t\t\t\t\tc$3 = (x$4 = i + 3 >> 0, ((x$4 < 0 || x$4 >= p.$length) ? $throwRuntimeError(\"index out of range\") : p.$array[p.$offset + x$4]));\n\t\t\t\t\tif (c$3 < 128 || 191 < c$3) {\n\t\t\t\t\t\tsize = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = i + (size) >> 0;\n\t\t}\n\t\treturn n;\n\t};\n\t$pkg.RuneCount = RuneCount;\n\tRuneCountInString = function(s) {\n\t\tvar $ptr, accept, c, c$1, c$2, c$3, i, n, ns, s, size, x, x$1;\n\t\tn = 0;\n\t\tns = s.length;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < ns)) { break; }\n\t\t\tc = s.charCodeAt(i);\n\t\t\tif (c < 128) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t\tn = n + (1) >> 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tx = ((c < 0 || c >= first.length) ? $throwRuntimeError(\"index out of range\") : first[c]);\n\t\t\tif (x === 241) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t\tn = n + (1) >> 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsize = (((x & 7) >>> 0) >> 0);\n\t\t\tif ((i + size >> 0) > ns) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t\tn = n + (1) >> 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\taccept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? $throwRuntimeError(\"index out of range\") : acceptRanges[x$1])), acceptRange);\n\t\t\tc$1 = s.charCodeAt((i + 1 >> 0));\n\t\t\tif (c$1 < accept.lo || accept.hi < c$1) {\n\t\t\t\tsize = 1;\n\t\t\t} else if (size === 2) {\n\t\t\t} else {\n\t\t\t\tc$2 = s.charCodeAt((i + 2 >> 0));\n\t\t\t\tif (c$2 < 128 || 191 < c$2) {\n\t\t\t\t\tsize = 1;\n\t\t\t\t} else if (size === 3) {\n\t\t\t\t} else {\n\t\t\t\t\tc$3 = s.charCodeAt((i + 3 >> 0));\n\t\t\t\t\tif (c$3 < 128 || 191 < c$3) {\n\t\t\t\t\t\tsize = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = i + (size) >> 0;\n\t\t\tn = n + (1) >> 0;\n\t\t}\n\t\tn = n;\n\t\treturn n;\n\t};\n\t$pkg.RuneCountInString = RuneCountInString;\n\tValidRune = function(r) {\n\t\tvar $ptr, r;\n\t\tif (r < 0) {\n\t\t\treturn false;\n\t\t} else if (55296 <= r && r <= 57343) {\n\t\t\treturn false;\n\t\t} else if (r > 1114111) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\t$pkg.ValidRune = ValidRune;\n\tacceptRange.init(\"unicode/utf8\", [{prop: \"lo\", name: \"lo\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"hi\", name: \"hi\", exported: false, typ: $Uint8, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tfirst = $toNativeArray($kindUint8, [240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 19, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 35, 3, 3, 52, 4, 4, 4, 68, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241]);\n\t\tacceptRanges = $toNativeArray($kindStruct, [new acceptRange.ptr(128, 191), new acceptRange.ptr(160, 191), new acceptRange.ptr(128, 159), new acceptRange.ptr(144, 191), new acceptRange.ptr(128, 143)]);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"strconv\"] = (function() {\n\tvar $pkg = {}, $init, errors, math, utf8, decimal, leftCheat, extFloat, floatInfo, decimalSlice, sliceType$3, sliceType$4, sliceType$5, arrayType, sliceType$6, arrayType$1, arrayType$2, ptrType$1, arrayType$3, arrayType$4, ptrType$2, ptrType$3, ptrType$4, optimize, leftcheats, smallPowersOfTen, powersOfTen, uint64pow10, float32info, float32info$24ptr, float64info, float64info$24ptr, isPrint16, isNotPrint16, isPrint32, isNotPrint32, isGraphic, shifts, digitZero, trim, rightShift, prefixIsLessThan, leftShift, shouldRoundUp, frexp10Many, adjustLastDigitFixed, adjustLastDigit, AppendFloat, genericFtoa, bigFtoa, formatDigits, roundShortest, fmtE, fmtF, fmtB, min, max, FormatInt, Itoa, formatBits, appendQuotedWith, appendQuotedRuneWith, appendEscapedRune, AppendQuote, AppendQuoteToASCII, AppendQuoteRune, AppendQuoteRuneToASCII, CanBackquote, unhex, UnquoteChar, Unquote, contains, bsearch16, bsearch32, IsPrint, isInGraphicList;\n\terrors = $packages[\"errors\"];\n\tmath = $packages[\"math\"];\n\tutf8 = $packages[\"unicode/utf8\"];\n\tdecimal = $pkg.decimal = $newType(0, $kindStruct, \"strconv.decimal\", true, \"strconv\", false, function(d_, nd_, dp_, neg_, trunc_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.d = arrayType.zero();\n\t\t\tthis.nd = 0;\n\t\t\tthis.dp = 0;\n\t\t\tthis.neg = false;\n\t\t\tthis.trunc = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.d = d_;\n\t\tthis.nd = nd_;\n\t\tthis.dp = dp_;\n\t\tthis.neg = neg_;\n\t\tthis.trunc = trunc_;\n\t});\n\tleftCheat = $pkg.leftCheat = $newType(0, $kindStruct, \"strconv.leftCheat\", true, \"strconv\", false, function(delta_, cutoff_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.delta = 0;\n\t\t\tthis.cutoff = \"\";\n\t\t\treturn;\n\t\t}\n\t\tthis.delta = delta_;\n\t\tthis.cutoff = cutoff_;\n\t});\n\textFloat = $pkg.extFloat = $newType(0, $kindStruct, \"strconv.extFloat\", true, \"strconv\", false, function(mant_, exp_, neg_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.mant = new $Uint64(0, 0);\n\t\t\tthis.exp = 0;\n\t\t\tthis.neg = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.mant = mant_;\n\t\tthis.exp = exp_;\n\t\tthis.neg = neg_;\n\t});\n\tfloatInfo = $pkg.floatInfo = $newType(0, $kindStruct, \"strconv.floatInfo\", true, \"strconv\", false, function(mantbits_, expbits_, bias_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.mantbits = 0;\n\t\t\tthis.expbits = 0;\n\t\t\tthis.bias = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.mantbits = mantbits_;\n\t\tthis.expbits = expbits_;\n\t\tthis.bias = bias_;\n\t});\n\tdecimalSlice = $pkg.decimalSlice = $newType(0, $kindStruct, \"strconv.decimalSlice\", true, \"strconv\", false, function(d_, nd_, dp_, neg_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.d = sliceType$6.nil;\n\t\t\tthis.nd = 0;\n\t\t\tthis.dp = 0;\n\t\t\tthis.neg = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.d = d_;\n\t\tthis.nd = nd_;\n\t\tthis.dp = dp_;\n\t\tthis.neg = neg_;\n\t});\n\tsliceType$3 = $sliceType(leftCheat);\n\tsliceType$4 = $sliceType($Uint16);\n\tsliceType$5 = $sliceType($Uint32);\n\tarrayType = $arrayType($Uint8, 800);\n\tsliceType$6 = $sliceType($Uint8);\n\tarrayType$1 = $arrayType($Uint8, 24);\n\tarrayType$2 = $arrayType($Uint8, 32);\n\tptrType$1 = $ptrType(floatInfo);\n\tarrayType$3 = $arrayType($Uint8, 65);\n\tarrayType$4 = $arrayType($Uint8, 4);\n\tptrType$2 = $ptrType(decimal);\n\tptrType$3 = $ptrType(decimalSlice);\n\tptrType$4 = $ptrType(extFloat);\n\tdecimal.ptr.prototype.String = function() {\n\t\tvar $ptr, a, buf, n, w;\n\t\ta = this;\n\t\tn = 10 + a.nd >> 0;\n\t\tif (a.dp > 0) {\n\t\t\tn = n + (a.dp) >> 0;\n\t\t}\n\t\tif (a.dp < 0) {\n\t\t\tn = n + (-a.dp) >> 0;\n\t\t}\n\t\tbuf = $makeSlice(sliceType$6, n);\n\t\tw = 0;\n\t\tif ((a.nd === 0)) {\n\t\t\treturn \"0\";\n\t\t} else if (a.dp <= 0) {\n\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = 48);\n\t\t\tw = w + (1) >> 0;\n\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = 46);\n\t\t\tw = w + (1) >> 0;\n\t\t\tw = w + (digitZero($subslice(buf, w, (w + -a.dp >> 0)))) >> 0;\n\t\t\tw = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.nd))) >> 0;\n\t\t} else if (a.dp < a.nd) {\n\t\t\tw = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.dp))) >> 0;\n\t\t\t((w < 0 || w >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + w] = 46);\n\t\t\tw = w + (1) >> 0;\n\t\t\tw = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), a.dp, a.nd))) >> 0;\n\t\t} else {\n\t\t\tw = w + ($copySlice($subslice(buf, w), $subslice(new sliceType$6(a.d), 0, a.nd))) >> 0;\n\t\t\tw = w + (digitZero($subslice(buf, w, ((w + a.dp >> 0) - a.nd >> 0)))) >> 0;\n\t\t}\n\t\treturn $bytesToString($subslice(buf, 0, w));\n\t};\n\tdecimal.prototype.String = function() { return this.$val.String(); };\n\tdigitZero = function(dst) {\n\t\tvar $ptr, _i, _ref, dst, i;\n\t\t_ref = dst;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\t((i < 0 || i >= dst.$length) ? $throwRuntimeError(\"index out of range\") : dst.$array[dst.$offset + i] = 48);\n\t\t\t_i++;\n\t\t}\n\t\treturn dst.$length;\n\t};\n\ttrim = function(a) {\n\t\tvar $ptr, a, x, x$1;\n\t\twhile (true) {\n\t\t\tif (!(a.nd > 0 && ((x = a.d, x$1 = a.nd - 1 >> 0, ((x$1 < 0 || x$1 >= x.length) ? $throwRuntimeError(\"index out of range\") : x[x$1])) === 48))) { break; }\n\t\t\ta.nd = a.nd - (1) >> 0;\n\t\t}\n\t\tif (a.nd === 0) {\n\t\t\ta.dp = 0;\n\t\t}\n\t};\n\tdecimal.ptr.prototype.Assign = function(v) {\n\t\tvar $ptr, a, buf, n, v, v1, x, x$1, x$2;\n\t\ta = this;\n\t\tbuf = arrayType$1.zero();\n\t\tn = 0;\n\t\twhile (true) {\n\t\t\tif (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }\n\t\t\tv1 = $div64(v, new $Uint64(0, 10), false);\n\t\t\tv = (x = $mul64(new $Uint64(0, 10), v1), new $Uint64(v.$high - x.$high, v.$low - x.$low));\n\t\t\t((n < 0 || n >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[n] = (new $Uint64(v.$high + 0, v.$low + 48).$low << 24 >>> 24));\n\t\t\tn = n + (1) >> 0;\n\t\t\tv = v1;\n\t\t}\n\t\ta.nd = 0;\n\t\tn = n - (1) >> 0;\n\t\twhile (true) {\n\t\t\tif (!(n >= 0)) { break; }\n\t\t\t(x$1 = a.d, x$2 = a.nd, ((x$2 < 0 || x$2 >= x$1.length) ? $throwRuntimeError(\"index out of range\") : x$1[x$2] = ((n < 0 || n >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[n])));\n\t\t\ta.nd = a.nd + (1) >> 0;\n\t\t\tn = n - (1) >> 0;\n\t\t}\n\t\ta.dp = a.nd;\n\t\ttrim(a);\n\t};\n\tdecimal.prototype.Assign = function(v) { return this.$val.Assign(v); };\n\trightShift = function(a, k) {\n\t\tvar $ptr, a, c, c$1, dig, dig$1, k, n, r, w, x, x$1, x$2, x$3, y, y$1, y$2, y$3, y$4, y$5;\n\t\tr = 0;\n\t\tw = 0;\n\t\tn = 0;\n\t\twhile (true) {\n\t\t\tif (!(((y = k, y < 32 ? (n >>> y) : 0) >>> 0) === 0)) { break; }\n\t\t\tif (r >= a.nd) {\n\t\t\t\tif (n === 0) {\n\t\t\t\t\ta.nd = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(((y$1 = k, y$1 < 32 ? (n >>> y$1) : 0) >>> 0) === 0)) { break; }\n\t\t\t\t\tn = n * 10 >>> 0;\n\t\t\t\t\tr = r + (1) >> 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = ((x = a.d, ((r < 0 || r >= x.length) ? $throwRuntimeError(\"index out of range\") : x[r])) >>> 0);\n\t\t\tn = ((n * 10 >>> 0) + c >>> 0) - 48 >>> 0;\n\t\t\tr = r + (1) >> 0;\n\t\t}\n\t\ta.dp = a.dp - ((r - 1 >> 0)) >> 0;\n\t\twhile (true) {\n\t\t\tif (!(r < a.nd)) { break; }\n\t\t\tc$1 = ((x$1 = a.d, ((r < 0 || r >= x$1.length) ? $throwRuntimeError(\"index out of range\") : x$1[r])) >>> 0);\n\t\t\tdig = (y$2 = k, y$2 < 32 ? (n >>> y$2) : 0) >>> 0;\n\t\t\tn = n - (((y$3 = k, y$3 < 32 ? (dig << y$3) : 0) >>> 0)) >>> 0;\n\t\t\t(x$2 = a.d, ((w < 0 || w >= x$2.length) ? $throwRuntimeError(\"index out of range\") : x$2[w] = ((dig + 48 >>> 0) << 24 >>> 24)));\n\t\t\tw = w + (1) >> 0;\n\t\t\tn = ((n * 10 >>> 0) + c$1 >>> 0) - 48 >>> 0;\n\t\t\tr = r + (1) >> 0;\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!(n > 0)) { break; }\n\t\t\tdig$1 = (y$4 = k, y$4 < 32 ? (n >>> y$4) : 0) >>> 0;\n\t\t\tn = n - (((y$5 = k, y$5 < 32 ? (dig$1 << y$5) : 0) >>> 0)) >>> 0;\n\t\t\tif (w < 800) {\n\t\t\t\t(x$3 = a.d, ((w < 0 || w >= x$3.length) ? $throwRuntimeError(\"index out of range\") : x$3[w] = ((dig$1 + 48 >>> 0) << 24 >>> 24)));\n\t\t\t\tw = w + (1) >> 0;\n\t\t\t} else if (dig$1 > 0) {\n\t\t\t\ta.trunc = true;\n\t\t\t}\n\t\t\tn = n * 10 >>> 0;\n\t\t}\n\t\ta.nd = w;\n\t\ttrim(a);\n\t};\n\tprefixIsLessThan = function(b, s) {\n\t\tvar $ptr, b, i, s;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < s.length)) { break; }\n\t\t\tif (i >= b.$length) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!((((i < 0 || i >= b.$length) ? $throwRuntimeError(\"index out of range\") : b.$array[b.$offset + i]) === s.charCodeAt(i)))) {\n\t\t\t\treturn ((i < 0 || i >= b.$length) ? $throwRuntimeError(\"index out of range\") : b.$array[b.$offset + i]) < s.charCodeAt(i);\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\treturn false;\n\t};\n\tleftShift = function(a, k) {\n\t\tvar $ptr, _q, _q$1, a, delta, k, n, quo, quo$1, r, rem, rem$1, w, x, x$1, x$2, y;\n\t\tdelta = ((k < 0 || k >= leftcheats.$length) ? $throwRuntimeError(\"index out of range\") : leftcheats.$array[leftcheats.$offset + k]).delta;\n\t\tif (prefixIsLessThan($subslice(new sliceType$6(a.d), 0, a.nd), ((k < 0 || k >= leftcheats.$length) ? $throwRuntimeError(\"index out of range\") : leftcheats.$array[leftcheats.$offset + k]).cutoff)) {\n\t\t\tdelta = delta - (1) >> 0;\n\t\t}\n\t\tr = a.nd;\n\t\tw = a.nd + delta >> 0;\n\t\tn = 0;\n\t\tr = r - (1) >> 0;\n\t\twhile (true) {\n\t\t\tif (!(r >= 0)) { break; }\n\t\t\tn = n + (((y = k, y < 32 ? (((((x = a.d, ((r < 0 || r >= x.length) ? $throwRuntimeError(\"index out of range\") : x[r])) >>> 0) - 48 >>> 0)) << y) : 0) >>> 0)) >>> 0;\n\t\t\tquo = (_q = n / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\trem = n - (10 * quo >>> 0) >>> 0;\n\t\t\tw = w - (1) >> 0;\n\t\t\tif (w < 800) {\n\t\t\t\t(x$1 = a.d, ((w < 0 || w >= x$1.length) ? $throwRuntimeError(\"index out of range\") : x$1[w] = ((rem + 48 >>> 0) << 24 >>> 24)));\n\t\t\t} else if (!((rem === 0))) {\n\t\t\t\ta.trunc = true;\n\t\t\t}\n\t\t\tn = quo;\n\t\t\tr = r - (1) >> 0;\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!(n > 0)) { break; }\n\t\t\tquo$1 = (_q$1 = n / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\trem$1 = n - (10 * quo$1 >>> 0) >>> 0;\n\t\t\tw = w - (1) >> 0;\n\t\t\tif (w < 800) {\n\t\t\t\t(x$2 = a.d, ((w < 0 || w >= x$2.length) ? $throwRuntimeError(\"index out of range\") : x$2[w] = ((rem$1 + 48 >>> 0) << 24 >>> 24)));\n\t\t\t} else if (!((rem$1 === 0))) {\n\t\t\t\ta.trunc = true;\n\t\t\t}\n\t\t\tn = quo$1;\n\t\t}\n\t\ta.nd = a.nd + (delta) >> 0;\n\t\tif (a.nd >= 800) {\n\t\t\ta.nd = 800;\n\t\t}\n\t\ta.dp = a.dp + (delta) >> 0;\n\t\ttrim(a);\n\t};\n\tdecimal.ptr.prototype.Shift = function(k) {\n\t\tvar $ptr, a, k;\n\t\ta = this;\n\t\tif ((a.nd === 0)) {\n\t\t} else if (k > 0) {\n\t\t\twhile (true) {\n\t\t\t\tif (!(k > 28)) { break; }\n\t\t\t\tleftShift(a, 28);\n\t\t\t\tk = k - (28) >> 0;\n\t\t\t}\n\t\t\tleftShift(a, (k >>> 0));\n\t\t} else if (k < 0) {\n\t\t\twhile (true) {\n\t\t\t\tif (!(k < -28)) { break; }\n\t\t\t\trightShift(a, 28);\n\t\t\t\tk = k + (28) >> 0;\n\t\t\t}\n\t\t\trightShift(a, (-k >>> 0));\n\t\t}\n\t};\n\tdecimal.prototype.Shift = function(k) { return this.$val.Shift(k); };\n\tshouldRoundUp = function(a, nd) {\n\t\tvar $ptr, _r, a, nd, x, x$1, x$2, x$3;\n\t\tif (nd < 0 || nd >= a.nd) {\n\t\t\treturn false;\n\t\t}\n\t\tif (((x = a.d, ((nd < 0 || nd >= x.length) ? $throwRuntimeError(\"index out of range\") : x[nd])) === 53) && ((nd + 1 >> 0) === a.nd)) {\n\t\t\tif (a.trunc) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn nd > 0 && !(((_r = (((x$1 = a.d, x$2 = nd - 1 >> 0, ((x$2 < 0 || x$2 >= x$1.length) ? $throwRuntimeError(\"index out of range\") : x$1[x$2])) - 48 << 24 >>> 24)) % 2, _r === _r ? _r : $throwRuntimeError(\"integer divide by zero\")) === 0));\n\t\t}\n\t\treturn (x$3 = a.d, ((nd < 0 || nd >= x$3.length) ? $throwRuntimeError(\"index out of range\") : x$3[nd])) >= 53;\n\t};\n\tdecimal.ptr.prototype.Round = function(nd) {\n\t\tvar $ptr, a, nd;\n\t\ta = this;\n\t\tif (nd < 0 || nd >= a.nd) {\n\t\t\treturn;\n\t\t}\n\t\tif (shouldRoundUp(a, nd)) {\n\t\t\ta.RoundUp(nd);\n\t\t} else {\n\t\t\ta.RoundDown(nd);\n\t\t}\n\t};\n\tdecimal.prototype.Round = function(nd) { return this.$val.Round(nd); };\n\tdecimal.ptr.prototype.RoundDown = function(nd) {\n\t\tvar $ptr, a, nd;\n\t\ta = this;\n\t\tif (nd < 0 || nd >= a.nd) {\n\t\t\treturn;\n\t\t}\n\t\ta.nd = nd;\n\t\ttrim(a);\n\t};\n\tdecimal.prototype.RoundDown = function(nd) { return this.$val.RoundDown(nd); };\n\tdecimal.ptr.prototype.RoundUp = function(nd) {\n\t\tvar $ptr, a, c, i, nd, x, x$1, x$2;\n\t\ta = this;\n\t\tif (nd < 0 || nd >= a.nd) {\n\t\t\treturn;\n\t\t}\n\t\ti = nd - 1 >> 0;\n\t\twhile (true) {\n\t\t\tif (!(i >= 0)) { break; }\n\t\t\tc = (x = a.d, ((i < 0 || i >= x.length) ? $throwRuntimeError(\"index out of range\") : x[i]));\n\t\t\tif (c < 57) {\n\t\t\t\t(x$2 = a.d, ((i < 0 || i >= x$2.length) ? $throwRuntimeError(\"index out of range\") : x$2[i] = ((x$1 = a.d, ((i < 0 || i >= x$1.length) ? $throwRuntimeError(\"index out of range\") : x$1[i])) + (1) << 24 >>> 24)));\n\t\t\t\ta.nd = i + 1 >> 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti = i - (1) >> 0;\n\t\t}\n\t\ta.d[0] = 49;\n\t\ta.nd = 1;\n\t\ta.dp = a.dp + (1) >> 0;\n\t};\n\tdecimal.prototype.RoundUp = function(nd) { return this.$val.RoundUp(nd); };\n\tdecimal.ptr.prototype.RoundedInteger = function() {\n\t\tvar $ptr, a, i, n, x, x$1, x$2, x$3;\n\t\ta = this;\n\t\tif (a.dp > 20) {\n\t\t\treturn new $Uint64(4294967295, 4294967295);\n\t\t}\n\t\ti = 0;\n\t\tn = new $Uint64(0, 0);\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < a.dp && i < a.nd)) { break; }\n\t\t\tn = (x = $mul64(n, new $Uint64(0, 10)), x$1 = new $Uint64(0, ((x$2 = a.d, ((i < 0 || i >= x$2.length) ? $throwRuntimeError(\"index out of range\") : x$2[i])) - 48 << 24 >>> 24)), new $Uint64(x.$high + x$1.$high, x.$low + x$1.$low));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!(i < a.dp)) { break; }\n\t\t\tn = $mul64(n, (new $Uint64(0, 10)));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\tif (shouldRoundUp(a, a.dp)) {\n\t\t\tn = (x$3 = new $Uint64(0, 1), new $Uint64(n.$high + x$3.$high, n.$low + x$3.$low));\n\t\t}\n\t\treturn n;\n\t};\n\tdecimal.prototype.RoundedInteger = function() { return this.$val.RoundedInteger(); };\n\textFloat.ptr.prototype.AssignComputeBounds = function(mant, exp, neg, flt) {\n\t\tvar $ptr, _tmp, _tmp$1, exp, expBiased, f, flt, lower, mant, neg, upper, x, x$1, x$2, x$3, x$4;\n\t\tlower = new extFloat.ptr(new $Uint64(0, 0), 0, false);\n\t\tupper = new extFloat.ptr(new $Uint64(0, 0), 0, false);\n\t\tf = this;\n\t\tf.mant = mant;\n\t\tf.exp = exp - (flt.mantbits >> 0) >> 0;\n\t\tf.neg = neg;\n\t\tif (f.exp <= 0 && (x = $shiftLeft64(($shiftRightUint64(mant, (-f.exp >>> 0))), (-f.exp >>> 0)), (mant.$high === x.$high && mant.$low === x.$low))) {\n\t\t\tf.mant = $shiftRightUint64(f.mant, ((-f.exp >>> 0)));\n\t\t\tf.exp = 0;\n\t\t\t_tmp = $clone(f, extFloat);\n\t\t\t_tmp$1 = $clone(f, extFloat);\n\t\t\textFloat.copy(lower, _tmp);\n\t\t\textFloat.copy(upper, _tmp$1);\n\t\t\treturn [lower, upper];\n\t\t}\n\t\texpBiased = exp - flt.bias >> 0;\n\t\textFloat.copy(upper, new extFloat.ptr((x$1 = $mul64(new $Uint64(0, 2), f.mant), new $Uint64(x$1.$high + 0, x$1.$low + 1)), f.exp - 1 >> 0, f.neg));\n\t\tif (!((x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), (mant.$high === x$2.$high && mant.$low === x$2.$low))) || (expBiased === 1)) {\n\t\t\textFloat.copy(lower, new extFloat.ptr((x$3 = $mul64(new $Uint64(0, 2), f.mant), new $Uint64(x$3.$high - 0, x$3.$low - 1)), f.exp - 1 >> 0, f.neg));\n\t\t} else {\n\t\t\textFloat.copy(lower, new extFloat.ptr((x$4 = $mul64(new $Uint64(0, 4), f.mant), new $Uint64(x$4.$high - 0, x$4.$low - 1)), f.exp - 2 >> 0, f.neg));\n\t\t}\n\t\treturn [lower, upper];\n\t};\n\textFloat.prototype.AssignComputeBounds = function(mant, exp, neg, flt) { return this.$val.AssignComputeBounds(mant, exp, neg, flt); };\n\textFloat.ptr.prototype.Normalize = function() {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, exp, f, mant, shift, x, x$1, x$2, x$3, x$4, x$5;\n\t\tshift = 0;\n\t\tf = this;\n\t\t_tmp = f.mant;\n\t\t_tmp$1 = f.exp;\n\t\tmant = _tmp;\n\t\texp = _tmp$1;\n\t\tif ((mant.$high === 0 && mant.$low === 0)) {\n\t\t\tshift = 0;\n\t\t\treturn shift;\n\t\t}\n\t\tif ((x = $shiftRightUint64(mant, 32), (x.$high === 0 && x.$low === 0))) {\n\t\t\tmant = $shiftLeft64(mant, (32));\n\t\t\texp = exp - (32) >> 0;\n\t\t}\n\t\tif ((x$1 = $shiftRightUint64(mant, 48), (x$1.$high === 0 && x$1.$low === 0))) {\n\t\t\tmant = $shiftLeft64(mant, (16));\n\t\t\texp = exp - (16) >> 0;\n\t\t}\n\t\tif ((x$2 = $shiftRightUint64(mant, 56), (x$2.$high === 0 && x$2.$low === 0))) {\n\t\t\tmant = $shiftLeft64(mant, (8));\n\t\t\texp = exp - (8) >> 0;\n\t\t}\n\t\tif ((x$3 = $shiftRightUint64(mant, 60), (x$3.$high === 0 && x$3.$low === 0))) {\n\t\t\tmant = $shiftLeft64(mant, (4));\n\t\t\texp = exp - (4) >> 0;\n\t\t}\n\t\tif ((x$4 = $shiftRightUint64(mant, 62), (x$4.$high === 0 && x$4.$low === 0))) {\n\t\t\tmant = $shiftLeft64(mant, (2));\n\t\t\texp = exp - (2) >> 0;\n\t\t}\n\t\tif ((x$5 = $shiftRightUint64(mant, 63), (x$5.$high === 0 && x$5.$low === 0))) {\n\t\t\tmant = $shiftLeft64(mant, (1));\n\t\t\texp = exp - (1) >> 0;\n\t\t}\n\t\tshift = ((f.exp - exp >> 0) >>> 0);\n\t\t_tmp$2 = mant;\n\t\t_tmp$3 = exp;\n\t\tf.mant = _tmp$2;\n\t\tf.exp = _tmp$3;\n\t\treturn shift;\n\t};\n\textFloat.prototype.Normalize = function() { return this.$val.Normalize(); };\n\textFloat.ptr.prototype.Multiply = function(g) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, cross1, cross2, f, fhi, flo, g, ghi, glo, rem, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;\n\t\tf = this;\n\t\t_tmp = $shiftRightUint64(f.mant, 32);\n\t\t_tmp$1 = new $Uint64(0, (f.mant.$low >>> 0));\n\t\tfhi = _tmp;\n\t\tflo = _tmp$1;\n\t\t_tmp$2 = $shiftRightUint64(g.mant, 32);\n\t\t_tmp$3 = new $Uint64(0, (g.mant.$low >>> 0));\n\t\tghi = _tmp$2;\n\t\tglo = _tmp$3;\n\t\tcross1 = $mul64(fhi, glo);\n\t\tcross2 = $mul64(flo, ghi);\n\t\tf.mant = (x = (x$1 = $mul64(fhi, ghi), x$2 = $shiftRightUint64(cross1, 32), new $Uint64(x$1.$high + x$2.$high, x$1.$low + x$2.$low)), x$3 = $shiftRightUint64(cross2, 32), new $Uint64(x.$high + x$3.$high, x.$low + x$3.$low));\n\t\trem = (x$4 = (x$5 = new $Uint64(0, (cross1.$low >>> 0)), x$6 = new $Uint64(0, (cross2.$low >>> 0)), new $Uint64(x$5.$high + x$6.$high, x$5.$low + x$6.$low)), x$7 = $shiftRightUint64(($mul64(flo, glo)), 32), new $Uint64(x$4.$high + x$7.$high, x$4.$low + x$7.$low));\n\t\trem = (x$8 = new $Uint64(0, 2147483648), new $Uint64(rem.$high + x$8.$high, rem.$low + x$8.$low));\n\t\tf.mant = (x$9 = f.mant, x$10 = ($shiftRightUint64(rem, 32)), new $Uint64(x$9.$high + x$10.$high, x$9.$low + x$10.$low));\n\t\tf.exp = (f.exp + g.exp >> 0) + 64 >> 0;\n\t};\n\textFloat.prototype.Multiply = function(g) { return this.$val.Multiply(g); };\n\textFloat.ptr.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) {\n\t\tvar $ptr, _q, _r, adjExp, denormalExp, errors$1, exp10, extrabits, f, flt, halfway, i, mant_extra, mantissa, neg, ok, shift, trunc, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, y;\n\t\tok = false;\n\t\tf = this;\n\t\terrors$1 = 0;\n\t\tif (trunc) {\n\t\t\terrors$1 = errors$1 + (4) >> 0;\n\t\t}\n\t\tf.mant = mantissa;\n\t\tf.exp = 0;\n\t\tf.neg = neg;\n\t\ti = (_q = ((exp10 - -348 >> 0)) / 8, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tif (exp10 < -348 || i >= 87) {\n\t\t\tok = false;\n\t\t\treturn ok;\n\t\t}\n\t\tadjExp = (_r = ((exp10 - -348 >> 0)) % 8, _r === _r ? _r : $throwRuntimeError(\"integer divide by zero\"));\n\t\tif (adjExp < 19 && (x = (x$1 = 19 - adjExp >> 0, ((x$1 < 0 || x$1 >= uint64pow10.length) ? $throwRuntimeError(\"index out of range\") : uint64pow10[x$1])), (mantissa.$high < x.$high || (mantissa.$high === x.$high && mantissa.$low < x.$low)))) {\n\t\t\tf.mant = $mul64(f.mant, (((adjExp < 0 || adjExp >= uint64pow10.length) ? $throwRuntimeError(\"index out of range\") : uint64pow10[adjExp])));\n\t\t\tf.Normalize();\n\t\t} else {\n\t\t\tf.Normalize();\n\t\t\tf.Multiply($clone(((adjExp < 0 || adjExp >= smallPowersOfTen.length) ? $throwRuntimeError(\"index out of range\") : smallPowersOfTen[adjExp]), extFloat));\n\t\t\terrors$1 = errors$1 + (4) >> 0;\n\t\t}\n\t\tf.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? $throwRuntimeError(\"index out of range\") : powersOfTen[i]), extFloat));\n\t\tif (errors$1 > 0) {\n\t\t\terrors$1 = errors$1 + (1) >> 0;\n\t\t}\n\t\terrors$1 = errors$1 + (4) >> 0;\n\t\tshift = f.Normalize();\n\t\terrors$1 = (y = (shift), y < 32 ? (errors$1 << y) : 0) >> 0;\n\t\tdenormalExp = flt.bias - 63 >> 0;\n\t\textrabits = 0;\n\t\tif (f.exp <= denormalExp) {\n\t\t\textrabits = ((63 - flt.mantbits >>> 0) + 1 >>> 0) + ((denormalExp - f.exp >> 0) >>> 0) >>> 0;\n\t\t} else {\n\t\t\textrabits = 63 - flt.mantbits >>> 0;\n\t\t}\n\t\thalfway = $shiftLeft64(new $Uint64(0, 1), ((extrabits - 1 >>> 0)));\n\t\tmant_extra = (x$2 = f.mant, x$3 = (x$4 = $shiftLeft64(new $Uint64(0, 1), extrabits), new $Uint64(x$4.$high - 0, x$4.$low - 1)), new $Uint64(x$2.$high & x$3.$high, (x$2.$low & x$3.$low) >>> 0));\n\t\tif ((x$5 = (x$6 = new $Int64(halfway.$high, halfway.$low), x$7 = new $Int64(0, errors$1), new $Int64(x$6.$high - x$7.$high, x$6.$low - x$7.$low)), x$8 = new $Int64(mant_extra.$high, mant_extra.$low), (x$5.$high < x$8.$high || (x$5.$high === x$8.$high && x$5.$low < x$8.$low))) && (x$9 = new $Int64(mant_extra.$high, mant_extra.$low), x$10 = (x$11 = new $Int64(halfway.$high, halfway.$low), x$12 = new $Int64(0, errors$1), new $Int64(x$11.$high + x$12.$high, x$11.$low + x$12.$low)), (x$9.$high < x$10.$high || (x$9.$high === x$10.$high && x$9.$low < x$10.$low)))) {\n\t\t\tok = false;\n\t\t\treturn ok;\n\t\t}\n\t\tok = true;\n\t\treturn ok;\n\t};\n\textFloat.prototype.AssignDecimal = function(mantissa, exp10, neg, trunc, flt) { return this.$val.AssignDecimal(mantissa, exp10, neg, trunc, flt); };\n\textFloat.ptr.prototype.frexp10 = function() {\n\t\tvar $ptr, _q, _q$1, _tmp, _tmp$1, approxExp10, exp, exp10, f, i, index;\n\t\texp10 = 0;\n\t\tindex = 0;\n\t\tf = this;\n\t\tapproxExp10 = (_q = ($imul(((-46 - f.exp >> 0)), 28)) / 93, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\ti = (_q$1 = ((approxExp10 - -348 >> 0)) / 8, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\tLoop:\n\t\twhile (true) {\n\t\t\texp = (f.exp + ((i < 0 || i >= powersOfTen.length) ? $throwRuntimeError(\"index out of range\") : powersOfTen[i]).exp >> 0) + 64 >> 0;\n\t\t\tif (exp < -60) {\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t} else if (exp > -32) {\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t} else {\n\t\t\t\tbreak Loop;\n\t\t\t}\n\t\t}\n\t\tf.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? $throwRuntimeError(\"index out of range\") : powersOfTen[i]), extFloat));\n\t\t_tmp = -((-348 + ($imul(i, 8)) >> 0));\n\t\t_tmp$1 = i;\n\t\texp10 = _tmp;\n\t\tindex = _tmp$1;\n\t\treturn [exp10, index];\n\t};\n\textFloat.prototype.frexp10 = function() { return this.$val.frexp10(); };\n\tfrexp10Many = function(a, b, c) {\n\t\tvar $ptr, _tuple, a, b, c, exp10, i;\n\t\texp10 = 0;\n\t\t_tuple = c.frexp10();\n\t\texp10 = _tuple[0];\n\t\ti = _tuple[1];\n\t\ta.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? $throwRuntimeError(\"index out of range\") : powersOfTen[i]), extFloat));\n\t\tb.Multiply($clone(((i < 0 || i >= powersOfTen.length) ? $throwRuntimeError(\"index out of range\") : powersOfTen[i]), extFloat));\n\t\treturn exp10;\n\t};\n\textFloat.ptr.prototype.FixedDecimal = function(d, n) {\n\t\tvar $CE$B5, $ptr, _q, _q$1, _tmp, _tmp$1, _tuple, buf, d, digit, exp10, f, fraction, i, i$1, i$2, integer, integerDigits, n, nd, needed, ok, pos, pow, pow10, rest, shift, v, v1, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;\n\t\tf = this;\n\t\tif ((x = f.mant, (x.$high === 0 && x.$low === 0))) {\n\t\t\td.nd = 0;\n\t\t\td.dp = 0;\n\t\t\td.neg = f.neg;\n\t\t\treturn true;\n\t\t}\n\t\tif (n === 0) {\n\t\t\t$panic(new $String(\"strconv: internal error: extFloat.FixedDecimal called with n == 0\"));\n\t\t}\n\t\tf.Normalize();\n\t\t_tuple = f.frexp10();\n\t\texp10 = _tuple[0];\n\t\tshift = (-f.exp >>> 0);\n\t\tinteger = ($shiftRightUint64(f.mant, shift).$low >>> 0);\n\t\tfraction = (x$1 = f.mant, x$2 = $shiftLeft64(new $Uint64(0, integer), shift), new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));\n\t\t$CE$B5 = new $Uint64(0, 1);\n\t\tneeded = n;\n\t\tintegerDigits = 0;\n\t\tpow10 = new $Uint64(0, 1);\n\t\t_tmp = 0;\n\t\t_tmp$1 = new $Uint64(0, 1);\n\t\ti = _tmp;\n\t\tpow = _tmp$1;\n\t\twhile (true) {\n\t\t\tif (!(i < 20)) { break; }\n\t\t\tif ((x$3 = new $Uint64(0, integer), (pow.$high > x$3.$high || (pow.$high === x$3.$high && pow.$low > x$3.$low)))) {\n\t\t\t\tintegerDigits = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpow = $mul64(pow, (new $Uint64(0, 10)));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\trest = integer;\n\t\tif (integerDigits > needed) {\n\t\t\tpow10 = (x$4 = integerDigits - needed >> 0, ((x$4 < 0 || x$4 >= uint64pow10.length) ? $throwRuntimeError(\"index out of range\") : uint64pow10[x$4]));\n\t\t\tinteger = (_q = integer / ((pow10.$low >>> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\trest = rest - (($imul(integer, (pow10.$low >>> 0)) >>> 0)) >>> 0;\n\t\t} else {\n\t\t\trest = 0;\n\t\t}\n\t\tbuf = arrayType$2.zero();\n\t\tpos = 32;\n\t\tv = integer;\n\t\twhile (true) {\n\t\t\tif (!(v > 0)) { break; }\n\t\t\tv1 = (_q$1 = v / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\tv = v - (($imul(10, v1) >>> 0)) >>> 0;\n\t\t\tpos = pos - (1) >> 0;\n\t\t\t((pos < 0 || pos >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[pos] = ((v + 48 >>> 0) << 24 >>> 24));\n\t\t\tv = v1;\n\t\t}\n\t\ti$1 = pos;\n\t\twhile (true) {\n\t\t\tif (!(i$1 < 32)) { break; }\n\t\t\t(x$5 = d.d, x$6 = i$1 - pos >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? $throwRuntimeError(\"index out of range\") : x$5.$array[x$5.$offset + x$6] = ((i$1 < 0 || i$1 >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[i$1])));\n\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t}\n\t\tnd = 32 - pos >> 0;\n\t\td.nd = nd;\n\t\td.dp = integerDigits + exp10 >> 0;\n\t\tneeded = needed - (nd) >> 0;\n\t\tif (needed > 0) {\n\t\t\tif (!((rest === 0)) || !((pow10.$high === 0 && pow10.$low === 1))) {\n\t\t\t\t$panic(new $String(\"strconv: internal error, rest != 0 but needed > 0\"));\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (!(needed > 0)) { break; }\n\t\t\t\tfraction = $mul64(fraction, (new $Uint64(0, 10)));\n\t\t\t\t$CE$B5 = $mul64($CE$B5, (new $Uint64(0, 10)));\n\t\t\t\tif ((x$7 = $mul64(new $Uint64(0, 2), $CE$B5), x$8 = $shiftLeft64(new $Uint64(0, 1), shift), (x$7.$high > x$8.$high || (x$7.$high === x$8.$high && x$7.$low > x$8.$low)))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tdigit = $shiftRightUint64(fraction, shift);\n\t\t\t\t(x$9 = d.d, ((nd < 0 || nd >= x$9.$length) ? $throwRuntimeError(\"index out of range\") : x$9.$array[x$9.$offset + nd] = (new $Uint64(digit.$high + 0, digit.$low + 48).$low << 24 >>> 24)));\n\t\t\t\tfraction = (x$10 = $shiftLeft64(digit, shift), new $Uint64(fraction.$high - x$10.$high, fraction.$low - x$10.$low));\n\t\t\t\tnd = nd + (1) >> 0;\n\t\t\t\tneeded = needed - (1) >> 0;\n\t\t\t}\n\t\t\td.nd = nd;\n\t\t}\n\t\tok = adjustLastDigitFixed(d, (x$11 = $shiftLeft64(new $Uint64(0, rest), shift), new $Uint64(x$11.$high | fraction.$high, (x$11.$low | fraction.$low) >>> 0)), pow10, shift, $CE$B5);\n\t\tif (!ok) {\n\t\t\treturn false;\n\t\t}\n\t\ti$2 = d.nd - 1 >> 0;\n\t\twhile (true) {\n\t\t\tif (!(i$2 >= 0)) { break; }\n\t\t\tif (!(((x$12 = d.d, ((i$2 < 0 || i$2 >= x$12.$length) ? $throwRuntimeError(\"index out of range\") : x$12.$array[x$12.$offset + i$2])) === 48))) {\n\t\t\t\td.nd = i$2 + 1 >> 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti$2 = i$2 - (1) >> 0;\n\t\t}\n\t\treturn true;\n\t};\n\textFloat.prototype.FixedDecimal = function(d, n) { return this.$val.FixedDecimal(d, n); };\n\tadjustLastDigitFixed = function(d, num, den, shift, $CE$B5) {\n\t\tvar $CE$B5, $ptr, d, den, i, num, shift, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;\n\t\tif ((x = $shiftLeft64(den, shift), (num.$high > x.$high || (num.$high === x.$high && num.$low > x.$low)))) {\n\t\t\t$panic(new $String(\"strconv: num > den<<shift in adjustLastDigitFixed\"));\n\t\t}\n\t\tif ((x$1 = $mul64(new $Uint64(0, 2), $CE$B5), x$2 = $shiftLeft64(den, shift), (x$1.$high > x$2.$high || (x$1.$high === x$2.$high && x$1.$low > x$2.$low)))) {\n\t\t\t$panic(new $String(\"strconv: \\xCE\\xB5 > (den<<shift)/2\"));\n\t\t}\n\t\tif ((x$3 = $mul64(new $Uint64(0, 2), (new $Uint64(num.$high + $CE$B5.$high, num.$low + $CE$B5.$low))), x$4 = $shiftLeft64(den, shift), (x$3.$high < x$4.$high || (x$3.$high === x$4.$high && x$3.$low < x$4.$low)))) {\n\t\t\treturn true;\n\t\t}\n\t\tif ((x$5 = $mul64(new $Uint64(0, 2), (new $Uint64(num.$high - $CE$B5.$high, num.$low - $CE$B5.$low))), x$6 = $shiftLeft64(den, shift), (x$5.$high > x$6.$high || (x$5.$high === x$6.$high && x$5.$low > x$6.$low)))) {\n\t\t\ti = d.nd - 1 >> 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i >= 0)) { break; }\n\t\t\t\tif ((x$7 = d.d, ((i < 0 || i >= x$7.$length) ? $throwRuntimeError(\"index out of range\") : x$7.$array[x$7.$offset + i])) === 57) {\n\t\t\t\t\td.nd = d.nd - (1) >> 0;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t}\n\t\t\tif (i < 0) {\n\t\t\t\t(x$8 = d.d, (0 >= x$8.$length ? $throwRuntimeError(\"index out of range\") : x$8.$array[x$8.$offset + 0] = 49));\n\t\t\t\td.nd = 1;\n\t\t\t\td.dp = d.dp + (1) >> 0;\n\t\t\t} else {\n\t\t\t\t(x$10 = d.d, ((i < 0 || i >= x$10.$length) ? $throwRuntimeError(\"index out of range\") : x$10.$array[x$10.$offset + i] = ((x$9 = d.d, ((i < 0 || i >= x$9.$length) ? $throwRuntimeError(\"index out of range\") : x$9.$array[x$9.$offset + i])) + (1) << 24 >>> 24)));\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\textFloat.ptr.prototype.ShortestDecimal = function(d, lower, upper) {\n\t\tvar $ptr, _q, _tmp, _tmp$1, _tmp$2, _tmp$3, allowance, buf, currentDiff, d, digit, digit$1, exp10, f, fraction, i, i$1, i$2, integer, integerDigits, lower, multiplier, n, nd, pow, pow$1, shift, targetDiff, upper, v, v1, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$22, x$23, x$3, x$4, x$5, x$6, x$7, x$8, x$9;\n\t\tf = this;\n\t\tif ((x = f.mant, (x.$high === 0 && x.$low === 0))) {\n\t\t\td.nd = 0;\n\t\t\td.dp = 0;\n\t\t\td.neg = f.neg;\n\t\t\treturn true;\n\t\t}\n\t\tif ((f.exp === 0) && $equal(lower, f, extFloat) && $equal(lower, upper, extFloat)) {\n\t\t\tbuf = arrayType$1.zero();\n\t\t\tn = 23;\n\t\t\tv = f.mant;\n\t\t\twhile (true) {\n\t\t\t\tif (!((v.$high > 0 || (v.$high === 0 && v.$low > 0)))) { break; }\n\t\t\t\tv1 = $div64(v, new $Uint64(0, 10), false);\n\t\t\t\tv = (x$1 = $mul64(new $Uint64(0, 10), v1), new $Uint64(v.$high - x$1.$high, v.$low - x$1.$low));\n\t\t\t\t((n < 0 || n >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[n] = (new $Uint64(v.$high + 0, v.$low + 48).$low << 24 >>> 24));\n\t\t\t\tn = n - (1) >> 0;\n\t\t\t\tv = v1;\n\t\t\t}\n\t\t\tnd = (24 - n >> 0) - 1 >> 0;\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < nd)) { break; }\n\t\t\t\t(x$3 = d.d, ((i < 0 || i >= x$3.$length) ? $throwRuntimeError(\"index out of range\") : x$3.$array[x$3.$offset + i] = (x$2 = (n + 1 >> 0) + i >> 0, ((x$2 < 0 || x$2 >= buf.length) ? $throwRuntimeError(\"index out of range\") : buf[x$2]))));\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\t_tmp = nd;\n\t\t\t_tmp$1 = nd;\n\t\t\td.nd = _tmp;\n\t\t\td.dp = _tmp$1;\n\t\t\twhile (true) {\n\t\t\t\tif (!(d.nd > 0 && ((x$4 = d.d, x$5 = d.nd - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? $throwRuntimeError(\"index out of range\") : x$4.$array[x$4.$offset + x$5])) === 48))) { break; }\n\t\t\t\td.nd = d.nd - (1) >> 0;\n\t\t\t}\n\t\t\tif (d.nd === 0) {\n\t\t\t\td.dp = 0;\n\t\t\t}\n\t\t\td.neg = f.neg;\n\t\t\treturn true;\n\t\t}\n\t\tupper.Normalize();\n\t\tif (f.exp > upper.exp) {\n\t\t\tf.mant = $shiftLeft64(f.mant, (((f.exp - upper.exp >> 0) >>> 0)));\n\t\t\tf.exp = upper.exp;\n\t\t}\n\t\tif (lower.exp > upper.exp) {\n\t\t\tlower.mant = $shiftLeft64(lower.mant, (((lower.exp - upper.exp >> 0) >>> 0)));\n\t\t\tlower.exp = upper.exp;\n\t\t}\n\t\texp10 = frexp10Many(lower, f, upper);\n\t\tupper.mant = (x$6 = upper.mant, x$7 = new $Uint64(0, 1), new $Uint64(x$6.$high + x$7.$high, x$6.$low + x$7.$low));\n\t\tlower.mant = (x$8 = lower.mant, x$9 = new $Uint64(0, 1), new $Uint64(x$8.$high - x$9.$high, x$8.$low - x$9.$low));\n\t\tshift = (-upper.exp >>> 0);\n\t\tinteger = ($shiftRightUint64(upper.mant, shift).$low >>> 0);\n\t\tfraction = (x$10 = upper.mant, x$11 = $shiftLeft64(new $Uint64(0, integer), shift), new $Uint64(x$10.$high - x$11.$high, x$10.$low - x$11.$low));\n\t\tallowance = (x$12 = upper.mant, x$13 = lower.mant, new $Uint64(x$12.$high - x$13.$high, x$12.$low - x$13.$low));\n\t\ttargetDiff = (x$14 = upper.mant, x$15 = f.mant, new $Uint64(x$14.$high - x$15.$high, x$14.$low - x$15.$low));\n\t\tintegerDigits = 0;\n\t\t_tmp$2 = 0;\n\t\t_tmp$3 = new $Uint64(0, 1);\n\t\ti$1 = _tmp$2;\n\t\tpow = _tmp$3;\n\t\twhile (true) {\n\t\t\tif (!(i$1 < 20)) { break; }\n\t\t\tif ((x$16 = new $Uint64(0, integer), (pow.$high > x$16.$high || (pow.$high === x$16.$high && pow.$low > x$16.$low)))) {\n\t\t\t\tintegerDigits = i$1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpow = $mul64(pow, (new $Uint64(0, 10)));\n\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t}\n\t\ti$2 = 0;\n\t\twhile (true) {\n\t\t\tif (!(i$2 < integerDigits)) { break; }\n\t\t\tpow$1 = (x$17 = (integerDigits - i$2 >> 0) - 1 >> 0, ((x$17 < 0 || x$17 >= uint64pow10.length) ? $throwRuntimeError(\"index out of range\") : uint64pow10[x$17]));\n\t\t\tdigit = (_q = integer / (pow$1.$low >>> 0), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t(x$18 = d.d, ((i$2 < 0 || i$2 >= x$18.$length) ? $throwRuntimeError(\"index out of range\") : x$18.$array[x$18.$offset + i$2] = ((digit + 48 >>> 0) << 24 >>> 24)));\n\t\t\tinteger = integer - (($imul(digit, (pow$1.$low >>> 0)) >>> 0)) >>> 0;\n\t\t\tcurrentDiff = (x$19 = $shiftLeft64(new $Uint64(0, integer), shift), new $Uint64(x$19.$high + fraction.$high, x$19.$low + fraction.$low));\n\t\t\tif ((currentDiff.$high < allowance.$high || (currentDiff.$high === allowance.$high && currentDiff.$low < allowance.$low))) {\n\t\t\t\td.nd = i$2 + 1 >> 0;\n\t\t\t\td.dp = integerDigits + exp10 >> 0;\n\t\t\t\td.neg = f.neg;\n\t\t\t\treturn adjustLastDigit(d, currentDiff, targetDiff, allowance, $shiftLeft64(pow$1, shift), new $Uint64(0, 2));\n\t\t\t}\n\t\t\ti$2 = i$2 + (1) >> 0;\n\t\t}\n\t\td.nd = integerDigits;\n\t\td.dp = d.nd + exp10 >> 0;\n\t\td.neg = f.neg;\n\t\tdigit$1 = 0;\n\t\tmultiplier = new $Uint64(0, 1);\n\t\twhile (true) {\n\t\t\tfraction = $mul64(fraction, (new $Uint64(0, 10)));\n\t\t\tmultiplier = $mul64(multiplier, (new $Uint64(0, 10)));\n\t\t\tdigit$1 = ($shiftRightUint64(fraction, shift).$low >> 0);\n\t\t\t(x$20 = d.d, x$21 = d.nd, ((x$21 < 0 || x$21 >= x$20.$length) ? $throwRuntimeError(\"index out of range\") : x$20.$array[x$20.$offset + x$21] = ((digit$1 + 48 >> 0) << 24 >>> 24)));\n\t\t\td.nd = d.nd + (1) >> 0;\n\t\t\tfraction = (x$22 = $shiftLeft64(new $Uint64(0, digit$1), shift), new $Uint64(fraction.$high - x$22.$high, fraction.$low - x$22.$low));\n\t\t\tif ((x$23 = $mul64(allowance, multiplier), (fraction.$high < x$23.$high || (fraction.$high === x$23.$high && fraction.$low < x$23.$low)))) {\n\t\t\t\treturn adjustLastDigit(d, fraction, $mul64(targetDiff, multiplier), $mul64(allowance, multiplier), $shiftLeft64(new $Uint64(0, 1), shift), $mul64(multiplier, new $Uint64(0, 2)));\n\t\t\t}\n\t\t}\n\t};\n\textFloat.prototype.ShortestDecimal = function(d, lower, upper) { return this.$val.ShortestDecimal(d, lower, upper); };\n\tadjustLastDigit = function(d, currentDiff, targetDiff, maxDiff, ulpDecimal, ulpBinary) {\n\t\tvar $ptr, _index, currentDiff, d, maxDiff, targetDiff, ulpBinary, ulpDecimal, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;\n\t\tif ((x = $mul64(new $Uint64(0, 2), ulpBinary), (ulpDecimal.$high < x.$high || (ulpDecimal.$high === x.$high && ulpDecimal.$low < x.$low)))) {\n\t\t\treturn false;\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!((x$1 = (x$2 = (x$3 = $div64(ulpDecimal, new $Uint64(0, 2), false), new $Uint64(currentDiff.$high + x$3.$high, currentDiff.$low + x$3.$low)), new $Uint64(x$2.$high + ulpBinary.$high, x$2.$low + ulpBinary.$low)), (x$1.$high < targetDiff.$high || (x$1.$high === targetDiff.$high && x$1.$low < targetDiff.$low))))) { break; }\n\t\t\t_index = d.nd - 1 >> 0;\n\t\t\t(x$5 = d.d, ((_index < 0 || _index >= x$5.$length) ? $throwRuntimeError(\"index out of range\") : x$5.$array[x$5.$offset + _index] = ((x$4 = d.d, ((_index < 0 || _index >= x$4.$length) ? $throwRuntimeError(\"index out of range\") : x$4.$array[x$4.$offset + _index])) - (1) << 24 >>> 24)));\n\t\t\tcurrentDiff = (x$6 = ulpDecimal, new $Uint64(currentDiff.$high + x$6.$high, currentDiff.$low + x$6.$low));\n\t\t}\n\t\tif ((x$7 = new $Uint64(currentDiff.$high + ulpDecimal.$high, currentDiff.$low + ulpDecimal.$low), x$8 = (x$9 = (x$10 = $div64(ulpDecimal, new $Uint64(0, 2), false), new $Uint64(targetDiff.$high + x$10.$high, targetDiff.$low + x$10.$low)), new $Uint64(x$9.$high + ulpBinary.$high, x$9.$low + ulpBinary.$low)), (x$7.$high < x$8.$high || (x$7.$high === x$8.$high && x$7.$low <= x$8.$low)))) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((currentDiff.$high < ulpBinary.$high || (currentDiff.$high === ulpBinary.$high && currentDiff.$low < ulpBinary.$low)) || (x$11 = new $Uint64(maxDiff.$high - ulpBinary.$high, maxDiff.$low - ulpBinary.$low), (currentDiff.$high > x$11.$high || (currentDiff.$high === x$11.$high && currentDiff.$low > x$11.$low)))) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((d.nd === 1) && ((x$12 = d.d, (0 >= x$12.$length ? $throwRuntimeError(\"index out of range\") : x$12.$array[x$12.$offset + 0])) === 48)) {\n\t\t\td.nd = 0;\n\t\t\td.dp = 0;\n\t\t}\n\t\treturn true;\n\t};\n\tAppendFloat = function(dst, f, fmt, prec, bitSize) {\n\t\tvar $ptr, bitSize, dst, f, fmt, prec;\n\t\treturn genericFtoa(dst, f, fmt, prec, bitSize);\n\t};\n\t$pkg.AppendFloat = AppendFloat;\n\tgenericFtoa = function(dst, val, fmt, prec, bitSize) {\n\t\tvar $ptr, _1, _2, _3, _4, _tuple, bitSize, bits, buf, buf$1, digits, digs, dst, exp, f, f$1, flt, fmt, lower, mant, neg, ok, prec, s, shortest, upper, val, x, x$1, x$2, x$3, y, y$1;\n\t\tbits = new $Uint64(0, 0);\n\t\tflt = ptrType$1.nil;\n\t\t_1 = bitSize;\n\t\tif (_1 === (32)) {\n\t\t\tbits = new $Uint64(0, math.Float32bits($fround(val)));\n\t\t\tflt = float32info;\n\t\t} else if (_1 === (64)) {\n\t\t\tbits = math.Float64bits(val);\n\t\t\tflt = float64info;\n\t\t} else {\n\t\t\t$panic(new $String(\"strconv: illegal AppendFloat/FormatFloat bitSize\"));\n\t\t}\n\t\tneg = !((x = $shiftRightUint64(bits, ((flt.expbits + flt.mantbits >>> 0))), (x.$high === 0 && x.$low === 0)));\n\t\texp = ($shiftRightUint64(bits, flt.mantbits).$low >> 0) & ((((y = flt.expbits, y < 32 ? (1 << y) : 0) >> 0) - 1 >> 0));\n\t\tmant = (x$1 = (x$2 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(x$2.$high - 0, x$2.$low - 1)), new $Uint64(bits.$high & x$1.$high, (bits.$low & x$1.$low) >>> 0));\n\t\t_2 = exp;\n\t\tif (_2 === ((((y$1 = flt.expbits, y$1 < 32 ? (1 << y$1) : 0) >> 0) - 1 >> 0))) {\n\t\t\ts = \"\";\n\t\t\tif (!((mant.$high === 0 && mant.$low === 0))) {\n\t\t\t\ts = \"NaN\";\n\t\t\t} else if (neg) {\n\t\t\t\ts = \"-Inf\";\n\t\t\t} else {\n\t\t\t\ts = \"+Inf\";\n\t\t\t}\n\t\t\treturn $appendSlice(dst, s);\n\t\t} else if (_2 === (0)) {\n\t\t\texp = exp + (1) >> 0;\n\t\t} else {\n\t\t\tmant = (x$3 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), new $Uint64(mant.$high | x$3.$high, (mant.$low | x$3.$low) >>> 0));\n\t\t}\n\t\texp = exp + (flt.bias) >> 0;\n\t\tif (fmt === 98) {\n\t\t\treturn fmtB(dst, neg, mant, exp, flt);\n\t\t}\n\t\tif (!optimize) {\n\t\t\treturn bigFtoa(dst, prec, fmt, neg, mant, exp, flt);\n\t\t}\n\t\tdigs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);\n\t\tok = false;\n\t\tshortest = prec < 0;\n\t\tif (shortest) {\n\t\t\tf = new extFloat.ptr(new $Uint64(0, 0), 0, false);\n\t\t\t_tuple = f.AssignComputeBounds(mant, exp, neg, flt);\n\t\t\tlower = $clone(_tuple[0], extFloat);\n\t\t\tupper = $clone(_tuple[1], extFloat);\n\t\t\tbuf = arrayType$2.zero();\n\t\t\tdigs.d = new sliceType$6(buf);\n\t\t\tok = f.ShortestDecimal(digs, lower, upper);\n\t\t\tif (!ok) {\n\t\t\t\treturn bigFtoa(dst, prec, fmt, neg, mant, exp, flt);\n\t\t\t}\n\t\t\t_3 = fmt;\n\t\t\tif ((_3 === (101)) || (_3 === (69))) {\n\t\t\t\tprec = max(digs.nd - 1 >> 0, 0);\n\t\t\t} else if (_3 === (102)) {\n\t\t\t\tprec = max(digs.nd - digs.dp >> 0, 0);\n\t\t\t} else if ((_3 === (103)) || (_3 === (71))) {\n\t\t\t\tprec = digs.nd;\n\t\t\t}\n\t\t} else if (!((fmt === 102))) {\n\t\t\tdigits = prec;\n\t\t\t_4 = fmt;\n\t\t\tif ((_4 === (101)) || (_4 === (69))) {\n\t\t\t\tdigits = digits + (1) >> 0;\n\t\t\t} else if ((_4 === (103)) || (_4 === (71))) {\n\t\t\t\tif (prec === 0) {\n\t\t\t\t\tprec = 1;\n\t\t\t\t}\n\t\t\t\tdigits = prec;\n\t\t\t}\n\t\t\tif (digits <= 15) {\n\t\t\t\tbuf$1 = arrayType$1.zero();\n\t\t\t\tdigs.d = new sliceType$6(buf$1);\n\t\t\t\tf$1 = new extFloat.ptr(mant, exp - (flt.mantbits >> 0) >> 0, neg);\n\t\t\t\tok = f$1.FixedDecimal(digs, digits);\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\treturn bigFtoa(dst, prec, fmt, neg, mant, exp, flt);\n\t\t}\n\t\treturn formatDigits(dst, shortest, neg, $clone(digs, decimalSlice), prec, fmt);\n\t};\n\tbigFtoa = function(dst, prec, fmt, neg, mant, exp, flt) {\n\t\tvar $ptr, _1, _2, d, digs, dst, exp, flt, fmt, mant, neg, prec, shortest;\n\t\td = new decimal.ptr(arrayType.zero(), 0, 0, false, false);\n\t\td.Assign(mant);\n\t\td.Shift(exp - (flt.mantbits >> 0) >> 0);\n\t\tdigs = new decimalSlice.ptr(sliceType$6.nil, 0, 0, false);\n\t\tshortest = prec < 0;\n\t\tif (shortest) {\n\t\t\troundShortest(d, mant, exp, flt);\n\t\t\tdecimalSlice.copy(digs, new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false));\n\t\t\t_1 = fmt;\n\t\t\tif ((_1 === (101)) || (_1 === (69))) {\n\t\t\t\tprec = digs.nd - 1 >> 0;\n\t\t\t} else if (_1 === (102)) {\n\t\t\t\tprec = max(digs.nd - digs.dp >> 0, 0);\n\t\t\t} else if ((_1 === (103)) || (_1 === (71))) {\n\t\t\t\tprec = digs.nd;\n\t\t\t}\n\t\t} else {\n\t\t\t_2 = fmt;\n\t\t\tif ((_2 === (101)) || (_2 === (69))) {\n\t\t\t\td.Round(prec + 1 >> 0);\n\t\t\t} else if (_2 === (102)) {\n\t\t\t\td.Round(d.dp + prec >> 0);\n\t\t\t} else if ((_2 === (103)) || (_2 === (71))) {\n\t\t\t\tif (prec === 0) {\n\t\t\t\t\tprec = 1;\n\t\t\t\t}\n\t\t\t\td.Round(prec);\n\t\t\t}\n\t\t\tdecimalSlice.copy(digs, new decimalSlice.ptr(new sliceType$6(d.d), d.nd, d.dp, false));\n\t\t}\n\t\treturn formatDigits(dst, shortest, neg, $clone(digs, decimalSlice), prec, fmt);\n\t};\n\tformatDigits = function(dst, shortest, neg, digs, prec, fmt) {\n\t\tvar $ptr, _1, digs, dst, eprec, exp, fmt, neg, prec, shortest;\n\t\t_1 = fmt;\n\t\tif ((_1 === (101)) || (_1 === (69))) {\n\t\t\treturn fmtE(dst, neg, $clone(digs, decimalSlice), prec, fmt);\n\t\t} else if (_1 === (102)) {\n\t\t\treturn fmtF(dst, neg, $clone(digs, decimalSlice), prec);\n\t\t} else if ((_1 === (103)) || (_1 === (71))) {\n\t\t\teprec = prec;\n\t\t\tif (eprec > digs.nd && digs.nd >= digs.dp) {\n\t\t\t\teprec = digs.nd;\n\t\t\t}\n\t\t\tif (shortest) {\n\t\t\t\teprec = 6;\n\t\t\t}\n\t\t\texp = digs.dp - 1 >> 0;\n\t\t\tif (exp < -4 || exp >= eprec) {\n\t\t\t\tif (prec > digs.nd) {\n\t\t\t\t\tprec = digs.nd;\n\t\t\t\t}\n\t\t\t\treturn fmtE(dst, neg, $clone(digs, decimalSlice), prec - 1 >> 0, (fmt + 101 << 24 >>> 24) - 103 << 24 >>> 24);\n\t\t\t}\n\t\t\tif (prec > digs.dp) {\n\t\t\t\tprec = digs.nd;\n\t\t\t}\n\t\t\treturn fmtF(dst, neg, $clone(digs, decimalSlice), max(prec - digs.dp >> 0, 0));\n\t\t}\n\t\treturn $append(dst, 37, fmt);\n\t};\n\troundShortest = function(d, mant, exp, flt) {\n\t\tvar $ptr, d, exp, explo, flt, i, inclusive, l, lower, m, mant, mantlo, minexp, okdown, okup, u, upper, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7;\n\t\tif ((mant.$high === 0 && mant.$low === 0)) {\n\t\t\td.nd = 0;\n\t\t\treturn;\n\t\t}\n\t\tminexp = flt.bias + 1 >> 0;\n\t\tif (exp > minexp && ($imul(332, ((d.dp - d.nd >> 0)))) >= ($imul(100, ((exp - (flt.mantbits >> 0) >> 0))))) {\n\t\t\treturn;\n\t\t}\n\t\tupper = new decimal.ptr(arrayType.zero(), 0, 0, false, false);\n\t\tupper.Assign((x = $mul64(mant, new $Uint64(0, 2)), new $Uint64(x.$high + 0, x.$low + 1)));\n\t\tupper.Shift((exp - (flt.mantbits >> 0) >> 0) - 1 >> 0);\n\t\tmantlo = new $Uint64(0, 0);\n\t\texplo = 0;\n\t\tif ((x$1 = $shiftLeft64(new $Uint64(0, 1), flt.mantbits), (mant.$high > x$1.$high || (mant.$high === x$1.$high && mant.$low > x$1.$low))) || (exp === minexp)) {\n\t\t\tmantlo = new $Uint64(mant.$high - 0, mant.$low - 1);\n\t\t\texplo = exp;\n\t\t} else {\n\t\t\tmantlo = (x$2 = $mul64(mant, new $Uint64(0, 2)), new $Uint64(x$2.$high - 0, x$2.$low - 1));\n\t\t\texplo = exp - 1 >> 0;\n\t\t}\n\t\tlower = new decimal.ptr(arrayType.zero(), 0, 0, false, false);\n\t\tlower.Assign((x$3 = $mul64(mantlo, new $Uint64(0, 2)), new $Uint64(x$3.$high + 0, x$3.$low + 1)));\n\t\tlower.Shift((explo - (flt.mantbits >> 0) >> 0) - 1 >> 0);\n\t\tinclusive = (x$4 = $div64(mant, new $Uint64(0, 2), true), (x$4.$high === 0 && x$4.$low === 0));\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < d.nd)) { break; }\n\t\t\tl = 48;\n\t\t\tif (i < lower.nd) {\n\t\t\t\tl = (x$5 = lower.d, ((i < 0 || i >= x$5.length) ? $throwRuntimeError(\"index out of range\") : x$5[i]));\n\t\t\t}\n\t\t\tm = (x$6 = d.d, ((i < 0 || i >= x$6.length) ? $throwRuntimeError(\"index out of range\") : x$6[i]));\n\t\t\tu = 48;\n\t\t\tif (i < upper.nd) {\n\t\t\t\tu = (x$7 = upper.d, ((i < 0 || i >= x$7.length) ? $throwRuntimeError(\"index out of range\") : x$7[i]));\n\t\t\t}\n\t\t\tokdown = !((l === m)) || inclusive && ((i + 1 >> 0) === lower.nd);\n\t\t\tokup = !((m === u)) && (inclusive || (m + 1 << 24 >>> 24) < u || (i + 1 >> 0) < upper.nd);\n\t\t\tif (okdown && okup) {\n\t\t\t\td.Round(i + 1 >> 0);\n\t\t\t\treturn;\n\t\t\t} else if (okdown) {\n\t\t\t\td.RoundDown(i + 1 >> 0);\n\t\t\t\treturn;\n\t\t\t} else if (okup) {\n\t\t\t\td.RoundUp(i + 1 >> 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t};\n\tfmtE = function(dst, neg, d, prec, fmt) {\n\t\tvar $ptr, _q, _q$1, _q$2, _r, _r$1, _r$2, ch, d, dst, exp, fmt, i, m, neg, prec, x;\n\t\tif (neg) {\n\t\t\tdst = $append(dst, 45);\n\t\t}\n\t\tch = 48;\n\t\tif (!((d.nd === 0))) {\n\t\t\tch = (x = d.d, (0 >= x.$length ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + 0]));\n\t\t}\n\t\tdst = $append(dst, ch);\n\t\tif (prec > 0) {\n\t\t\tdst = $append(dst, 46);\n\t\t\ti = 1;\n\t\t\tm = min(d.nd, prec + 1 >> 0);\n\t\t\tif (i < m) {\n\t\t\t\tdst = $appendSlice(dst, $subslice(d.d, i, m));\n\t\t\t\ti = m;\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (!(i <= prec)) { break; }\n\t\t\t\tdst = $append(dst, 48);\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t}\n\t\tdst = $append(dst, fmt);\n\t\texp = d.dp - 1 >> 0;\n\t\tif (d.nd === 0) {\n\t\t\texp = 0;\n\t\t}\n\t\tif (exp < 0) {\n\t\t\tch = 45;\n\t\t\texp = -exp;\n\t\t} else {\n\t\t\tch = 43;\n\t\t}\n\t\tdst = $append(dst, ch);\n\t\tif (exp < 10) {\n\t\t\tdst = $append(dst, 48, (exp << 24 >>> 24) + 48 << 24 >>> 24);\n\t\t} else if (exp < 100) {\n\t\t\tdst = $append(dst, ((_q = exp / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) << 24 >>> 24) + 48 << 24 >>> 24, ((_r = exp % 10, _r === _r ? _r : $throwRuntimeError(\"integer divide by zero\")) << 24 >>> 24) + 48 << 24 >>> 24);\n\t\t} else {\n\t\t\tdst = $append(dst, ((_q$1 = exp / 100, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError(\"integer divide by zero\")) << 24 >>> 24) + 48 << 24 >>> 24, (_r$1 = ((_q$2 = exp / 10, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : $throwRuntimeError(\"integer divide by zero\")) << 24 >>> 24) % 10, _r$1 === _r$1 ? _r$1 : $throwRuntimeError(\"integer divide by zero\")) + 48 << 24 >>> 24, ((_r$2 = exp % 10, _r$2 === _r$2 ? _r$2 : $throwRuntimeError(\"integer divide by zero\")) << 24 >>> 24) + 48 << 24 >>> 24);\n\t\t}\n\t\treturn dst;\n\t};\n\tfmtF = function(dst, neg, d, prec) {\n\t\tvar $ptr, ch, d, dst, i, j, m, neg, prec, x;\n\t\tif (neg) {\n\t\t\tdst = $append(dst, 45);\n\t\t}\n\t\tif (d.dp > 0) {\n\t\t\tm = min(d.nd, d.dp);\n\t\t\tdst = $appendSlice(dst, $subslice(d.d, 0, m));\n\t\t\twhile (true) {\n\t\t\t\tif (!(m < d.dp)) { break; }\n\t\t\t\tdst = $append(dst, 48);\n\t\t\t\tm = m + (1) >> 0;\n\t\t\t}\n\t\t} else {\n\t\t\tdst = $append(dst, 48);\n\t\t}\n\t\tif (prec > 0) {\n\t\t\tdst = $append(dst, 46);\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < prec)) { break; }\n\t\t\t\tch = 48;\n\t\t\t\tj = d.dp + i >> 0;\n\t\t\t\tif (0 <= j && j < d.nd) {\n\t\t\t\t\tch = (x = d.d, ((j < 0 || j >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + j]));\n\t\t\t\t}\n\t\t\t\tdst = $append(dst, ch);\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t}\n\t\treturn dst;\n\t};\n\tfmtB = function(dst, neg, mant, exp, flt) {\n\t\tvar $ptr, _tuple, _tuple$1, dst, exp, flt, mant, neg;\n\t\tif (neg) {\n\t\t\tdst = $append(dst, 45);\n\t\t}\n\t\t_tuple = formatBits(dst, mant, 10, false, true);\n\t\tdst = _tuple[0];\n\t\tdst = $append(dst, 112);\n\t\texp = exp - ((flt.mantbits >> 0)) >> 0;\n\t\tif (exp >= 0) {\n\t\t\tdst = $append(dst, 43);\n\t\t}\n\t\t_tuple$1 = formatBits(dst, new $Uint64(0, exp), 10, exp < 0, true);\n\t\tdst = _tuple$1[0];\n\t\treturn dst;\n\t};\n\tmin = function(a, b) {\n\t\tvar $ptr, a, b;\n\t\tif (a < b) {\n\t\t\treturn a;\n\t\t}\n\t\treturn b;\n\t};\n\tmax = function(a, b) {\n\t\tvar $ptr, a, b;\n\t\tif (a > b) {\n\t\t\treturn a;\n\t\t}\n\t\treturn b;\n\t};\n\tFormatInt = function(i, base) {\n\t\tvar $ptr, _tuple, base, i, s;\n\t\t_tuple = formatBits(sliceType$6.nil, new $Uint64(i.$high, i.$low), base, (i.$high < 0 || (i.$high === 0 && i.$low < 0)), false);\n\t\ts = _tuple[1];\n\t\treturn s;\n\t};\n\t$pkg.FormatInt = FormatInt;\n\tItoa = function(i) {\n\t\tvar $ptr, i;\n\t\treturn FormatInt(new $Int64(0, i), 10);\n\t};\n\t$pkg.Itoa = Itoa;\n\tformatBits = function(dst, u, base, neg, append_) {\n\t\tvar $ptr, _q, _q$1, a, append_, b, b$1, base, d, dst, i, j, m, neg, q, q$1, q$2, qs, s, s$1, u, us, us$1, x, x$1;\n\t\td = sliceType$6.nil;\n\t\ts = \"\";\n\t\tif (base < 2 || base > 36) {\n\t\t\t$panic(new $String(\"strconv: illegal AppendInt/FormatInt base\"));\n\t\t}\n\t\ta = arrayType$3.zero();\n\t\ti = 65;\n\t\tif (neg) {\n\t\t\tu = new $Uint64(-u.$high, -u.$low);\n\t\t}\n\t\tif (base === 10) {\n\t\t\tif (true) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!((u.$high > 0 || (u.$high === 0 && u.$low > 4294967295)))) { break; }\n\t\t\t\t\tq = $div64(u, new $Uint64(0, 1000000000), false);\n\t\t\t\t\tus = ((x = $mul64(q, new $Uint64(0, 1000000000)), new $Uint64(u.$high - x.$high, u.$low - x.$low)).$low >>> 0);\n\t\t\t\t\tj = 9;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!(j > 0)) { break; }\n\t\t\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t\t\tqs = (_q = us / 10, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = (((us - ($imul(qs, 10) >>> 0) >>> 0) + 48 >>> 0) << 24 >>> 24));\n\t\t\t\t\t\tus = qs;\n\t\t\t\t\t\tj = j - (1) >> 0;\n\t\t\t\t\t}\n\t\t\t\t\tu = q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tus$1 = (u.$low >>> 0);\n\t\t\twhile (true) {\n\t\t\t\tif (!(us$1 >= 10)) { break; }\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\tq$1 = (_q$1 = us$1 / 10, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError(\"integer divide by zero\"));\n\t\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = (((us$1 - ($imul(q$1, 10) >>> 0) >>> 0) + 48 >>> 0) << 24 >>> 24));\n\t\t\t\tus$1 = q$1;\n\t\t\t}\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = ((us$1 + 48 >>> 0) << 24 >>> 24));\n\t\t} else {\n\t\t\ts$1 = ((base < 0 || base >= shifts.length) ? $throwRuntimeError(\"index out of range\") : shifts[base]);\n\t\t\tif (s$1 > 0) {\n\t\t\t\tb = new $Uint64(0, base);\n\t\t\t\tm = (b.$low >>> 0) - 1 >>> 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!((u.$high > b.$high || (u.$high === b.$high && u.$low >= b.$low)))) { break; }\n\t\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = \"0123456789abcdefghijklmnopqrstuvwxyz\".charCodeAt((((u.$low >>> 0) & m) >>> 0)));\n\t\t\t\t\tu = $shiftRightUint64(u, (s$1));\n\t\t\t\t}\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = \"0123456789abcdefghijklmnopqrstuvwxyz\".charCodeAt((u.$low >>> 0)));\n\t\t\t} else {\n\t\t\t\tb$1 = new $Uint64(0, base);\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!((u.$high > b$1.$high || (u.$high === b$1.$high && u.$low >= b$1.$low)))) { break; }\n\t\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t\tq$2 = $div64(u, b$1, false);\n\t\t\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = \"0123456789abcdefghijklmnopqrstuvwxyz\".charCodeAt(((x$1 = $mul64(q$2, b$1), new $Uint64(u.$high - x$1.$high, u.$low - x$1.$low)).$low >>> 0)));\n\t\t\t\t\tu = q$2;\n\t\t\t\t}\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = \"0123456789abcdefghijklmnopqrstuvwxyz\".charCodeAt((u.$low >>> 0)));\n\t\t\t}\n\t\t}\n\t\tif (neg) {\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= a.length) ? $throwRuntimeError(\"index out of range\") : a[i] = 45);\n\t\t}\n\t\tif (append_) {\n\t\t\td = $appendSlice(dst, $subslice(new sliceType$6(a), i));\n\t\t\treturn [d, s];\n\t\t}\n\t\ts = $bytesToString($subslice(new sliceType$6(a), i));\n\t\treturn [d, s];\n\t};\n\tappendQuotedWith = function(buf, s, quote, ASCIIonly, graphicOnly) {\n\t\tvar $ptr, ASCIIonly, _tuple, buf, graphicOnly, quote, r, s, width;\n\t\tbuf = $append(buf, quote);\n\t\twidth = 0;\n\t\twhile (true) {\n\t\t\tif (!(s.length > 0)) { break; }\n\t\t\tr = (s.charCodeAt(0) >> 0);\n\t\t\twidth = 1;\n\t\t\tif (r >= 128) {\n\t\t\t\t_tuple = utf8.DecodeRuneInString(s);\n\t\t\t\tr = _tuple[0];\n\t\t\t\twidth = _tuple[1];\n\t\t\t}\n\t\t\tif ((width === 1) && (r === 65533)) {\n\t\t\t\tbuf = $appendSlice(buf, \"\\\\x\");\n\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));\n\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));\n\t\t\t\ts = $substring(s, width);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbuf = appendEscapedRune(buf, r, width, quote, ASCIIonly, graphicOnly);\n\t\t\ts = $substring(s, width);\n\t\t}\n\t\tbuf = $append(buf, quote);\n\t\treturn buf;\n\t};\n\tappendQuotedRuneWith = function(buf, r, quote, ASCIIonly, graphicOnly) {\n\t\tvar $ptr, ASCIIonly, buf, graphicOnly, quote, r;\n\t\tbuf = $append(buf, quote);\n\t\tif (!utf8.ValidRune(r)) {\n\t\t\tr = 65533;\n\t\t}\n\t\tbuf = appendEscapedRune(buf, r, utf8.RuneLen(r), quote, ASCIIonly, graphicOnly);\n\t\tbuf = $append(buf, quote);\n\t\treturn buf;\n\t};\n\tappendEscapedRune = function(buf, r, width, quote, ASCIIonly, graphicOnly) {\n\t\tvar $ptr, ASCIIonly, _1, buf, graphicOnly, n, quote, r, runeTmp, s, s$1, width;\n\t\truneTmp = arrayType$4.zero();\n\t\tif ((r === (quote >> 0)) || (r === 92)) {\n\t\t\tbuf = $append(buf, 92);\n\t\t\tbuf = $append(buf, (r << 24 >>> 24));\n\t\t\treturn buf;\n\t\t}\n\t\tif (ASCIIonly) {\n\t\t\tif (r < 128 && IsPrint(r)) {\n\t\t\t\tbuf = $append(buf, (r << 24 >>> 24));\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t} else if (IsPrint(r) || graphicOnly && isInGraphicList(r)) {\n\t\t\tn = utf8.EncodeRune(new sliceType$6(runeTmp), r);\n\t\t\tbuf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n));\n\t\t\treturn buf;\n\t\t}\n\t\t_1 = r;\n\t\tif (_1 === (7)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\a\");\n\t\t} else if (_1 === (8)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\b\");\n\t\t} else if (_1 === (12)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\f\");\n\t\t} else if (_1 === (10)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\n\");\n\t\t} else if (_1 === (13)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\r\");\n\t\t} else if (_1 === (9)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\t\");\n\t\t} else if (_1 === (11)) {\n\t\t\tbuf = $appendSlice(buf, \"\\\\v\");\n\t\t} else {\n\t\t\tif (r < 32) {\n\t\t\t\tbuf = $appendSlice(buf, \"\\\\x\");\n\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt(((r << 24 >>> 24) >>> 4 << 24 >>> 24)));\n\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt((((r << 24 >>> 24) & 15) >>> 0)));\n\t\t\t} else if (r > 1114111) {\n\t\t\t\tr = 65533;\n\t\t\t\tbuf = $appendSlice(buf, \"\\\\u\");\n\t\t\t\ts = 12;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(s >= 0)) { break; }\n\t\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt((((r >> $min((s >>> 0), 31)) >> 0) & 15)));\n\t\t\t\t\ts = s - (4) >> 0;\n\t\t\t\t}\n\t\t\t} else if (r < 65536) {\n\t\t\t\tbuf = $appendSlice(buf, \"\\\\u\");\n\t\t\t\ts = 12;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(s >= 0)) { break; }\n\t\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt((((r >> $min((s >>> 0), 31)) >> 0) & 15)));\n\t\t\t\t\ts = s - (4) >> 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf = $appendSlice(buf, \"\\\\U\");\n\t\t\t\ts$1 = 28;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(s$1 >= 0)) { break; }\n\t\t\t\t\tbuf = $append(buf, \"0123456789abcdef\".charCodeAt((((r >> $min((s$1 >>> 0), 31)) >> 0) & 15)));\n\t\t\t\t\ts$1 = s$1 - (4) >> 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf;\n\t};\n\tAppendQuote = function(dst, s) {\n\t\tvar $ptr, dst, s;\n\t\treturn appendQuotedWith(dst, s, 34, false, false);\n\t};\n\t$pkg.AppendQuote = AppendQuote;\n\tAppendQuoteToASCII = function(dst, s) {\n\t\tvar $ptr, dst, s;\n\t\treturn appendQuotedWith(dst, s, 34, true, false);\n\t};\n\t$pkg.AppendQuoteToASCII = AppendQuoteToASCII;\n\tAppendQuoteRune = function(dst, r) {\n\t\tvar $ptr, dst, r;\n\t\treturn appendQuotedRuneWith(dst, r, 39, false, false);\n\t};\n\t$pkg.AppendQuoteRune = AppendQuoteRune;\n\tAppendQuoteRuneToASCII = function(dst, r) {\n\t\tvar $ptr, dst, r;\n\t\treturn appendQuotedRuneWith(dst, r, 39, true, false);\n\t};\n\t$pkg.AppendQuoteRuneToASCII = AppendQuoteRuneToASCII;\n\tCanBackquote = function(s) {\n\t\tvar $ptr, _tuple, r, s, wid;\n\t\twhile (true) {\n\t\t\tif (!(s.length > 0)) { break; }\n\t\t\t_tuple = utf8.DecodeRuneInString(s);\n\t\t\tr = _tuple[0];\n\t\t\twid = _tuple[1];\n\t\t\ts = $substring(s, wid);\n\t\t\tif (wid > 1) {\n\t\t\t\tif (r === 65279) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r === 65533) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ((r < 32 && !((r === 9))) || (r === 96) || (r === 127)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\t$pkg.CanBackquote = CanBackquote;\n\tunhex = function(b) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, c, ok, v;\n\t\tv = 0;\n\t\tok = false;\n\t\tc = (b >> 0);\n\t\tif (48 <= c && c <= 57) {\n\t\t\t_tmp = c - 48 >> 0;\n\t\t\t_tmp$1 = true;\n\t\t\tv = _tmp;\n\t\t\tok = _tmp$1;\n\t\t\treturn [v, ok];\n\t\t} else if (97 <= c && c <= 102) {\n\t\t\t_tmp$2 = (c - 97 >> 0) + 10 >> 0;\n\t\t\t_tmp$3 = true;\n\t\t\tv = _tmp$2;\n\t\t\tok = _tmp$3;\n\t\t\treturn [v, ok];\n\t\t} else if (65 <= c && c <= 70) {\n\t\t\t_tmp$4 = (c - 65 >> 0) + 10 >> 0;\n\t\t\t_tmp$5 = true;\n\t\t\tv = _tmp$4;\n\t\t\tok = _tmp$5;\n\t\t\treturn [v, ok];\n\t\t}\n\t\treturn [v, ok];\n\t};\n\tUnquoteChar = function(s, quote) {\n\t\tvar $ptr, _1, _2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, c, c$1, err, j, j$1, multibyte, n, ok, quote, r, s, size, tail, v, v$1, value, x, x$1;\n\t\tvalue = 0;\n\t\tmultibyte = false;\n\t\ttail = \"\";\n\t\terr = $ifaceNil;\n\t\tc = s.charCodeAt(0);\n\t\tif ((c === quote) && ((quote === 39) || (quote === 34))) {\n\t\t\terr = $pkg.ErrSyntax;\n\t\t\treturn [value, multibyte, tail, err];\n\t\t} else if (c >= 128) {\n\t\t\t_tuple = utf8.DecodeRuneInString(s);\n\t\t\tr = _tuple[0];\n\t\t\tsize = _tuple[1];\n\t\t\t_tmp = r;\n\t\t\t_tmp$1 = true;\n\t\t\t_tmp$2 = $substring(s, size);\n\t\t\t_tmp$3 = $ifaceNil;\n\t\t\tvalue = _tmp;\n\t\t\tmultibyte = _tmp$1;\n\t\t\ttail = _tmp$2;\n\t\t\terr = _tmp$3;\n\t\t\treturn [value, multibyte, tail, err];\n\t\t} else if (!((c === 92))) {\n\t\t\t_tmp$4 = (s.charCodeAt(0) >> 0);\n\t\t\t_tmp$5 = false;\n\t\t\t_tmp$6 = $substring(s, 1);\n\t\t\t_tmp$7 = $ifaceNil;\n\t\t\tvalue = _tmp$4;\n\t\t\tmultibyte = _tmp$5;\n\t\t\ttail = _tmp$6;\n\t\t\terr = _tmp$7;\n\t\t\treturn [value, multibyte, tail, err];\n\t\t}\n\t\tif (s.length <= 1) {\n\t\t\terr = $pkg.ErrSyntax;\n\t\t\treturn [value, multibyte, tail, err];\n\t\t}\n\t\tc$1 = s.charCodeAt(1);\n\t\ts = $substring(s, 2);\n\t\tswitch (0) { default:\n\t\t\t_1 = c$1;\n\t\t\tif (_1 === (97)) {\n\t\t\t\tvalue = 7;\n\t\t\t} else if (_1 === (98)) {\n\t\t\t\tvalue = 8;\n\t\t\t} else if (_1 === (102)) {\n\t\t\t\tvalue = 12;\n\t\t\t} else if (_1 === (110)) {\n\t\t\t\tvalue = 10;\n\t\t\t} else if (_1 === (114)) {\n\t\t\t\tvalue = 13;\n\t\t\t} else if (_1 === (116)) {\n\t\t\t\tvalue = 9;\n\t\t\t} else if (_1 === (118)) {\n\t\t\t\tvalue = 11;\n\t\t\t} else if ((_1 === (120)) || (_1 === (117)) || (_1 === (85))) {\n\t\t\t\tn = 0;\n\t\t\t\t_2 = c$1;\n\t\t\t\tif (_2 === (120)) {\n\t\t\t\t\tn = 2;\n\t\t\t\t} else if (_2 === (117)) {\n\t\t\t\t\tn = 4;\n\t\t\t\t} else if (_2 === (85)) {\n\t\t\t\t\tn = 8;\n\t\t\t\t}\n\t\t\t\tv = 0;\n\t\t\t\tif (s.length < n) {\n\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t}\n\t\t\t\tj = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(j < n)) { break; }\n\t\t\t\t\t_tuple$1 = unhex(s.charCodeAt(j));\n\t\t\t\t\tx = _tuple$1[0];\n\t\t\t\t\tok = _tuple$1[1];\n\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t\t}\n\t\t\t\t\tv = (v << 4 >> 0) | x;\n\t\t\t\t\tj = j + (1) >> 0;\n\t\t\t\t}\n\t\t\t\ts = $substring(s, n);\n\t\t\t\tif (c$1 === 120) {\n\t\t\t\t\tvalue = v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v > 1114111) {\n\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t}\n\t\t\t\tvalue = v;\n\t\t\t\tmultibyte = true;\n\t\t\t} else if ((_1 === (48)) || (_1 === (49)) || (_1 === (50)) || (_1 === (51)) || (_1 === (52)) || (_1 === (53)) || (_1 === (54)) || (_1 === (55))) {\n\t\t\t\tv$1 = (c$1 >> 0) - 48 >> 0;\n\t\t\t\tif (s.length < 2) {\n\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t}\n\t\t\t\tj$1 = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(j$1 < 2)) { break; }\n\t\t\t\t\tx$1 = (s.charCodeAt(j$1) >> 0) - 48 >> 0;\n\t\t\t\t\tif (x$1 < 0 || x$1 > 7) {\n\t\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t\t}\n\t\t\t\t\tv$1 = ((v$1 << 3 >> 0)) | x$1;\n\t\t\t\t\tj$1 = j$1 + (1) >> 0;\n\t\t\t\t}\n\t\t\t\ts = $substring(s, 2);\n\t\t\t\tif (v$1 > 255) {\n\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t}\n\t\t\t\tvalue = v$1;\n\t\t\t} else if (_1 === (92)) {\n\t\t\t\tvalue = 92;\n\t\t\t} else if ((_1 === (39)) || (_1 === (34))) {\n\t\t\t\tif (!((c$1 === quote))) {\n\t\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t\t}\n\t\t\t\tvalue = (c$1 >> 0);\n\t\t\t} else {\n\t\t\t\terr = $pkg.ErrSyntax;\n\t\t\t\treturn [value, multibyte, tail, err];\n\t\t\t}\n\t\t}\n\t\ttail = s;\n\t\treturn [value, multibyte, tail, err];\n\t};\n\t$pkg.UnquoteChar = UnquoteChar;\n\tUnquote = function(s) {\n\t\tvar $ptr, _1, _q, _tuple, _tuple$1, buf, c, err, multibyte, n, n$1, quote, r, runeTmp, s, size, ss;\n\t\tn = s.length;\n\t\tif (n < 2) {\n\t\t\treturn [\"\", $pkg.ErrSyntax];\n\t\t}\n\t\tquote = s.charCodeAt(0);\n\t\tif (!((quote === s.charCodeAt((n - 1 >> 0))))) {\n\t\t\treturn [\"\", $pkg.ErrSyntax];\n\t\t}\n\t\ts = $substring(s, 1, (n - 1 >> 0));\n\t\tif (quote === 96) {\n\t\t\tif (contains(s, 96)) {\n\t\t\t\treturn [\"\", $pkg.ErrSyntax];\n\t\t\t}\n\t\t\treturn [s, $ifaceNil];\n\t\t}\n\t\tif (!((quote === 34)) && !((quote === 39))) {\n\t\t\treturn [\"\", $pkg.ErrSyntax];\n\t\t}\n\t\tif (contains(s, 10)) {\n\t\t\treturn [\"\", $pkg.ErrSyntax];\n\t\t}\n\t\tif (!contains(s, 92) && !contains(s, quote)) {\n\t\t\t_1 = quote;\n\t\t\tif (_1 === (34)) {\n\t\t\t\treturn [s, $ifaceNil];\n\t\t\t} else if (_1 === (39)) {\n\t\t\t\t_tuple = utf8.DecodeRuneInString(s);\n\t\t\t\tr = _tuple[0];\n\t\t\t\tsize = _tuple[1];\n\t\t\t\tif ((size === s.length) && (!((r === 65533)) || !((size === 1)))) {\n\t\t\t\t\treturn [s, $ifaceNil];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\truneTmp = arrayType$4.zero();\n\t\tbuf = $makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")));\n\t\twhile (true) {\n\t\t\tif (!(s.length > 0)) { break; }\n\t\t\t_tuple$1 = UnquoteChar(s, quote);\n\t\t\tc = _tuple$1[0];\n\t\t\tmultibyte = _tuple$1[1];\n\t\t\tss = _tuple$1[2];\n\t\t\terr = _tuple$1[3];\n\t\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t\treturn [\"\", err];\n\t\t\t}\n\t\t\ts = ss;\n\t\t\tif (c < 128 || !multibyte) {\n\t\t\t\tbuf = $append(buf, (c << 24 >>> 24));\n\t\t\t} else {\n\t\t\t\tn$1 = utf8.EncodeRune(new sliceType$6(runeTmp), c);\n\t\t\t\tbuf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n$1));\n\t\t\t}\n\t\t\tif ((quote === 39) && !((s.length === 0))) {\n\t\t\t\treturn [\"\", $pkg.ErrSyntax];\n\t\t\t}\n\t\t}\n\t\treturn [$bytesToString(buf), $ifaceNil];\n\t};\n\t$pkg.Unquote = Unquote;\n\tcontains = function(s, c) {\n\t\tvar $ptr, c, i, s;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < s.length)) { break; }\n\t\t\tif (s.charCodeAt(i) === c) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\treturn false;\n\t};\n\tbsearch16 = function(a, x) {\n\t\tvar $ptr, _q, _tmp, _tmp$1, a, h, i, j, x;\n\t\t_tmp = 0;\n\t\t_tmp$1 = a.$length;\n\t\ti = _tmp;\n\t\tj = _tmp$1;\n\t\twhile (true) {\n\t\t\tif (!(i < j)) { break; }\n\t\t\th = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) >> 0;\n\t\t\tif (((h < 0 || h >= a.$length) ? $throwRuntimeError(\"index out of range\") : a.$array[a.$offset + h]) < x) {\n\t\t\t\ti = h + 1 >> 0;\n\t\t\t} else {\n\t\t\t\tj = h;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t};\n\tbsearch32 = function(a, x) {\n\t\tvar $ptr, _q, _tmp, _tmp$1, a, h, i, j, x;\n\t\t_tmp = 0;\n\t\t_tmp$1 = a.$length;\n\t\ti = _tmp;\n\t\tj = _tmp$1;\n\t\twhile (true) {\n\t\t\tif (!(i < j)) { break; }\n\t\t\th = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")) >> 0;\n\t\t\tif (((h < 0 || h >= a.$length) ? $throwRuntimeError(\"index out of range\") : a.$array[a.$offset + h]) < x) {\n\t\t\t\ti = h + 1 >> 0;\n\t\t\t} else {\n\t\t\t\tj = h;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t};\n\tIsPrint = function(r) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, i, i$1, isNotPrint, isNotPrint$1, isPrint, isPrint$1, j, j$1, r, rr, rr$1, x, x$1, x$2, x$3;\n\t\tif (r <= 255) {\n\t\t\tif (32 <= r && r <= 126) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (161 <= r && r <= 255) {\n\t\t\t\treturn !((r === 173));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (0 <= r && r < 65536) {\n\t\t\t_tmp = (r << 16 >>> 16);\n\t\t\t_tmp$1 = isPrint16;\n\t\t\t_tmp$2 = isNotPrint16;\n\t\t\trr = _tmp;\n\t\t\tisPrint = _tmp$1;\n\t\t\tisNotPrint = _tmp$2;\n\t\t\ti = bsearch16(isPrint, rr);\n\t\t\tif (i >= isPrint.$length || rr < (x = (i & ~1) >> 0, ((x < 0 || x >= isPrint.$length) ? $throwRuntimeError(\"index out of range\") : isPrint.$array[isPrint.$offset + x])) || (x$1 = i | 1, ((x$1 < 0 || x$1 >= isPrint.$length) ? $throwRuntimeError(\"index out of range\") : isPrint.$array[isPrint.$offset + x$1])) < rr) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = bsearch16(isNotPrint, rr);\n\t\t\treturn j >= isNotPrint.$length || !((((j < 0 || j >= isNotPrint.$length) ? $throwRuntimeError(\"index out of range\") : isNotPrint.$array[isNotPrint.$offset + j]) === rr));\n\t\t}\n\t\t_tmp$3 = (r >>> 0);\n\t\t_tmp$4 = isPrint32;\n\t\t_tmp$5 = isNotPrint32;\n\t\trr$1 = _tmp$3;\n\t\tisPrint$1 = _tmp$4;\n\t\tisNotPrint$1 = _tmp$5;\n\t\ti$1 = bsearch32(isPrint$1, rr$1);\n\t\tif (i$1 >= isPrint$1.$length || rr$1 < (x$2 = (i$1 & ~1) >> 0, ((x$2 < 0 || x$2 >= isPrint$1.$length) ? $throwRuntimeError(\"index out of range\") : isPrint$1.$array[isPrint$1.$offset + x$2])) || (x$3 = i$1 | 1, ((x$3 < 0 || x$3 >= isPrint$1.$length) ? $throwRuntimeError(\"index out of range\") : isPrint$1.$array[isPrint$1.$offset + x$3])) < rr$1) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r >= 131072) {\n\t\t\treturn true;\n\t\t}\n\t\tr = r - (65536) >> 0;\n\t\tj$1 = bsearch16(isNotPrint$1, (r << 16 >>> 16));\n\t\treturn j$1 >= isNotPrint$1.$length || !((((j$1 < 0 || j$1 >= isNotPrint$1.$length) ? $throwRuntimeError(\"index out of range\") : isNotPrint$1.$array[isNotPrint$1.$offset + j$1]) === (r << 16 >>> 16)));\n\t};\n\t$pkg.IsPrint = IsPrint;\n\tisInGraphicList = function(r) {\n\t\tvar $ptr, i, r, rr;\n\t\tif (r > 65535) {\n\t\t\treturn false;\n\t\t}\n\t\trr = (r << 16 >>> 16);\n\t\ti = bsearch16(isGraphic, rr);\n\t\treturn i < isGraphic.$length && (rr === ((i < 0 || i >= isGraphic.$length) ? $throwRuntimeError(\"index out of range\") : isGraphic.$array[isGraphic.$offset + i]));\n\t};\n\tptrType$2.methods = [{prop: \"set\", name: \"set\", pkg: \"strconv\", typ: $funcType([$String], [$Bool], false)}, {prop: \"floatBits\", name: \"floatBits\", pkg: \"strconv\", typ: $funcType([ptrType$1], [$Uint64, $Bool], false)}, {prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Assign\", name: \"Assign\", pkg: \"\", typ: $funcType([$Uint64], [], false)}, {prop: \"Shift\", name: \"Shift\", pkg: \"\", typ: $funcType([$Int], [], false)}, {prop: \"Round\", name: \"Round\", pkg: \"\", typ: $funcType([$Int], [], false)}, {prop: \"RoundDown\", name: \"RoundDown\", pkg: \"\", typ: $funcType([$Int], [], false)}, {prop: \"RoundUp\", name: \"RoundUp\", pkg: \"\", typ: $funcType([$Int], [], false)}, {prop: \"RoundedInteger\", name: \"RoundedInteger\", pkg: \"\", typ: $funcType([], [$Uint64], false)}];\n\tptrType$4.methods = [{prop: \"floatBits\", name: \"floatBits\", pkg: \"strconv\", typ: $funcType([ptrType$1], [$Uint64, $Bool], false)}, {prop: \"AssignComputeBounds\", name: \"AssignComputeBounds\", pkg: \"\", typ: $funcType([$Uint64, $Int, $Bool, ptrType$1], [extFloat, extFloat], false)}, {prop: \"Normalize\", name: \"Normalize\", pkg: \"\", typ: $funcType([], [$Uint], false)}, {prop: \"Multiply\", name: \"Multiply\", pkg: \"\", typ: $funcType([extFloat], [], false)}, {prop: \"AssignDecimal\", name: \"AssignDecimal\", pkg: \"\", typ: $funcType([$Uint64, $Int, $Bool, $Bool, ptrType$1], [$Bool], false)}, {prop: \"frexp10\", name: \"frexp10\", pkg: \"strconv\", typ: $funcType([], [$Int, $Int], false)}, {prop: \"FixedDecimal\", name: \"FixedDecimal\", pkg: \"\", typ: $funcType([ptrType$3, $Int], [$Bool], false)}, {prop: \"ShortestDecimal\", name: \"ShortestDecimal\", pkg: \"\", typ: $funcType([ptrType$3, ptrType$4, ptrType$4], [$Bool], false)}];\n\tdecimal.init(\"strconv\", [{prop: \"d\", name: \"d\", exported: false, typ: arrayType, tag: \"\"}, {prop: \"nd\", name: \"nd\", exported: false, typ: $Int, tag: \"\"}, {prop: \"dp\", name: \"dp\", exported: false, typ: $Int, tag: \"\"}, {prop: \"neg\", name: \"neg\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"trunc\", name: \"trunc\", exported: false, typ: $Bool, tag: \"\"}]);\n\tleftCheat.init(\"strconv\", [{prop: \"delta\", name: \"delta\", exported: false, typ: $Int, tag: \"\"}, {prop: \"cutoff\", name: \"cutoff\", exported: false, typ: $String, tag: \"\"}]);\n\textFloat.init(\"strconv\", [{prop: \"mant\", name: \"mant\", exported: false, typ: $Uint64, tag: \"\"}, {prop: \"exp\", name: \"exp\", exported: false, typ: $Int, tag: \"\"}, {prop: \"neg\", name: \"neg\", exported: false, typ: $Bool, tag: \"\"}]);\n\tfloatInfo.init(\"strconv\", [{prop: \"mantbits\", name: \"mantbits\", exported: false, typ: $Uint, tag: \"\"}, {prop: \"expbits\", name: \"expbits\", exported: false, typ: $Uint, tag: \"\"}, {prop: \"bias\", name: \"bias\", exported: false, typ: $Int, tag: \"\"}]);\n\tdecimalSlice.init(\"strconv\", [{prop: \"d\", name: \"d\", exported: false, typ: sliceType$6, tag: \"\"}, {prop: \"nd\", name: \"nd\", exported: false, typ: $Int, tag: \"\"}, {prop: \"dp\", name: \"dp\", exported: false, typ: $Int, tag: \"\"}, {prop: \"neg\", name: \"neg\", exported: false, typ: $Bool, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = math.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = utf8.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\toptimize = true;\n\t\t$pkg.ErrRange = errors.New(\"value out of range\");\n\t\t$pkg.ErrSyntax = errors.New(\"invalid syntax\");\n\t\tleftcheats = new sliceType$3([new leftCheat.ptr(0, \"\"), new leftCheat.ptr(1, \"5\"), new leftCheat.ptr(1, \"25\"), new leftCheat.ptr(1, \"125\"), new leftCheat.ptr(2, \"625\"), new leftCheat.ptr(2, \"3125\"), new leftCheat.ptr(2, \"15625\"), new leftCheat.ptr(3, \"78125\"), new leftCheat.ptr(3, \"390625\"), new leftCheat.ptr(3, \"1953125\"), new leftCheat.ptr(4, \"9765625\"), new leftCheat.ptr(4, \"48828125\"), new leftCheat.ptr(4, \"244140625\"), new leftCheat.ptr(4, \"1220703125\"), new leftCheat.ptr(5, \"6103515625\"), new leftCheat.ptr(5, \"30517578125\"), new leftCheat.ptr(5, \"152587890625\"), new leftCheat.ptr(6, \"762939453125\"), new leftCheat.ptr(6, \"3814697265625\"), new leftCheat.ptr(6, \"19073486328125\"), new leftCheat.ptr(7, \"95367431640625\"), new leftCheat.ptr(7, \"476837158203125\"), new leftCheat.ptr(7, \"2384185791015625\"), new leftCheat.ptr(7, \"11920928955078125\"), new leftCheat.ptr(8, \"59604644775390625\"), new leftCheat.ptr(8, \"298023223876953125\"), new leftCheat.ptr(8, \"1490116119384765625\"), new leftCheat.ptr(9, \"7450580596923828125\"), new leftCheat.ptr(9, \"37252902984619140625\"), new leftCheat.ptr(9, \"186264514923095703125\"), new leftCheat.ptr(10, \"931322574615478515625\"), new leftCheat.ptr(10, \"4656612873077392578125\"), new leftCheat.ptr(10, \"23283064365386962890625\"), new leftCheat.ptr(10, \"116415321826934814453125\"), new leftCheat.ptr(11, \"582076609134674072265625\"), new leftCheat.ptr(11, \"2910383045673370361328125\"), new leftCheat.ptr(11, \"14551915228366851806640625\"), new leftCheat.ptr(12, \"72759576141834259033203125\"), new leftCheat.ptr(12, \"363797880709171295166015625\"), new leftCheat.ptr(12, \"1818989403545856475830078125\"), new leftCheat.ptr(13, \"9094947017729282379150390625\"), new leftCheat.ptr(13, \"45474735088646411895751953125\"), new leftCheat.ptr(13, \"227373675443232059478759765625\"), new leftCheat.ptr(13, \"1136868377216160297393798828125\"), new leftCheat.ptr(14, \"5684341886080801486968994140625\"), new leftCheat.ptr(14, \"28421709430404007434844970703125\"), new leftCheat.ptr(14, \"142108547152020037174224853515625\"), new leftCheat.ptr(15, \"710542735760100185871124267578125\"), new leftCheat.ptr(15, \"3552713678800500929355621337890625\"), new leftCheat.ptr(15, \"17763568394002504646778106689453125\"), new leftCheat.ptr(16, \"88817841970012523233890533447265625\"), new leftCheat.ptr(16, \"444089209850062616169452667236328125\"), new leftCheat.ptr(16, \"2220446049250313080847263336181640625\"), new leftCheat.ptr(16, \"11102230246251565404236316680908203125\"), new leftCheat.ptr(17, \"55511151231257827021181583404541015625\"), new leftCheat.ptr(17, \"277555756156289135105907917022705078125\"), new leftCheat.ptr(17, \"1387778780781445675529539585113525390625\"), new leftCheat.ptr(18, \"6938893903907228377647697925567626953125\"), new leftCheat.ptr(18, \"34694469519536141888238489627838134765625\"), new leftCheat.ptr(18, \"173472347597680709441192448139190673828125\"), new leftCheat.ptr(19, \"867361737988403547205962240695953369140625\")]);\n\t\tsmallPowersOfTen = $toNativeArray($kindStruct, [new extFloat.ptr(new $Uint64(2147483648, 0), -63, false), new extFloat.ptr(new $Uint64(2684354560, 0), -60, false), new extFloat.ptr(new $Uint64(3355443200, 0), -57, false), new extFloat.ptr(new $Uint64(4194304000, 0), -54, false), new extFloat.ptr(new $Uint64(2621440000, 0), -50, false), new extFloat.ptr(new $Uint64(3276800000, 0), -47, false), new extFloat.ptr(new $Uint64(4096000000, 0), -44, false), new extFloat.ptr(new $Uint64(2560000000, 0), -40, false)]);\n\t\tpowersOfTen = $toNativeArray($kindStruct, [new extFloat.ptr(new $Uint64(4203730336, 136053384), -1220, false), new extFloat.ptr(new $Uint64(3132023167, 2722021238), -1193, false), new extFloat.ptr(new $Uint64(2333539104, 810921078), -1166, false), new extFloat.ptr(new $Uint64(3477244234, 1573795306), -1140, false), new extFloat.ptr(new $Uint64(2590748842, 1432697645), -1113, false), new extFloat.ptr(new $Uint64(3860516611, 1025131999), -1087, false), new extFloat.ptr(new $Uint64(2876309015, 3348809418), -1060, false), new extFloat.ptr(new $Uint64(4286034428, 3200048207), -1034, false), new extFloat.ptr(new $Uint64(3193344495, 1097586188), -1007, false), new extFloat.ptr(new $Uint64(2379227053, 2424306748), -980, false), new extFloat.ptr(new $Uint64(3545324584, 827693699), -954, false), new extFloat.ptr(new $Uint64(2641472655, 2913388981), -927, false), new extFloat.ptr(new $Uint64(3936100983, 602835915), -901, false), new extFloat.ptr(new $Uint64(2932623761, 1081627501), -874, false), new extFloat.ptr(new $Uint64(2184974969, 1572261463), -847, false), new extFloat.ptr(new $Uint64(3255866422, 1308317239), -821, false), new extFloat.ptr(new $Uint64(2425809519, 944281679), -794, false), new extFloat.ptr(new $Uint64(3614737867, 629291719), -768, false), new extFloat.ptr(new $Uint64(2693189581, 2545915892), -741, false), new extFloat.ptr(new $Uint64(4013165208, 388672741), -715, false), new extFloat.ptr(new $Uint64(2990041083, 708162190), -688, false), new extFloat.ptr(new $Uint64(2227754207, 3536207675), -661, false), new extFloat.ptr(new $Uint64(3319612455, 450088378), -635, false), new extFloat.ptr(new $Uint64(2473304014, 3139815830), -608, false), new extFloat.ptr(new $Uint64(3685510180, 2103616900), -582, false), new extFloat.ptr(new $Uint64(2745919064, 224385782), -555, false), new extFloat.ptr(new $Uint64(4091738259, 3737383206), -529, false), new extFloat.ptr(new $Uint64(3048582568, 2868871352), -502, false), new extFloat.ptr(new $Uint64(2271371013, 1820084875), -475, false), new extFloat.ptr(new $Uint64(3384606560, 885076051), -449, false), new extFloat.ptr(new $Uint64(2521728396, 2444895829), -422, false), new extFloat.ptr(new $Uint64(3757668132, 1881767613), -396, false), new extFloat.ptr(new $Uint64(2799680927, 3102062735), -369, false), new extFloat.ptr(new $Uint64(4171849679, 2289335700), -343, false), new extFloat.ptr(new $Uint64(3108270227, 2410191823), -316, false), new extFloat.ptr(new $Uint64(2315841784, 3205436779), -289, false), new extFloat.ptr(new $Uint64(3450873173, 1697722806), -263, false), new extFloat.ptr(new $Uint64(2571100870, 3497754540), -236, false), new extFloat.ptr(new $Uint64(3831238852, 707476230), -210, false), new extFloat.ptr(new $Uint64(2854495385, 1769181907), -183, false), new extFloat.ptr(new $Uint64(4253529586, 2197867022), -157, false), new extFloat.ptr(new $Uint64(3169126500, 2450594539), -130, false), new extFloat.ptr(new $Uint64(2361183241, 1867548876), -103, false), new extFloat.ptr(new $Uint64(3518437208, 3793315116), -77, false), new extFloat.ptr(new $Uint64(2621440000, 0), -50, false), new extFloat.ptr(new $Uint64(3906250000, 0), -24, false), new extFloat.ptr(new $Uint64(2910383045, 2892103680), 3, false), new extFloat.ptr(new $Uint64(2168404344, 4170451332), 30, false), new extFloat.ptr(new $Uint64(3231174267, 3372684723), 56, false), new extFloat.ptr(new $Uint64(2407412430, 2078956656), 83, false), new extFloat.ptr(new $Uint64(3587324068, 2884206696), 109, false), new extFloat.ptr(new $Uint64(2672764710, 395977285), 136, false), new extFloat.ptr(new $Uint64(3982729777, 3569679143), 162, false), new extFloat.ptr(new $Uint64(2967364920, 2361961896), 189, false), new extFloat.ptr(new $Uint64(2210859150, 447440347), 216, false), new extFloat.ptr(new $Uint64(3294436857, 1114709402), 242, false), new extFloat.ptr(new $Uint64(2454546732, 2786846552), 269, false), new extFloat.ptr(new $Uint64(3657559652, 443583978), 295, false), new extFloat.ptr(new $Uint64(2725094297, 2599384906), 322, false), new extFloat.ptr(new $Uint64(4060706939, 3028118405), 348, false), new extFloat.ptr(new $Uint64(3025462433, 2044532855), 375, false), new extFloat.ptr(new $Uint64(2254145170, 1536935362), 402, false), new extFloat.ptr(new $Uint64(3358938053, 3365297469), 428, false), new extFloat.ptr(new $Uint64(2502603868, 4204241075), 455, false), new extFloat.ptr(new $Uint64(3729170365, 2577424355), 481, false), new extFloat.ptr(new $Uint64(2778448436, 3677981733), 508, false), new extFloat.ptr(new $Uint64(4140210802, 2744688476), 534, false), new extFloat.ptr(new $Uint64(3084697427, 1424604878), 561, false), new extFloat.ptr(new $Uint64(2298278679, 4062331362), 588, false), new extFloat.ptr(new $Uint64(3424702107, 3546052773), 614, false), new extFloat.ptr(new $Uint64(2551601907, 2065781727), 641, false), new extFloat.ptr(new $Uint64(3802183132, 2535403578), 667, false), new extFloat.ptr(new $Uint64(2832847187, 1558426518), 694, false), new extFloat.ptr(new $Uint64(4221271257, 2762425404), 720, false), new extFloat.ptr(new $Uint64(3145092172, 2812560400), 747, false), new extFloat.ptr(new $Uint64(2343276271, 3057687578), 774, false), new extFloat.ptr(new $Uint64(3491753744, 2790753324), 800, false), new extFloat.ptr(new $Uint64(2601559269, 3918606633), 827, false), new extFloat.ptr(new $Uint64(3876625403, 2711358621), 853, false), new extFloat.ptr(new $Uint64(2888311001, 1648096297), 880, false), new extFloat.ptr(new $Uint64(2151959390, 2057817989), 907, false), new extFloat.ptr(new $Uint64(3206669376, 61660461), 933, false), new extFloat.ptr(new $Uint64(2389154863, 1581580175), 960, false), new extFloat.ptr(new $Uint64(3560118173, 2626467905), 986, false), new extFloat.ptr(new $Uint64(2652494738, 3034782633), 1013, false), new extFloat.ptr(new $Uint64(3952525166, 3135207385), 1039, false), new extFloat.ptr(new $Uint64(2944860731, 2616258155), 1066, false)]);\n\t\tuint64pow10 = $toNativeArray($kindUint64, [new $Uint64(0, 1), new $Uint64(0, 10), new $Uint64(0, 100), new $Uint64(0, 1000), new $Uint64(0, 10000), new $Uint64(0, 100000), new $Uint64(0, 1000000), new $Uint64(0, 10000000), new $Uint64(0, 100000000), new $Uint64(0, 1000000000), new $Uint64(2, 1410065408), new $Uint64(23, 1215752192), new $Uint64(232, 3567587328), new $Uint64(2328, 1316134912), new $Uint64(23283, 276447232), new $Uint64(232830, 2764472320), new $Uint64(2328306, 1874919424), new $Uint64(23283064, 1569325056), new $Uint64(232830643, 2808348672), new $Uint64(2328306436, 2313682944)]);\n\t\tfloat32info = new floatInfo.ptr(23, 8, -127);\n\t\tfloat64info = new floatInfo.ptr(52, 11, -1023);\n\t\tisPrint16 = new sliceType$4([32, 126, 161, 887, 890, 895, 900, 1366, 1369, 1418, 1421, 1479, 1488, 1514, 1520, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869, 1969, 1984, 2042, 2048, 2093, 2096, 2139, 2142, 2142, 2208, 2237, 2260, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2555, 2561, 2570, 2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2654, 2662, 2677, 2689, 2745, 2748, 2765, 2768, 2768, 2784, 2787, 2790, 2801, 2809, 2809, 2817, 2828, 2831, 2832, 2835, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2915, 2918, 2935, 2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066, 3072, 3129, 3133, 3149, 3157, 3162, 3168, 3171, 3174, 3183, 3192, 3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3329, 3386, 3389, 3407, 3412, 3427, 3430, 3455, 3458, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535, 3551, 3558, 3567, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3716, 3719, 3722, 3725, 3725, 3732, 3751, 3754, 3773, 3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096, 4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789, 4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024, 5109, 5112, 5117, 5120, 5788, 5792, 5880, 5888, 5908, 5920, 5942, 5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6443, 6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809, 6816, 6829, 6832, 6846, 6912, 6987, 6992, 7036, 7040, 7155, 7164, 7223, 7227, 7241, 7245, 7304, 7360, 7367, 7376, 7417, 7424, 7669, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064, 8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305, 8308, 8348, 8352, 8382, 8400, 8432, 8448, 8587, 8592, 9254, 9280, 9290, 9312, 11123, 11126, 11157, 11160, 11193, 11197, 11217, 11244, 11247, 11264, 11507, 11513, 11559, 11565, 11565, 11568, 11623, 11631, 11632, 11647, 11670, 11680, 11844, 11904, 12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543, 12549, 12589, 12593, 12730, 12736, 12771, 12784, 19893, 19904, 40917, 40960, 42124, 42128, 42182, 42192, 42539, 42560, 42743, 42752, 42935, 42999, 43051, 43056, 43065, 43072, 43127, 43136, 43205, 43214, 43225, 43232, 43261, 43264, 43347, 43359, 43388, 43392, 43481, 43486, 43574, 43584, 43597, 43600, 43609, 43612, 43714, 43739, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43877, 43888, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831, 64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056, 65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533]);\n\t\tisNotPrint16 = new sliceType$4([173, 907, 909, 930, 1328, 1376, 1416, 1424, 1757, 2111, 2229, 2274, 2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653, 2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2820, 2857, 2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3076, 3085, 3089, 3113, 3141, 3145, 3159, 3204, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312, 3332, 3341, 3345, 3397, 3401, 3460, 3506, 3516, 3541, 3543, 3715, 3721, 3736, 3744, 3748, 3750, 3756, 3770, 3781, 3783, 3912, 3992, 4029, 4045, 4294, 4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901, 5997, 6001, 6431, 6751, 7415, 8024, 8026, 8028, 8030, 8117, 8133, 8156, 8181, 8335, 9215, 11209, 11311, 11359, 11558, 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, 11930, 12352, 12687, 12831, 13055, 42927, 43470, 43519, 43815, 43823, 64311, 64317, 64319, 64322, 64325, 65107, 65127, 65141, 65511]);\n\t\tisPrint32 = new sliceType$5([65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799, 65843, 65847, 65947, 65952, 65952, 66000, 66045, 66176, 66204, 66208, 66256, 66272, 66299, 66304, 66339, 66352, 66378, 66384, 66426, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66927, 66927, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67640, 67644, 67644, 67647, 67742, 67751, 67759, 67808, 67829, 67835, 67867, 67871, 67897, 67903, 67903, 67968, 68023, 68028, 68047, 68050, 68102, 68108, 68147, 68152, 68154, 68159, 68167, 68176, 68184, 68192, 68255, 68288, 68326, 68331, 68342, 68352, 68405, 68409, 68437, 68440, 68466, 68472, 68497, 68505, 68508, 68521, 68527, 68608, 68680, 68736, 68786, 68800, 68850, 68858, 68863, 69216, 69246, 69632, 69709, 69714, 69743, 69759, 69825, 69840, 69864, 69872, 69881, 69888, 69955, 69968, 70006, 70016, 70093, 70096, 70132, 70144, 70206, 70272, 70313, 70320, 70378, 70384, 70393, 70400, 70412, 70415, 70416, 70419, 70457, 70460, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70749, 70784, 70855, 70864, 70873, 71040, 71093, 71096, 71133, 71168, 71236, 71248, 71257, 71264, 71276, 71296, 71351, 71360, 71369, 71424, 71449, 71453, 71467, 71472, 71487, 71840, 71922, 71935, 71935, 72384, 72440, 72704, 72773, 72784, 72812, 72816, 72847, 72850, 72886, 73728, 74649, 74752, 74868, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92777, 92782, 92783, 92880, 92909, 92912, 92917, 92928, 92997, 93008, 93047, 93053, 93071, 93952, 94020, 94032, 94078, 94095, 94111, 94176, 94176, 94208, 100332, 100352, 101106, 110592, 110593, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113820, 113823, 118784, 119029, 119040, 119078, 119081, 119154, 119163, 119272, 119296, 119365, 119552, 119638, 119648, 119665, 119808, 119967, 119970, 119970, 119973, 119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488, 120779, 120782, 121483, 121499, 121519, 122880, 122904, 122907, 122922, 124928, 125124, 125127, 125142, 125184, 125258, 125264, 125273, 125278, 125279, 126464, 126500, 126503, 126523, 126530, 126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625, 126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136, 127150, 127153, 127221, 127232, 127244, 127248, 127339, 127344, 127404, 127462, 127490, 127504, 127547, 127552, 127560, 127568, 127569, 127744, 128722, 128736, 128748, 128752, 128758, 128768, 128883, 128896, 128980, 129024, 129035, 129040, 129095, 129104, 129113, 129120, 129159, 129168, 129197, 129296, 129319, 129328, 129328, 129331, 129355, 129360, 129374, 129408, 129425, 129472, 129472, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 194560, 195101, 917760, 917999]);\n\t\tisNotPrint32 = new sliceType$4([12, 39, 59, 62, 399, 926, 2057, 2102, 2134, 2291, 2564, 2580, 2584, 4285, 4405, 4576, 4626, 4743, 4745, 4750, 4766, 4868, 4905, 4913, 4916, 5210, 5212, 7177, 7223, 7336, 9327, 27231, 27482, 27490, 54357, 54429, 54445, 54458, 54460, 54468, 54534, 54549, 54557, 54586, 54591, 54597, 54609, 55968, 57351, 57378, 57381, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000, 61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024, 61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098, 61632, 61648, 61743, 63775, 63807]);\n\t\tisGraphic = new sliceType$4([160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288]);\n\t\tshifts = $toNativeArray($kindUint, [0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0]);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"reflect\"] = (function() {\n\tvar $pkg = {}, $init, errors, js, math, runtime, strconv, sync, uncommonType, funcType, name, nameData, mapIter, Type, Kind, tflag, rtype, typeAlg, method, ChanDir, arrayType, chanType, imethod, interfaceType, mapType, ptrType, sliceType, structField, structType, Method, nameOff, typeOff, textOff, StructField, StructTag, fieldScan, Value, flag, ValueError, sliceType$1, ptrType$1, sliceType$2, sliceType$3, mapType$1, structType$1, sliceType$5, ptrType$3, funcType$1, sliceType$6, ptrType$4, ptrType$5, sliceType$7, sliceType$8, ptrType$6, ptrType$7, structType$8, sliceType$9, sliceType$10, sliceType$11, sliceType$12, ptrType$8, ptrType$9, sliceType$14, sliceType$15, ptrType$10, sliceType$16, ptrType$16, sliceType$18, ptrType$17, funcType$3, funcType$4, funcType$5, arrayType$12, ptrType$18, initialized, uncommonTypeMap, nameMap, nameOffList, typeOffList, callHelper, jsObjectPtr, selectHelper, kindNames, methodCache, uint8Type, init, jsType, reflectType, setKindType, newName, newNameOff, newTypeOff, internalStr, isWrapped, copyStruct, makeValue, MakeSlice, TypeOf, ValueOf, FuncOf, SliceOf, Zero, unsafe_New, makeInt, typedmemmove, keyFor, mapaccess, mapassign, mapdelete, mapiterinit, mapiterkey, mapiternext, maplen, cvtDirect, methodReceiver, valueInterface, ifaceE2I, methodName, makeMethodValue, wrapJsObject, unwrapJsObject, getJsTag, chanrecv, chansend, PtrTo, implements$1, directlyAssignable, haveIdenticalUnderlyingType, toType, ifaceIndir, overflowFloat32, New, convertOp, makeFloat, makeComplex, makeString, makeBytes, makeRunes, cvtInt, cvtUint, cvtFloatInt, cvtFloatUint, cvtIntFloat, cvtUintFloat, cvtFloat, cvtComplex, cvtIntString, cvtUintString, cvtBytesString, cvtStringBytes, cvtRunesString, cvtStringRunes, cvtT2I, cvtI2I;\n\terrors = $packages[\"errors\"];\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tmath = $packages[\"math\"];\n\truntime = $packages[\"runtime\"];\n\tstrconv = $packages[\"strconv\"];\n\tsync = $packages[\"sync\"];\n\tuncommonType = $pkg.uncommonType = $newType(0, $kindStruct, \"reflect.uncommonType\", true, \"reflect\", false, function(pkgPath_, mcount_, _$2_, moff_, _$4_, _methods_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.pkgPath = 0;\n\t\t\tthis.mcount = 0;\n\t\t\tthis._$2 = 0;\n\t\t\tthis.moff = 0;\n\t\t\tthis._$4 = 0;\n\t\t\tthis._methods = sliceType$3.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.pkgPath = pkgPath_;\n\t\tthis.mcount = mcount_;\n\t\tthis._$2 = _$2_;\n\t\tthis.moff = moff_;\n\t\tthis._$4 = _$4_;\n\t\tthis._methods = _methods_;\n\t});\n\tfuncType = $pkg.funcType = $newType(0, $kindStruct, \"reflect.funcType\", true, \"reflect\", false, function(rtype_, inCount_, outCount_, _in_, _out_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.inCount = 0;\n\t\t\tthis.outCount = 0;\n\t\t\tthis._in = sliceType$2.nil;\n\t\t\tthis._out = sliceType$2.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.inCount = inCount_;\n\t\tthis.outCount = outCount_;\n\t\tthis._in = _in_;\n\t\tthis._out = _out_;\n\t});\n\tname = $pkg.name = $newType(0, $kindStruct, \"reflect.name\", true, \"reflect\", false, function(bytes_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.bytes = ptrType$5.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.bytes = bytes_;\n\t});\n\tnameData = $pkg.nameData = $newType(0, $kindStruct, \"reflect.nameData\", true, \"reflect\", false, function(name_, tag_, pkgPath_, exported_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = \"\";\n\t\t\tthis.tag = \"\";\n\t\t\tthis.pkgPath = \"\";\n\t\t\tthis.exported = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.tag = tag_;\n\t\tthis.pkgPath = pkgPath_;\n\t\tthis.exported = exported_;\n\t});\n\tmapIter = $pkg.mapIter = $newType(0, $kindStruct, \"reflect.mapIter\", true, \"reflect\", false, function(t_, m_, keys_, i_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.t = $ifaceNil;\n\t\t\tthis.m = null;\n\t\t\tthis.keys = null;\n\t\t\tthis.i = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.t = t_;\n\t\tthis.m = m_;\n\t\tthis.keys = keys_;\n\t\tthis.i = i_;\n\t});\n\tType = $pkg.Type = $newType(8, $kindInterface, \"reflect.Type\", true, \"reflect\", true, null);\n\tKind = $pkg.Kind = $newType(4, $kindUint, \"reflect.Kind\", true, \"reflect\", true, null);\n\ttflag = $pkg.tflag = $newType(1, $kindUint8, \"reflect.tflag\", true, \"reflect\", false, null);\n\trtype = $pkg.rtype = $newType(0, $kindStruct, \"reflect.rtype\", true, \"reflect\", false, function(size_, ptrdata_, hash_, tflag_, align_, fieldAlign_, kind_, alg_, gcdata_, str_, ptrToThis_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.size = 0;\n\t\t\tthis.ptrdata = 0;\n\t\t\tthis.hash = 0;\n\t\t\tthis.tflag = 0;\n\t\t\tthis.align = 0;\n\t\t\tthis.fieldAlign = 0;\n\t\t\tthis.kind = 0;\n\t\t\tthis.alg = ptrType$4.nil;\n\t\t\tthis.gcdata = ptrType$5.nil;\n\t\t\tthis.str = 0;\n\t\t\tthis.ptrToThis = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.size = size_;\n\t\tthis.ptrdata = ptrdata_;\n\t\tthis.hash = hash_;\n\t\tthis.tflag = tflag_;\n\t\tthis.align = align_;\n\t\tthis.fieldAlign = fieldAlign_;\n\t\tthis.kind = kind_;\n\t\tthis.alg = alg_;\n\t\tthis.gcdata = gcdata_;\n\t\tthis.str = str_;\n\t\tthis.ptrToThis = ptrToThis_;\n\t});\n\ttypeAlg = $pkg.typeAlg = $newType(0, $kindStruct, \"reflect.typeAlg\", true, \"reflect\", false, function(hash_, equal_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.hash = $throwNilPointerError;\n\t\t\tthis.equal = $throwNilPointerError;\n\t\t\treturn;\n\t\t}\n\t\tthis.hash = hash_;\n\t\tthis.equal = equal_;\n\t});\n\tmethod = $pkg.method = $newType(0, $kindStruct, \"reflect.method\", true, \"reflect\", false, function(name_, mtyp_, ifn_, tfn_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = 0;\n\t\t\tthis.mtyp = 0;\n\t\t\tthis.ifn = 0;\n\t\t\tthis.tfn = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.mtyp = mtyp_;\n\t\tthis.ifn = ifn_;\n\t\tthis.tfn = tfn_;\n\t});\n\tChanDir = $pkg.ChanDir = $newType(4, $kindInt, \"reflect.ChanDir\", true, \"reflect\", true, null);\n\tarrayType = $pkg.arrayType = $newType(0, $kindStruct, \"reflect.arrayType\", true, \"reflect\", false, function(rtype_, elem_, slice_, len_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.elem = ptrType$1.nil;\n\t\t\tthis.slice = ptrType$1.nil;\n\t\t\tthis.len = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.elem = elem_;\n\t\tthis.slice = slice_;\n\t\tthis.len = len_;\n\t});\n\tchanType = $pkg.chanType = $newType(0, $kindStruct, \"reflect.chanType\", true, \"reflect\", false, function(rtype_, elem_, dir_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.elem = ptrType$1.nil;\n\t\t\tthis.dir = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.elem = elem_;\n\t\tthis.dir = dir_;\n\t});\n\timethod = $pkg.imethod = $newType(0, $kindStruct, \"reflect.imethod\", true, \"reflect\", false, function(name_, typ_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = 0;\n\t\t\tthis.typ = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.typ = typ_;\n\t});\n\tinterfaceType = $pkg.interfaceType = $newType(0, $kindStruct, \"reflect.interfaceType\", true, \"reflect\", false, function(rtype_, pkgPath_, methods_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.pkgPath = new name.ptr(ptrType$5.nil);\n\t\t\tthis.methods = sliceType$7.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.pkgPath = pkgPath_;\n\t\tthis.methods = methods_;\n\t});\n\tmapType = $pkg.mapType = $newType(0, $kindStruct, \"reflect.mapType\", true, \"reflect\", false, function(rtype_, key_, elem_, bucket_, hmap_, keysize_, indirectkey_, valuesize_, indirectvalue_, bucketsize_, reflexivekey_, needkeyupdate_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.key = ptrType$1.nil;\n\t\t\tthis.elem = ptrType$1.nil;\n\t\t\tthis.bucket = ptrType$1.nil;\n\t\t\tthis.hmap = ptrType$1.nil;\n\t\t\tthis.keysize = 0;\n\t\t\tthis.indirectkey = 0;\n\t\t\tthis.valuesize = 0;\n\t\t\tthis.indirectvalue = 0;\n\t\t\tthis.bucketsize = 0;\n\t\t\tthis.reflexivekey = false;\n\t\t\tthis.needkeyupdate = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.key = key_;\n\t\tthis.elem = elem_;\n\t\tthis.bucket = bucket_;\n\t\tthis.hmap = hmap_;\n\t\tthis.keysize = keysize_;\n\t\tthis.indirectkey = indirectkey_;\n\t\tthis.valuesize = valuesize_;\n\t\tthis.indirectvalue = indirectvalue_;\n\t\tthis.bucketsize = bucketsize_;\n\t\tthis.reflexivekey = reflexivekey_;\n\t\tthis.needkeyupdate = needkeyupdate_;\n\t});\n\tptrType = $pkg.ptrType = $newType(0, $kindStruct, \"reflect.ptrType\", true, \"reflect\", false, function(rtype_, elem_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.elem = ptrType$1.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.elem = elem_;\n\t});\n\tsliceType = $pkg.sliceType = $newType(0, $kindStruct, \"reflect.sliceType\", true, \"reflect\", false, function(rtype_, elem_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.elem = ptrType$1.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.elem = elem_;\n\t});\n\tstructField = $pkg.structField = $newType(0, $kindStruct, \"reflect.structField\", true, \"reflect\", false, function(name_, typ_, offset_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.name = new name.ptr(ptrType$5.nil);\n\t\t\tthis.typ = ptrType$1.nil;\n\t\t\tthis.offset = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.name = name_;\n\t\tthis.typ = typ_;\n\t\tthis.offset = offset_;\n\t});\n\tstructType = $pkg.structType = $newType(0, $kindStruct, \"reflect.structType\", true, \"reflect\", false, function(rtype_, pkgPath_, fields_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rtype = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t\tthis.pkgPath = new name.ptr(ptrType$5.nil);\n\t\t\tthis.fields = sliceType$8.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.rtype = rtype_;\n\t\tthis.pkgPath = pkgPath_;\n\t\tthis.fields = fields_;\n\t});\n\tMethod = $pkg.Method = $newType(0, $kindStruct, \"reflect.Method\", true, \"reflect\", true, function(Name_, PkgPath_, Type_, Func_, Index_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Name = \"\";\n\t\t\tthis.PkgPath = \"\";\n\t\t\tthis.Type = $ifaceNil;\n\t\t\tthis.Func = new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t\tthis.Index = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.Name = Name_;\n\t\tthis.PkgPath = PkgPath_;\n\t\tthis.Type = Type_;\n\t\tthis.Func = Func_;\n\t\tthis.Index = Index_;\n\t});\n\tnameOff = $pkg.nameOff = $newType(4, $kindInt32, \"reflect.nameOff\", true, \"reflect\", false, null);\n\ttypeOff = $pkg.typeOff = $newType(4, $kindInt32, \"reflect.typeOff\", true, \"reflect\", false, null);\n\ttextOff = $pkg.textOff = $newType(4, $kindInt32, \"reflect.textOff\", true, \"reflect\", false, null);\n\tStructField = $pkg.StructField = $newType(0, $kindStruct, \"reflect.StructField\", true, \"reflect\", true, function(Name_, PkgPath_, Type_, Tag_, Offset_, Index_, Anonymous_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Name = \"\";\n\t\t\tthis.PkgPath = \"\";\n\t\t\tthis.Type = $ifaceNil;\n\t\t\tthis.Tag = \"\";\n\t\t\tthis.Offset = 0;\n\t\t\tthis.Index = sliceType$14.nil;\n\t\t\tthis.Anonymous = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.Name = Name_;\n\t\tthis.PkgPath = PkgPath_;\n\t\tthis.Type = Type_;\n\t\tthis.Tag = Tag_;\n\t\tthis.Offset = Offset_;\n\t\tthis.Index = Index_;\n\t\tthis.Anonymous = Anonymous_;\n\t});\n\tStructTag = $pkg.StructTag = $newType(8, $kindString, \"reflect.StructTag\", true, \"reflect\", true, null);\n\tfieldScan = $pkg.fieldScan = $newType(0, $kindStruct, \"reflect.fieldScan\", true, \"reflect\", false, function(typ_, index_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.typ = ptrType$10.nil;\n\t\t\tthis.index = sliceType$14.nil;\n\t\t\treturn;\n\t\t}\n\t\tthis.typ = typ_;\n\t\tthis.index = index_;\n\t});\n\tValue = $pkg.Value = $newType(0, $kindStruct, \"reflect.Value\", true, \"reflect\", true, function(typ_, ptr_, flag_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.typ = ptrType$1.nil;\n\t\t\tthis.ptr = 0;\n\t\t\tthis.flag = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.typ = typ_;\n\t\tthis.ptr = ptr_;\n\t\tthis.flag = flag_;\n\t});\n\tflag = $pkg.flag = $newType(4, $kindUintptr, \"reflect.flag\", true, \"reflect\", false, null);\n\tValueError = $pkg.ValueError = $newType(0, $kindStruct, \"reflect.ValueError\", true, \"reflect\", true, function(Method_, Kind_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.Method = \"\";\n\t\t\tthis.Kind = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.Method = Method_;\n\t\tthis.Kind = Kind_;\n\t});\n\tsliceType$1 = $sliceType(name);\n\tptrType$1 = $ptrType(rtype);\n\tsliceType$2 = $sliceType(ptrType$1);\n\tsliceType$3 = $sliceType(method);\n\tmapType$1 = $mapType(ptrType$1, sliceType$3);\n\tstructType$1 = $structType(\"reflect\", [{prop: \"RWMutex\", name: \"\", exported: true, typ: sync.RWMutex, tag: \"\"}, {prop: \"m\", name: \"m\", exported: false, typ: mapType$1, tag: \"\"}]);\n\tsliceType$5 = $sliceType($emptyInterface);\n\tptrType$3 = $ptrType(js.Object);\n\tfuncType$1 = $funcType([sliceType$5], [ptrType$3], true);\n\tsliceType$6 = $sliceType($String);\n\tptrType$4 = $ptrType(typeAlg);\n\tptrType$5 = $ptrType($Uint8);\n\tsliceType$7 = $sliceType(imethod);\n\tsliceType$8 = $sliceType(structField);\n\tptrType$6 = $ptrType(uncommonType);\n\tptrType$7 = $ptrType(nameData);\n\tstructType$8 = $structType(\"reflect\", [{prop: \"str\", name: \"str\", exported: false, typ: $String, tag: \"\"}]);\n\tsliceType$9 = $sliceType(ptrType$3);\n\tsliceType$10 = $sliceType(Value);\n\tsliceType$11 = $sliceType(Type);\n\tsliceType$12 = $sliceType(sliceType$9);\n\tptrType$8 = $ptrType(interfaceType);\n\tptrType$9 = $ptrType(imethod);\n\tsliceType$14 = $sliceType($Int);\n\tsliceType$15 = $sliceType(fieldScan);\n\tptrType$10 = $ptrType(structType);\n\tsliceType$16 = $sliceType($Uint8);\n\tptrType$16 = $ptrType($UnsafePointer);\n\tsliceType$18 = $sliceType($Int32);\n\tptrType$17 = $ptrType(funcType);\n\tfuncType$3 = $funcType([$String], [$Bool], false);\n\tfuncType$4 = $funcType([$UnsafePointer, $Uintptr], [$Uintptr], false);\n\tfuncType$5 = $funcType([$UnsafePointer, $UnsafePointer], [$Bool], false);\n\tarrayType$12 = $arrayType($Uintptr, 2);\n\tptrType$18 = $ptrType(ValueError);\n\tinit = function() {\n\t\tvar $ptr, used, x, x$1, x$10, x$11, x$12, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; used = $f.used; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$12 = $f.x$12; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tused = (function(i) {\n\t\t\tvar $ptr, i;\n\t\t});\n\t\t$r = used((x = new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), new x.constructor.elem(x))); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$1 = new uncommonType.ptr(0, 0, 0, 0, 0, sliceType$3.nil), new x$1.constructor.elem(x$1))); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$2 = new method.ptr(0, 0, 0, 0), new x$2.constructor.elem(x$2))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$3 = new arrayType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), ptrType$1.nil, ptrType$1.nil, 0), new x$3.constructor.elem(x$3))); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$4 = new chanType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), ptrType$1.nil, 0), new x$4.constructor.elem(x$4))); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$5 = new funcType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), 0, 0, sliceType$2.nil, sliceType$2.nil), new x$5.constructor.elem(x$5))); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$6 = new interfaceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), new name.ptr(ptrType$5.nil), sliceType$7.nil), new x$6.constructor.elem(x$6))); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$7 = new mapType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, 0, 0, 0, 0, 0, false, false), new x$7.constructor.elem(x$7))); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$8 = new ptrType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), ptrType$1.nil), new x$8.constructor.elem(x$8))); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$9 = new sliceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), ptrType$1.nil), new x$9.constructor.elem(x$9))); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$10 = new structType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), new name.ptr(ptrType$5.nil), sliceType$8.nil), new x$10.constructor.elem(x$10))); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$11 = new imethod.ptr(0, 0), new x$11.constructor.elem(x$11))); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = used((x$12 = new structField.ptr(new name.ptr(ptrType$5.nil), ptrType$1.nil, 0), new x$12.constructor.elem(x$12))); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tinitialized = true;\n\t\tuint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: init }; } $f.$ptr = $ptr; $f.used = used; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$12 = x$12; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tjsType = function(typ) {\n\t\tvar $ptr, typ;\n\t\treturn typ.jsType;\n\t};\n\treflectType = function(typ) {\n\t\tvar $ptr, _1, _i, _i$1, _i$2, _i$3, _i$4, _key, _ref, _ref$1, _ref$2, _ref$3, _ref$4, dir, f, fields, i, i$1, i$2, i$3, i$4, imethods, in$1, m, m$1, methodSet, methods, out, outCount, params, reflectFields, reflectMethods, results, rt, typ, ut;\n\t\tif (typ.reflectType === undefined) {\n\t\t\trt = new rtype.ptr((($parseInt(typ.size) >> 0) >>> 0), 0, 0, 0, 0, 0, (($parseInt(typ.kind) >> 0) << 24 >>> 24), ptrType$4.nil, ptrType$5.nil, newNameOff($clone(newName(internalStr(typ.string), \"\", \"\", !!(typ.exported)), name)), 0);\n\t\t\trt.jsType = typ;\n\t\t\ttyp.reflectType = rt;\n\t\t\tmethodSet = $methodSet(typ);\n\t\t\tif (!(($parseInt(methodSet.length) === 0)) || !!(typ.named)) {\n\t\t\t\trt.tflag = (rt.tflag | (1)) >>> 0;\n\t\t\t\tif (!!(typ.named)) {\n\t\t\t\t\trt.tflag = (rt.tflag | (4)) >>> 0;\n\t\t\t\t}\n\t\t\t\treflectMethods = $makeSlice(sliceType$3, $parseInt(methodSet.length));\n\t\t\t\t_ref = reflectMethods;\n\t\t\t\t_i = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\t\t\ti = _i;\n\t\t\t\t\tm = methodSet[i];\n\t\t\t\t\tmethod.copy(((i < 0 || i >= reflectMethods.$length) ? $throwRuntimeError(\"index out of range\") : reflectMethods.$array[reflectMethods.$offset + i]), new method.ptr(newNameOff($clone(newName(internalStr(m.name), \"\", \"\", internalStr(m.pkg) === \"\"), name)), newTypeOff(reflectType(m.typ)), 0, 0));\n\t\t\t\t\t_i++;\n\t\t\t\t}\n\t\t\t\tut = new uncommonType.ptr(newNameOff($clone(newName(internalStr(typ.pkg), \"\", \"\", false), name)), ($parseInt(methodSet.length) << 16 >>> 16), 0, 0, 0, reflectMethods);\n\t\t\t\t_key = rt; (uncommonTypeMap || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$1.keyFor(_key)] = { k: _key, v: ut };\n\t\t\t\tut.jsType = typ;\n\t\t\t}\n\t\t\t_1 = rt.Kind();\n\t\t\tif (_1 === (17)) {\n\t\t\t\tsetKindType(rt, new arrayType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), reflectType(typ.elem), ptrType$1.nil, (($parseInt(typ.len) >> 0) >>> 0)));\n\t\t\t} else if (_1 === (18)) {\n\t\t\t\tdir = 3;\n\t\t\t\tif (!!(typ.sendOnly)) {\n\t\t\t\t\tdir = 2;\n\t\t\t\t}\n\t\t\t\tif (!!(typ.recvOnly)) {\n\t\t\t\t\tdir = 1;\n\t\t\t\t}\n\t\t\t\tsetKindType(rt, new chanType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), reflectType(typ.elem), (dir >>> 0)));\n\t\t\t} else if (_1 === (19)) {\n\t\t\t\tparams = typ.params;\n\t\t\t\tin$1 = $makeSlice(sliceType$2, $parseInt(params.length));\n\t\t\t\t_ref$1 = in$1;\n\t\t\t\t_i$1 = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\t\t\ti$1 = _i$1;\n\t\t\t\t\t((i$1 < 0 || i$1 >= in$1.$length) ? $throwRuntimeError(\"index out of range\") : in$1.$array[in$1.$offset + i$1] = reflectType(params[i$1]));\n\t\t\t\t\t_i$1++;\n\t\t\t\t}\n\t\t\t\tresults = typ.results;\n\t\t\t\tout = $makeSlice(sliceType$2, $parseInt(results.length));\n\t\t\t\t_ref$2 = out;\n\t\t\t\t_i$2 = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(_i$2 < _ref$2.$length)) { break; }\n\t\t\t\t\ti$2 = _i$2;\n\t\t\t\t\t((i$2 < 0 || i$2 >= out.$length) ? $throwRuntimeError(\"index out of range\") : out.$array[out.$offset + i$2] = reflectType(results[i$2]));\n\t\t\t\t\t_i$2++;\n\t\t\t\t}\n\t\t\t\toutCount = ($parseInt(results.length) << 16 >>> 16);\n\t\t\t\tif (!!(typ.variadic)) {\n\t\t\t\t\toutCount = (outCount | (32768)) >>> 0;\n\t\t\t\t}\n\t\t\t\tsetKindType(rt, new funcType.ptr($clone(rt, rtype), ($parseInt(params.length) << 16 >>> 16), outCount, in$1, out));\n\t\t\t} else if (_1 === (20)) {\n\t\t\t\tmethods = typ.methods;\n\t\t\t\timethods = $makeSlice(sliceType$7, $parseInt(methods.length));\n\t\t\t\t_ref$3 = imethods;\n\t\t\t\t_i$3 = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(_i$3 < _ref$3.$length)) { break; }\n\t\t\t\t\ti$3 = _i$3;\n\t\t\t\t\tm$1 = methods[i$3];\n\t\t\t\t\timethod.copy(((i$3 < 0 || i$3 >= imethods.$length) ? $throwRuntimeError(\"index out of range\") : imethods.$array[imethods.$offset + i$3]), new imethod.ptr(newNameOff($clone(newName(internalStr(m$1.name), \"\", \"\", internalStr(m$1.pkg) === \"\"), name)), newTypeOff(reflectType(m$1.typ))));\n\t\t\t\t\t_i$3++;\n\t\t\t\t}\n\t\t\t\tsetKindType(rt, new interfaceType.ptr($clone(rt, rtype), new name.ptr(ptrType$5.nil), imethods));\n\t\t\t} else if (_1 === (21)) {\n\t\t\t\tsetKindType(rt, new mapType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), reflectType(typ.key), reflectType(typ.elem), ptrType$1.nil, ptrType$1.nil, 0, 0, 0, 0, 0, false, false));\n\t\t\t} else if (_1 === (22)) {\n\t\t\t\tsetKindType(rt, new ptrType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), reflectType(typ.elem)));\n\t\t\t} else if (_1 === (23)) {\n\t\t\t\tsetKindType(rt, new sliceType.ptr(new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0), reflectType(typ.elem)));\n\t\t\t} else if (_1 === (25)) {\n\t\t\t\tfields = typ.fields;\n\t\t\t\treflectFields = $makeSlice(sliceType$8, $parseInt(fields.length));\n\t\t\t\t_ref$4 = reflectFields;\n\t\t\t\t_i$4 = 0;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (!(_i$4 < _ref$4.$length)) { break; }\n\t\t\t\t\ti$4 = _i$4;\n\t\t\t\t\tf = fields[i$4];\n\t\t\t\t\tstructField.copy(((i$4 < 0 || i$4 >= reflectFields.$length) ? $throwRuntimeError(\"index out of range\") : reflectFields.$array[reflectFields.$offset + i$4]), new structField.ptr($clone(newName(internalStr(f.name), internalStr(f.tag), \"\", !!(f.exported)), name), reflectType(f.typ), (i$4 >>> 0)));\n\t\t\t\t\t_i$4++;\n\t\t\t\t}\n\t\t\t\tsetKindType(rt, new structType.ptr($clone(rt, rtype), $clone(newName(internalStr(typ.pkgPath), \"\", \"\", false), name), reflectFields));\n\t\t\t}\n\t\t}\n\t\treturn typ.reflectType;\n\t};\n\tsetKindType = function(rt, kindType) {\n\t\tvar $ptr, kindType, rt;\n\t\trt.kindType = kindType;\n\t\tkindType.rtype = rt;\n\t};\n\tuncommonType.ptr.prototype.methods = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn t._methods;\n\t};\n\tuncommonType.prototype.methods = function() { return this.$val.methods(); };\n\trtype.ptr.prototype.uncommon = function() {\n\t\tvar $ptr, _entry, t;\n\t\tt = this;\n\t\treturn (_entry = uncommonTypeMap[ptrType$1.keyFor(t)], _entry !== undefined ? _entry.v : ptrType$6.nil);\n\t};\n\trtype.prototype.uncommon = function() { return this.$val.uncommon(); };\n\tfuncType.ptr.prototype.in$ = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn t._in;\n\t};\n\tfuncType.prototype.in$ = function() { return this.$val.in$(); };\n\tfuncType.ptr.prototype.out = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn t._out;\n\t};\n\tfuncType.prototype.out = function() { return this.$val.out(); };\n\tname.ptr.prototype.name = function() {\n\t\tvar $ptr, _entry, n, s;\n\t\ts = \"\";\n\t\tn = this;\n\t\ts = (_entry = nameMap[ptrType$5.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$7.nil).name;\n\t\treturn s;\n\t};\n\tname.prototype.name = function() { return this.$val.name(); };\n\tname.ptr.prototype.tag = function() {\n\t\tvar $ptr, _entry, n, s;\n\t\ts = \"\";\n\t\tn = this;\n\t\ts = (_entry = nameMap[ptrType$5.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$7.nil).tag;\n\t\treturn s;\n\t};\n\tname.prototype.tag = function() { return this.$val.tag(); };\n\tname.ptr.prototype.pkgPath = function() {\n\t\tvar $ptr, _entry, n;\n\t\tn = this;\n\t\treturn (_entry = nameMap[ptrType$5.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$7.nil).pkgPath;\n\t};\n\tname.prototype.pkgPath = function() { return this.$val.pkgPath(); };\n\tname.ptr.prototype.isExported = function() {\n\t\tvar $ptr, _entry, n;\n\t\tn = this;\n\t\treturn (_entry = nameMap[ptrType$5.keyFor(n.bytes)], _entry !== undefined ? _entry.v : ptrType$7.nil).exported;\n\t};\n\tname.prototype.isExported = function() { return this.$val.isExported(); };\n\tnewName = function(n, tag, pkgPath, exported) {\n\t\tvar $ptr, _key, b, exported, n, pkgPath, tag;\n\t\tb = $newDataPointer(0, ptrType$5);\n\t\t_key = b; (nameMap || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$5.keyFor(_key)] = { k: _key, v: new nameData.ptr(n, tag, pkgPath, exported) };\n\t\treturn new name.ptr(b);\n\t};\n\trtype.ptr.prototype.nameOff = function(off) {\n\t\tvar $ptr, off, t, x;\n\t\tt = this;\n\t\treturn (x = (off >> 0), ((x < 0 || x >= nameOffList.$length) ? $throwRuntimeError(\"index out of range\") : nameOffList.$array[nameOffList.$offset + x]));\n\t};\n\trtype.prototype.nameOff = function(off) { return this.$val.nameOff(off); };\n\tnewNameOff = function(n) {\n\t\tvar $ptr, i, n;\n\t\ti = nameOffList.$length;\n\t\tnameOffList = $append(nameOffList, n);\n\t\treturn (i >> 0);\n\t};\n\trtype.ptr.prototype.typeOff = function(off) {\n\t\tvar $ptr, off, t, x;\n\t\tt = this;\n\t\treturn (x = (off >> 0), ((x < 0 || x >= typeOffList.$length) ? $throwRuntimeError(\"index out of range\") : typeOffList.$array[typeOffList.$offset + x]));\n\t};\n\trtype.prototype.typeOff = function(off) { return this.$val.typeOff(off); };\n\tnewTypeOff = function(t) {\n\t\tvar $ptr, i, t;\n\t\ti = typeOffList.$length;\n\t\ttypeOffList = $append(typeOffList, t);\n\t\treturn (i >> 0);\n\t};\n\tinternalStr = function(strObj) {\n\t\tvar $ptr, c, strObj;\n\t\tc = new structType$8.ptr(\"\");\n\t\tc.str = strObj;\n\t\treturn c.str;\n\t};\n\tisWrapped = function(typ) {\n\t\tvar $ptr, typ;\n\t\treturn !!(jsType(typ).wrapped);\n\t};\n\tcopyStruct = function(dst, src, typ) {\n\t\tvar $ptr, dst, fields, i, prop, src, typ;\n\t\tfields = jsType(typ).fields;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < $parseInt(fields.length))) { break; }\n\t\t\tprop = $internalize(fields[i].prop, $String);\n\t\t\tdst[$externalize(prop, $String)] = src[$externalize(prop, $String)];\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t};\n\tmakeValue = function(t, v, fl) {\n\t\tvar $ptr, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _v, _v$1, fl, rt, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _v = $f._v; _v$1 = $f._v$1; fl = $f.fl; rt = $f.rt; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\trt = _r;\n\t\t_r$1 = t.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tif (_r$1 === 17) { _v$1 = true; $s = 5; continue s; }\n\t\t_r$2 = t.Kind(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t_v$1 = _r$2 === 25; case 5:\n\t\tif (_v$1) { _v = true; $s = 4; continue s; }\n\t\t_r$3 = t.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t_v = _r$3 === 22; case 4:\n\t\t/* */ if (_v) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (_v) { */ case 2:\n\t\t\t_r$4 = t.Kind(); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return new Value.ptr(rt, v, (fl | (_r$4 >>> 0)) >>> 0);\n\t\t/* } */ case 3:\n\t\t_r$5 = t.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }\n\t\t$s = -1; return new Value.ptr(rt, $newDataPointer(v, jsType(rt.ptrTo())), (((fl | (_r$5 >>> 0)) >>> 0) | 128) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeValue }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._v = _v; $f._v$1 = _v$1; $f.fl = fl; $f.rt = rt; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tMakeSlice = function(typ, len, cap) {\n\t\tvar $ptr, _r, _r$1, cap, len, typ, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; cap = $f.cap; len = $f.len; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ttyp = [typ];\n\t\t_r = typ[0].Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (!((_r === 23))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((_r === 23))) { */ case 1:\n\t\t\t$panic(new $String(\"reflect.MakeSlice of non-slice type\"));\n\t\t/* } */ case 2:\n\t\tif (len < 0) {\n\t\t\t$panic(new $String(\"reflect.MakeSlice: negative len\"));\n\t\t}\n\t\tif (cap < 0) {\n\t\t\t$panic(new $String(\"reflect.MakeSlice: negative cap\"));\n\t\t}\n\t\tif (len > cap) {\n\t\t\t$panic(new $String(\"reflect.MakeSlice: len > cap\"));\n\t\t}\n\t\t_r$1 = makeValue(typ[0], $makeSlice(jsType(typ[0]), len, cap, (function(typ) { return function $b() {\n\t\t\tvar $ptr, _r$1, _r$2, $s, $r;\n\t\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r$1 = $f._r$1; _r$2 = $f._r$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t\t_r$1 = typ[0].Elem(); /* */ $s = 1; case 1: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t_r$2 = jsType(_r$1); /* */ $s = 2; case 2: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return _r$2.zero();\n\t\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f.$ptr = $ptr; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.$s = $s; $f.$r = $r; return $f;\n\t\t}; })(typ)), 0); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: MakeSlice }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.cap = cap; $f.len = len; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.MakeSlice = MakeSlice;\n\tTypeOf = function(i) {\n\t\tvar $ptr, i;\n\t\tif (!initialized) {\n\t\t\treturn new rtype.ptr(0, 0, 0, 0, 0, 0, 0, ptrType$4.nil, ptrType$5.nil, 0, 0);\n\t\t}\n\t\tif ($interfaceIsEqual(i, $ifaceNil)) {\n\t\t\treturn $ifaceNil;\n\t\t}\n\t\treturn reflectType(i.constructor);\n\t};\n\t$pkg.TypeOf = TypeOf;\n\tValueOf = function(i) {\n\t\tvar $ptr, _r, i, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; i = $f.i; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tif ($interfaceIsEqual(i, $ifaceNil)) {\n\t\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t}\n\t\t_r = makeValue(reflectType(i.constructor), i.$val, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ValueOf }; } $f.$ptr = $ptr; $f._r = _r; $f.i = i; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.ValueOf = ValueOf;\n\tFuncOf = function(in$1, out, variadic) {\n\t\tvar $ptr, _i, _i$1, _r, _ref, _ref$1, _v, _v$1, i, i$1, in$1, jsIn, jsOut, out, v, v$1, variadic, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; _v = $f._v; _v$1 = $f._v$1; i = $f.i; i$1 = $f.i$1; in$1 = $f.in$1; jsIn = $f.jsIn; jsOut = $f.jsOut; out = $f.out; v = $f.v; v$1 = $f.v$1; variadic = $f.variadic; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tif (!(variadic)) { _v = false; $s = 3; continue s; }\n\t\tif (in$1.$length === 0) { _v$1 = true; $s = 4; continue s; }\n\t\t_r = (x = in$1.$length - 1 >> 0, ((x < 0 || x >= in$1.$length) ? $throwRuntimeError(\"index out of range\") : in$1.$array[in$1.$offset + x])).Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_v$1 = !((_r === 23)); case 4:\n\t\t_v = _v$1; case 3:\n\t\t/* */ if (_v) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (_v) { */ case 1:\n\t\t\t$panic(new $String(\"reflect.FuncOf: last arg of variadic func must be slice\"));\n\t\t/* } */ case 2:\n\t\tjsIn = $makeSlice(sliceType$9, in$1.$length);\n\t\t_ref = in$1;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\tv = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t((i < 0 || i >= jsIn.$length) ? $throwRuntimeError(\"index out of range\") : jsIn.$array[jsIn.$offset + i] = jsType(v));\n\t\t\t_i++;\n\t\t}\n\t\tjsOut = $makeSlice(sliceType$9, out.$length);\n\t\t_ref$1 = out;\n\t\t_i$1 = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\ti$1 = _i$1;\n\t\t\tv$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? $throwRuntimeError(\"index out of range\") : _ref$1.$array[_ref$1.$offset + _i$1]);\n\t\t\t((i$1 < 0 || i$1 >= jsOut.$length) ? $throwRuntimeError(\"index out of range\") : jsOut.$array[jsOut.$offset + i$1] = jsType(v$1));\n\t\t\t_i$1++;\n\t\t}\n\t\t$s = -1; return reflectType($funcType($externalize(jsIn, sliceType$9), $externalize(jsOut, sliceType$9), $externalize(variadic, $Bool)));\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: FuncOf }; } $f.$ptr = $ptr; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f._v = _v; $f._v$1 = _v$1; $f.i = i; $f.i$1 = i$1; $f.in$1 = in$1; $f.jsIn = jsIn; $f.jsOut = jsOut; $f.out = out; $f.v = v; $f.v$1 = v$1; $f.variadic = variadic; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.FuncOf = FuncOf;\n\trtype.ptr.prototype.ptrTo = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn reflectType($ptrType(jsType(t)));\n\t};\n\trtype.prototype.ptrTo = function() { return this.$val.ptrTo(); };\n\tSliceOf = function(t) {\n\t\tvar $ptr, t;\n\t\treturn reflectType($sliceType(jsType(t)));\n\t};\n\t$pkg.SliceOf = SliceOf;\n\tZero = function(typ) {\n\t\tvar $ptr, _r, typ, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeValue(typ, jsType(typ).zero(), 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Zero }; } $f.$ptr = $ptr; $f._r = _r; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.Zero = Zero;\n\tunsafe_New = function(typ) {\n\t\tvar $ptr, _1, typ;\n\t\t_1 = typ.Kind();\n\t\tif (_1 === (25)) {\n\t\t\treturn new (jsType(typ).ptr)();\n\t\t} else if (_1 === (17)) {\n\t\t\treturn jsType(typ).zero();\n\t\t} else {\n\t\t\treturn $newDataPointer(jsType(typ).zero(), jsType(typ.ptrTo()));\n\t\t}\n\t};\n\tmakeInt = function(f, bits, t) {\n\t\tvar $ptr, _1, _r, bits, f, ptr, t, typ, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; bits = $f.bits; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\ttyp = _r;\n\t\tptr = unsafe_New(typ);\n\t\t_1 = typ.Kind();\n\t\tif (_1 === (3)) {\n\t\t\tptr.$set((bits.$low << 24 >> 24));\n\t\t} else if (_1 === (4)) {\n\t\t\tptr.$set((bits.$low << 16 >> 16));\n\t\t} else if ((_1 === (2)) || (_1 === (5))) {\n\t\t\tptr.$set((bits.$low >> 0));\n\t\t} else if (_1 === (6)) {\n\t\t\tptr.$set(new $Int64(bits.$high, bits.$low));\n\t\t} else if (_1 === (8)) {\n\t\t\tptr.$set((bits.$low << 24 >>> 24));\n\t\t} else if (_1 === (9)) {\n\t\t\tptr.$set((bits.$low << 16 >>> 16));\n\t\t} else if ((_1 === (7)) || (_1 === (10)) || (_1 === (12))) {\n\t\t\tptr.$set((bits.$low >>> 0));\n\t\t} else if (_1 === (11)) {\n\t\t\tptr.$set(bits);\n\t\t}\n\t\t$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeInt }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f.bits = bits; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\ttypedmemmove = function(t, dst, src) {\n\t\tvar $ptr, dst, src, t;\n\t\tdst.$set(src.$get());\n\t};\n\tkeyFor = function(t, key) {\n\t\tvar $ptr, k, key, kv, t;\n\t\tkv = key;\n\t\tif (!(kv.$get === undefined)) {\n\t\t\tkv = kv.$get();\n\t\t}\n\t\tk = $internalize(jsType(t.Key()).keyFor(kv), $String);\n\t\treturn [kv, k];\n\t};\n\tmapaccess = function(t, m, key) {\n\t\tvar $ptr, _tuple, entry, k, key, m, t;\n\t\t_tuple = keyFor(t, key);\n\t\tk = _tuple[1];\n\t\tentry = m[$externalize(k, $String)];\n\t\tif (entry === undefined) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn $newDataPointer(entry.v, jsType(PtrTo(t.Elem())));\n\t};\n\tmapassign = function(t, m, key, val) {\n\t\tvar $ptr, _r, _tuple, entry, et, jsVal, k, key, kv, m, newVal, t, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; entry = $f.entry; et = $f.et; jsVal = $f.jsVal; k = $f.k; key = $f.key; kv = $f.kv; m = $f.m; newVal = $f.newVal; t = $f.t; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_tuple = keyFor(t, key);\n\t\tkv = _tuple[0];\n\t\tk = _tuple[1];\n\t\tjsVal = val.$get();\n\t\tet = t.Elem();\n\t\t_r = et.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (_r === 25) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (_r === 25) { */ case 1:\n\t\t\tnewVal = jsType(et).zero();\n\t\t\tcopyStruct(newVal, jsVal, et);\n\t\t\tjsVal = newVal;\n\t\t/* } */ case 2:\n\t\tentry = new ($global.Object)();\n\t\tentry.k = kv;\n\t\tentry.v = jsVal;\n\t\tm[$externalize(k, $String)] = entry;\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: mapassign }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.entry = entry; $f.et = et; $f.jsVal = jsVal; $f.k = k; $f.key = key; $f.kv = kv; $f.m = m; $f.newVal = newVal; $f.t = t; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmapdelete = function(t, m, key) {\n\t\tvar $ptr, _tuple, k, key, m, t;\n\t\t_tuple = keyFor(t, key);\n\t\tk = _tuple[1];\n\t\tdelete m[$externalize(k, $String)];\n\t};\n\tmapiterinit = function(t, m) {\n\t\tvar $ptr, m, t;\n\t\treturn new mapIter.ptr(t, m, $keys(m), 0);\n\t};\n\tmapiterkey = function(it) {\n\t\tvar $ptr, _r, _r$1, _r$2, it, iter, k, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; it = $f.it; iter = $f.iter; k = $f.k; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\titer = it;\n\t\tk = iter.keys[iter.i];\n\t\t_r = iter.t.Key(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r$1 = PtrTo(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_r$2 = jsType(_r$1); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t$s = -1; return $newDataPointer(iter.m[$externalize($internalize(k, $String), $String)].k, _r$2);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: mapiterkey }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.it = it; $f.iter = iter; $f.k = k; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmapiternext = function(it) {\n\t\tvar $ptr, it, iter;\n\t\titer = it;\n\t\titer.i = iter.i + (1) >> 0;\n\t};\n\tmaplen = function(m) {\n\t\tvar $ptr, m;\n\t\treturn $parseInt($keys(m).length);\n\t};\n\tcvtDirect = function(v, typ) {\n\t\tvar $ptr, _1, _arg, _arg$1, _arg$2, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, k, slice, srcVal, typ, v, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; k = $f.k; slice = $f.slice; srcVal = $f.srcVal; typ = $f.typ; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tsrcVal = $clone(v, Value).object();\n\t\t/* */ if (srcVal === jsType(v.typ).nil) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (srcVal === jsType(v.typ).nil) { */ case 1:\n\t\t\t_r = makeValue(typ, jsType(typ).nil, v.flag); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return _r;\n\t\t/* } */ case 2:\n\t\tval = null;\n\t\t\t_r$1 = typ.Kind(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\tk = _r$1;\n\t\t\t_1 = k;\n\t\t\t/* */ if (_1 === (23)) { $s = 6; continue; }\n\t\t\t/* */ if (_1 === (22)) { $s = 7; continue; }\n\t\t\t/* */ if (_1 === (25)) { $s = 8; continue; }\n\t\t\t/* */ if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24))) { $s = 9; continue; }\n\t\t\t/* */ $s = 10; continue;\n\t\t\t/* if (_1 === (23)) { */ case 6:\n\t\t\t\tslice = new (jsType(typ))(srcVal.$array);\n\t\t\t\tslice.$offset = srcVal.$offset;\n\t\t\t\tslice.$length = srcVal.$length;\n\t\t\t\tslice.$capacity = srcVal.$capacity;\n\t\t\t\tval = $newDataPointer(slice, jsType(PtrTo(typ)));\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else if (_1 === (22)) { */ case 7:\n\t\t\t\t_r$2 = typ.Elem(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_r$3 = _r$2.Kind(); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t\t/* */ if (_r$3 === 25) { $s = 12; continue; }\n\t\t\t\t/* */ $s = 13; continue;\n\t\t\t\t/* if (_r$3 === 25) { */ case 12:\n\t\t\t\t\t_r$4 = typ.Elem(); /* */ $s = 18; case 18: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t\t\t\t/* */ if ($interfaceIsEqual(_r$4, v.typ.Elem())) { $s = 16; continue; }\n\t\t\t\t\t/* */ $s = 17; continue;\n\t\t\t\t\t/* if ($interfaceIsEqual(_r$4, v.typ.Elem())) { */ case 16:\n\t\t\t\t\t\tval = srcVal;\n\t\t\t\t\t\t/* break; */ $s = 4; continue;\n\t\t\t\t\t/* } */ case 17:\n\t\t\t\t\tval = new (jsType(typ))();\n\t\t\t\t\t_arg = val;\n\t\t\t\t\t_arg$1 = srcVal;\n\t\t\t\t\t_r$5 = typ.Elem(); /* */ $s = 19; case 19: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }\n\t\t\t\t\t_arg$2 = _r$5;\n\t\t\t\t\t$r = copyStruct(_arg, _arg$1, _arg$2); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t/* break; */ $s = 4; continue;\n\t\t\t\t/* } */ case 13:\n\t\t\t\tval = new (jsType(typ))(srcVal.$get, srcVal.$set);\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else if (_1 === (25)) { */ case 8:\n\t\t\t\tval = new (jsType(typ).ptr)();\n\t\t\t\tcopyStruct(val, srcVal, typ);\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else if ((_1 === (17)) || (_1 === (1)) || (_1 === (18)) || (_1 === (19)) || (_1 === (20)) || (_1 === (21)) || (_1 === (24))) { */ case 9:\n\t\t\t\tval = v.ptr;\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else { */ case 10:\n\t\t\t\t$panic(new ValueError.ptr(\"reflect.Convert\", k));\n\t\t\t/* } */ case 11:\n\t\tcase 4:\n\t\t_r$6 = typ.common(); /* */ $s = 21; case 21: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }\n\t\t_r$7 = typ.Kind(); /* */ $s = 22; case 22: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }\n\t\t$s = -1; return new Value.ptr(_r$6, val, (((v.flag & 224) >>> 0) | (_r$7 >>> 0)) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtDirect }; } $f.$ptr = $ptr; $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f.k = k; $f.slice = slice; $f.srcVal = srcVal; $f.typ = typ; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmethodReceiver = function(op, v, i) {\n\t\tvar $ptr, _$37, fn, i, m, m$1, op, prop, rcvr, t, tt, ut, v, x, x$1;\n\t\t_$37 = ptrType$1.nil;\n\t\tt = ptrType$1.nil;\n\t\tfn = 0;\n\t\tprop = \"\";\n\t\tif (v.typ.Kind() === 20) {\n\t\t\ttt = v.typ.kindType;\n\t\t\tif (i < 0 || i >= tt.methods.$length) {\n\t\t\t\t$panic(new $String(\"reflect: internal error: invalid method index\"));\n\t\t\t}\n\t\t\tm = (x = tt.methods, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\tif (!$clone(tt.rtype.nameOff(m.name), name).isExported()) {\n\t\t\t\t$panic(new $String(\"reflect: \" + op + \" of unexported method\"));\n\t\t\t}\n\t\t\tt = tt.rtype.typeOff(m.typ);\n\t\t\tprop = $clone(tt.rtype.nameOff(m.name), name).name();\n\t\t} else {\n\t\t\tut = v.typ.uncommon();\n\t\t\tif (ut === ptrType$6.nil || (i >>> 0) >= (ut.mcount >>> 0)) {\n\t\t\t\t$panic(new $String(\"reflect: internal error: invalid method index\"));\n\t\t\t}\n\t\t\tm$1 = $clone((x$1 = ut.methods(), ((i < 0 || i >= x$1.$length) ? $throwRuntimeError(\"index out of range\") : x$1.$array[x$1.$offset + i])), method);\n\t\t\tif (!$clone(v.typ.nameOff(m$1.name), name).isExported()) {\n\t\t\t\t$panic(new $String(\"reflect: \" + op + \" of unexported method\"));\n\t\t\t}\n\t\t\tt = v.typ.typeOff(m$1.mtyp);\n\t\t\tprop = $internalize($methodSet(jsType(v.typ))[i].prop, $String);\n\t\t}\n\t\trcvr = $clone(v, Value).object();\n\t\tif (isWrapped(v.typ)) {\n\t\t\trcvr = new (jsType(v.typ))(rcvr);\n\t\t}\n\t\tfn = rcvr[$externalize(prop, $String)];\n\t\treturn [_$37, t, fn];\n\t};\n\tvalueInterface = function(v, safe) {\n\t\tvar $ptr, _r, safe, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; safe = $f.safe; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tif (v.flag === 0) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Interface\", 0));\n\t\t}\n\t\tif (safe && !((((v.flag & 96) >>> 0) === 0))) {\n\t\t\t$panic(new $String(\"reflect.Value.Interface: cannot return value obtained from unexported field or method\"));\n\t\t}\n\t\t/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:\n\t\t\t_r = makeMethodValue(\"Interface\", $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tv = _r;\n\t\t/* } */ case 2:\n\t\tif (isWrapped(v.typ)) {\n\t\t\t$s = -1; return new (jsType(v.typ))($clone(v, Value).object());\n\t\t}\n\t\t$s = -1; return $clone(v, Value).object();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: valueInterface }; } $f.$ptr = $ptr; $f._r = _r; $f.safe = safe; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tifaceE2I = function(t, src, dst) {\n\t\tvar $ptr, dst, src, t;\n\t\tdst.$set(src);\n\t};\n\tmethodName = function() {\n\t\tvar $ptr;\n\t\treturn \"?FIXME?\";\n\t};\n\tmakeMethodValue = function(op, v) {\n\t\tvar $ptr, _r, _tuple, fn, fv, op, rcvr, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; fn = $f.fn; fv = $f.fv; op = $f.op; rcvr = $f.rcvr; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tfn = [fn];\n\t\trcvr = [rcvr];\n\t\tif (((v.flag & 512) >>> 0) === 0) {\n\t\t\t$panic(new $String(\"reflect: internal error: invalid use of makePartialFunc\"));\n\t\t}\n\t\t_tuple = methodReceiver(op, $clone(v, Value), (v.flag >> 0) >> 10 >> 0);\n\t\tfn[0] = _tuple[2];\n\t\trcvr[0] = $clone(v, Value).object();\n\t\tif (isWrapped(v.typ)) {\n\t\t\trcvr[0] = new (jsType(v.typ))(rcvr[0]);\n\t\t}\n\t\tfv = js.MakeFunc((function(fn, rcvr) { return function(this$1, arguments$1) {\n\t\t\tvar $ptr, arguments$1, this$1;\n\t\t\treturn new $jsObjectPtr(fn[0].apply(rcvr[0], $externalize(arguments$1, sliceType$9)));\n\t\t}; })(fn, rcvr));\n\t\t_r = $clone(v, Value).Type().common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return new Value.ptr(_r, fv, (((v.flag & 96) >>> 0) | 19) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeMethodValue }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.fn = fn; $f.fv = fv; $f.op = op; $f.rcvr = rcvr; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.ptr.prototype.pointers = function() {\n\t\tvar $ptr, _1, t;\n\t\tt = this;\n\t\t_1 = t.Kind();\n\t\tif ((_1 === (22)) || (_1 === (21)) || (_1 === (18)) || (_1 === (19)) || (_1 === (25)) || (_1 === (17))) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\trtype.prototype.pointers = function() { return this.$val.pointers(); };\n\trtype.ptr.prototype.Comparable = function() {\n\t\tvar $ptr, _1, _r, _r$1, _r$2, i, t, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; i = $f.i; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t\t_1 = t.Kind();\n\t\t\t/* */ if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (17)) { $s = 3; continue; }\n\t\t\t/* */ if (_1 === (25)) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if ((_1 === (19)) || (_1 === (23)) || (_1 === (21))) { */ case 2:\n\t\t\t\t$s = -1; return false;\n\t\t\t/* } else if (_1 === (17)) { */ case 3:\n\t\t\t\t_r = t.Elem().Comparable(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return _r;\n\t\t\t/* } else if (_1 === (25)) { */ case 4:\n\t\t\t\ti = 0;\n\t\t\t\t/* while (true) { */ case 7:\n\t\t\t\t\t/* if (!(i < t.NumField())) { break; } */ if(!(i < t.NumField())) { $s = 8; continue; }\n\t\t\t\t\t_r$1 = t.Field(i); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t\t_r$2 = _r$1.Type.Comparable(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t\t/* */ if (!_r$2) { $s = 9; continue; }\n\t\t\t\t\t/* */ $s = 10; continue;\n\t\t\t\t\t/* if (!_r$2) { */ case 9:\n\t\t\t\t\t\t$s = -1; return false;\n\t\t\t\t\t/* } */ case 10:\n\t\t\t\t\ti = i + (1) >> 0;\n\t\t\t\t/* } */ $s = 7; continue; case 8:\n\t\t\t/* } */ case 5:\n\t\tcase 1:\n\t\t$s = -1; return true;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Comparable }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.i = i; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.Comparable = function() { return this.$val.Comparable(); };\n\trtype.ptr.prototype.Method = function(i) {\n\t\tvar $ptr, _i, _i$1, _r, _r$1, _ref, _ref$1, arg, fl, fn, ft, i, in$1, m, methods, mt, mtyp, out, p, pname, prop, ret, t, tt, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; arg = $f.arg; fl = $f.fl; fn = $f.fn; ft = $f.ft; i = $f.i; in$1 = $f.in$1; m = $f.m; methods = $f.methods; mt = $f.mt; mtyp = $f.mtyp; out = $f.out; p = $f.p; pname = $f.pname; prop = $f.prop; ret = $f.ret; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tprop = [prop];\n\t\tm = new Method.ptr(\"\", \"\", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);\n\t\tt = this;\n\t\tif (t.Kind() === 20) {\n\t\t\ttt = t.kindType;\n\t\t\tMethod.copy(m, tt.Method(i));\n\t\t\t$s = -1; return m;\n\t\t}\n\t\t_r = t.exportedMethods(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tmethods = _r;\n\t\tif (i < 0 || i >= methods.$length) {\n\t\t\t$panic(new $String(\"reflect: Method index out of range\"));\n\t\t}\n\t\tp = $clone(((i < 0 || i >= methods.$length) ? $throwRuntimeError(\"index out of range\") : methods.$array[methods.$offset + i]), method);\n\t\tpname = $clone(t.nameOff(p.name), name);\n\t\tm.Name = $clone(pname, name).name();\n\t\tfl = 19;\n\t\tmtyp = t.typeOff(p.mtyp);\n\t\tft = mtyp.kindType;\n\t\tin$1 = $makeSlice(sliceType$11, 0, (1 + ft.in$().$length >> 0));\n\t\tin$1 = $append(in$1, t);\n\t\t_ref = ft.in$();\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\targ = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tin$1 = $append(in$1, arg);\n\t\t\t_i++;\n\t\t}\n\t\tout = $makeSlice(sliceType$11, 0, ft.out().$length);\n\t\t_ref$1 = ft.out();\n\t\t_i$1 = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\tret = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? $throwRuntimeError(\"index out of range\") : _ref$1.$array[_ref$1.$offset + _i$1]);\n\t\t\tout = $append(out, ret);\n\t\t\t_i$1++;\n\t\t}\n\t\t_r$1 = FuncOf(in$1, out, ft.rtype.IsVariadic()); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tmt = _r$1;\n\t\tm.Type = mt;\n\t\tprop[0] = $internalize($methodSet(t.jsType)[i].prop, $String);\n\t\tfn = js.MakeFunc((function(prop) { return function(this$1, arguments$1) {\n\t\t\tvar $ptr, arguments$1, rcvr, this$1;\n\t\t\trcvr = (0 >= arguments$1.$length ? $throwRuntimeError(\"index out of range\") : arguments$1.$array[arguments$1.$offset + 0]);\n\t\t\treturn new $jsObjectPtr(rcvr[$externalize(prop[0], $String)].apply(rcvr, $externalize($subslice(arguments$1, 1), sliceType$9)));\n\t\t}; })(prop));\n\t\tm.Func = new Value.ptr($assertType(mt, ptrType$1), fn, fl);\n\t\tm.Index = i;\n\t\tMethod.copy(m, m);\n\t\t$s = -1; return m;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Method }; } $f.$ptr = $ptr; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f.arg = arg; $f.fl = fl; $f.fn = fn; $f.ft = ft; $f.i = i; $f.in$1 = in$1; $f.m = m; $f.methods = methods; $f.mt = mt; $f.mtyp = mtyp; $f.out = out; $f.p = p; $f.pname = pname; $f.prop = prop; $f.ret = ret; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.Method = function(i) { return this.$val.Method(i); };\n\tValue.ptr.prototype.object = function() {\n\t\tvar $ptr, _1, newVal, v, val;\n\t\tv = this;\n\t\tif ((v.typ.Kind() === 17) || (v.typ.Kind() === 25)) {\n\t\t\treturn v.ptr;\n\t\t}\n\t\tif (!((((v.flag & 128) >>> 0) === 0))) {\n\t\t\tval = v.ptr.$get();\n\t\t\tif (!(val === $ifaceNil) && !(val.constructor === jsType(v.typ))) {\n\t\t\t\tswitch (0) { default:\n\t\t\t\t\t_1 = v.typ.Kind();\n\t\t\t\t\tif ((_1 === (11)) || (_1 === (6))) {\n\t\t\t\t\t\tval = new (jsType(v.typ))(val.$high, val.$low);\n\t\t\t\t\t} else if ((_1 === (15)) || (_1 === (16))) {\n\t\t\t\t\t\tval = new (jsType(v.typ))(val.$real, val.$imag);\n\t\t\t\t\t} else if (_1 === (23)) {\n\t\t\t\t\t\tif (val === val.constructor.nil) {\n\t\t\t\t\t\t\tval = jsType(v.typ).nil;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewVal = new (jsType(v.typ))(val.$array);\n\t\t\t\t\t\tnewVal.$offset = val.$offset;\n\t\t\t\t\t\tnewVal.$length = val.$length;\n\t\t\t\t\t\tnewVal.$capacity = val.$capacity;\n\t\t\t\t\t\tval = newVal;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\treturn v.ptr;\n\t};\n\tValue.prototype.object = function() { return this.$val.object(); };\n\tValue.ptr.prototype.call = function(op, in$1) {\n\t\tvar $ptr, _1, _arg, _arg$1, _arg$2, _arg$3, _i, _i$1, _i$2, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _ref$2, _tmp, _tmp$1, _tuple, arg, argsArray, elem, fn, i, i$1, i$2, i$3, in$1, isSlice, m, n, nin, nout, op, origIn, rcvr, results, ret, slice, t, targ, v, x, x$1, x$2, xt, xt$1, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _arg$3 = $f._arg$3; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; arg = $f.arg; argsArray = $f.argsArray; elem = $f.elem; fn = $f.fn; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; in$1 = $f.in$1; isSlice = $f.isSlice; m = $f.m; n = $f.n; nin = $f.nin; nout = $f.nout; op = $f.op; origIn = $f.origIn; rcvr = $f.rcvr; results = $f.results; ret = $f.ret; slice = $f.slice; t = $f.t; targ = $f.targ; v = $f.v; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; xt = $f.xt; xt$1 = $f.xt$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tt = ptrType$1.nil;\n\t\tfn = 0;\n\t\trcvr = null;\n\t\tif (!((((v.flag & 512) >>> 0) === 0))) {\n\t\t\t_tuple = methodReceiver(op, $clone(v, Value), (v.flag >> 0) >> 10 >> 0);\n\t\t\tt = _tuple[1];\n\t\t\tfn = _tuple[2];\n\t\t\trcvr = $clone(v, Value).object();\n\t\t\tif (isWrapped(v.typ)) {\n\t\t\t\trcvr = new (jsType(v.typ))(rcvr);\n\t\t\t}\n\t\t} else {\n\t\t\tt = v.typ;\n\t\t\tfn = $clone(v, Value).object();\n\t\t\trcvr = undefined;\n\t\t}\n\t\tif (fn === 0) {\n\t\t\t$panic(new $String(\"reflect.Value.Call: call of nil function\"));\n\t\t}\n\t\tisSlice = op === \"CallSlice\";\n\t\tn = t.NumIn();\n\t\tif (isSlice) {\n\t\t\tif (!t.IsVariadic()) {\n\t\t\t\t$panic(new $String(\"reflect: CallSlice of non-variadic function\"));\n\t\t\t}\n\t\t\tif (in$1.$length < n) {\n\t\t\t\t$panic(new $String(\"reflect: CallSlice with too few input arguments\"));\n\t\t\t}\n\t\t\tif (in$1.$length > n) {\n\t\t\t\t$panic(new $String(\"reflect: CallSlice with too many input arguments\"));\n\t\t\t}\n\t\t} else {\n\t\t\tif (t.IsVariadic()) {\n\t\t\t\tn = n - (1) >> 0;\n\t\t\t}\n\t\t\tif (in$1.$length < n) {\n\t\t\t\t$panic(new $String(\"reflect: Call with too few input arguments\"));\n\t\t\t}\n\t\t\tif (!t.IsVariadic() && in$1.$length > n) {\n\t\t\t\t$panic(new $String(\"reflect: Call with too many input arguments\"));\n\t\t\t}\n\t\t}\n\t\t_ref = in$1;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\tx = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tif ($clone(x, Value).Kind() === 0) {\n\t\t\t\t$panic(new $String(\"reflect: \" + op + \" using zero Value argument\"));\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\ti = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(i < n)) { break; } */ if(!(i < n)) { $s = 2; continue; }\n\t\t\t_tmp = $clone(((i < 0 || i >= in$1.$length) ? $throwRuntimeError(\"index out of range\") : in$1.$array[in$1.$offset + i]), Value).Type();\n\t\t\t_tmp$1 = t.In(i);\n\t\t\txt = _tmp;\n\t\t\ttarg = _tmp$1;\n\t\t\t_r = xt.AssignableTo(targ); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t/* */ if (!_r) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (!_r) { */ case 3:\n\t\t\t\t_r$1 = xt.String(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t_r$2 = targ.String(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t$panic(new $String(\"reflect: \" + op + \" using \" + _r$1 + \" as type \" + _r$2));\n\t\t\t/* } */ case 4:\n\t\t\ti = i + (1) >> 0;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t/* */ if (!isSlice && t.IsVariadic()) { $s = 8; continue; }\n\t\t/* */ $s = 9; continue;\n\t\t/* if (!isSlice && t.IsVariadic()) { */ case 8:\n\t\t\tm = in$1.$length - n >> 0;\n\t\t\t_r$3 = MakeSlice(t.In(n), m, m); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\tslice = _r$3;\n\t\t\t_r$4 = t.In(n).Elem(); /* */ $s = 11; case 11: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t\telem = _r$4;\n\t\t\ti$1 = 0;\n\t\t\t/* while (true) { */ case 12:\n\t\t\t\t/* if (!(i$1 < m)) { break; } */ if(!(i$1 < m)) { $s = 13; continue; }\n\t\t\t\tx$2 = (x$1 = n + i$1 >> 0, ((x$1 < 0 || x$1 >= in$1.$length) ? $throwRuntimeError(\"index out of range\") : in$1.$array[in$1.$offset + x$1]));\n\t\t\t\txt$1 = $clone(x$2, Value).Type();\n\t\t\t\t_r$5 = xt$1.AssignableTo(elem); /* */ $s = 16; case 16: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }\n\t\t\t\t/* */ if (!_r$5) { $s = 14; continue; }\n\t\t\t\t/* */ $s = 15; continue;\n\t\t\t\t/* if (!_r$5) { */ case 14:\n\t\t\t\t\t_r$6 = xt$1.String(); /* */ $s = 17; case 17: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }\n\t\t\t\t\t_r$7 = elem.String(); /* */ $s = 18; case 18: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }\n\t\t\t\t\t$panic(new $String(\"reflect: cannot use \" + _r$6 + \" as type \" + _r$7 + \" in \" + op));\n\t\t\t\t/* } */ case 15:\n\t\t\t\t_r$8 = $clone(slice, Value).Index(i$1); /* */ $s = 19; case 19: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }\n\t\t\t\t$r = $clone(_r$8, Value).Set($clone(x$2, Value)); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t\t/* } */ $s = 12; continue; case 13:\n\t\t\torigIn = in$1;\n\t\t\tin$1 = $makeSlice(sliceType$10, (n + 1 >> 0));\n\t\t\t$copySlice($subslice(in$1, 0, n), origIn);\n\t\t\t((n < 0 || n >= in$1.$length) ? $throwRuntimeError(\"index out of range\") : in$1.$array[in$1.$offset + n] = slice);\n\t\t/* } */ case 9:\n\t\tnin = in$1.$length;\n\t\tif (!((nin === t.NumIn()))) {\n\t\t\t$panic(new $String(\"reflect.Value.Call: wrong argument count\"));\n\t\t}\n\t\tnout = t.NumOut();\n\t\targsArray = new ($global.Array)(t.NumIn());\n\t\t_ref$1 = in$1;\n\t\t_i$1 = 0;\n\t\t/* while (true) { */ case 21:\n\t\t\t/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 22; continue; }\n\t\t\ti$2 = _i$1;\n\t\t\targ = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? $throwRuntimeError(\"index out of range\") : _ref$1.$array[_ref$1.$offset + _i$1]);\n\t\t\t_arg = t.In(i$2);\n\t\t\t_r$9 = t.In(i$2).common(); /* */ $s = 23; case 23: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }\n\t\t\t_arg$1 = _r$9;\n\t\t\t_arg$2 = 0;\n\t\t\t_r$10 = $clone(arg, Value).assignTo(\"reflect.Value.Call\", _arg$1, _arg$2); /* */ $s = 24; case 24: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }\n\t\t\t_r$11 = $clone(_r$10, Value).object(); /* */ $s = 25; case 25: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }\n\t\t\t_arg$3 = _r$11;\n\t\t\t_r$12 = unwrapJsObject(_arg, _arg$3); /* */ $s = 26; case 26: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }\n\t\t\targsArray[i$2] = _r$12;\n\t\t\t_i$1++;\n\t\t/* } */ $s = 21; continue; case 22:\n\t\t_r$13 = callHelper(new sliceType$5([new $jsObjectPtr(fn), new $jsObjectPtr(rcvr), new $jsObjectPtr(argsArray)])); /* */ $s = 27; case 27: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }\n\t\tresults = _r$13;\n\t\t\t_1 = nout;\n\t\t\t/* */ if (_1 === (0)) { $s = 29; continue; }\n\t\t\t/* */ if (_1 === (1)) { $s = 30; continue; }\n\t\t\t/* */ $s = 31; continue;\n\t\t\t/* if (_1 === (0)) { */ case 29:\n\t\t\t\t$s = -1; return sliceType$10.nil;\n\t\t\t/* } else if (_1 === (1)) { */ case 30:\n\t\t\t\t_r$14 = makeValue(t.Out(0), wrapJsObject(t.Out(0), results), 0); /* */ $s = 33; case 33: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return new sliceType$10([$clone(_r$14, Value)]);\n\t\t\t/* } else { */ case 31:\n\t\t\t\tret = $makeSlice(sliceType$10, nout);\n\t\t\t\t_ref$2 = ret;\n\t\t\t\t_i$2 = 0;\n\t\t\t\t/* while (true) { */ case 34:\n\t\t\t\t\t/* if (!(_i$2 < _ref$2.$length)) { break; } */ if(!(_i$2 < _ref$2.$length)) { $s = 35; continue; }\n\t\t\t\t\ti$3 = _i$2;\n\t\t\t\t\t_r$15 = makeValue(t.Out(i$3), wrapJsObject(t.Out(i$3), results[i$3]), 0); /* */ $s = 36; case 36: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }\n\t\t\t\t\t((i$3 < 0 || i$3 >= ret.$length) ? $throwRuntimeError(\"index out of range\") : ret.$array[ret.$offset + i$3] = _r$15);\n\t\t\t\t\t_i$2++;\n\t\t\t\t/* } */ $s = 34; continue; case 35:\n\t\t\t\t$s = -1; return ret;\n\t\t\t/* } */ case 32:\n\t\tcase 28:\n\t\t$s = -1; return sliceType$10.nil;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.call }; } $f.$ptr = $ptr; $f._1 = _1; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._arg$3 = _arg$3; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.arg = arg; $f.argsArray = argsArray; $f.elem = elem; $f.fn = fn; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.in$1 = in$1; $f.isSlice = isSlice; $f.m = m; $f.n = n; $f.nin = nin; $f.nout = nout; $f.op = op; $f.origIn = origIn; $f.rcvr = rcvr; $f.results = results; $f.ret = ret; $f.slice = slice; $f.t = t; $f.targ = targ; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.xt = xt; $f.xt$1 = xt$1; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.call = function(op, in$1) { return this.$val.call(op, in$1); };\n\tValue.ptr.prototype.Cap = function() {\n\t\tvar $ptr, _1, k, v;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (17)) {\n\t\t\treturn v.typ.Len();\n\t\t} else if ((_1 === (18)) || (_1 === (23))) {\n\t\t\treturn $parseInt($clone(v, Value).object().$capacity) >> 0;\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.Cap\", k));\n\t};\n\tValue.prototype.Cap = function() { return this.$val.Cap(); };\n\twrapJsObject = function(typ, val) {\n\t\tvar $ptr, typ, val;\n\t\tif ($interfaceIsEqual(typ, jsObjectPtr)) {\n\t\t\treturn new (jsType(jsObjectPtr))(val);\n\t\t}\n\t\treturn val;\n\t};\n\tunwrapJsObject = function(typ, val) {\n\t\tvar $ptr, typ, val;\n\t\tif ($interfaceIsEqual(typ, jsObjectPtr)) {\n\t\t\treturn val.object;\n\t\t}\n\t\treturn val;\n\t};\n\tValue.ptr.prototype.Elem = function() {\n\t\tvar $ptr, _1, _r, fl, k, tt, typ, v, val, val$1, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; fl = $f.fl; k = $f.k; tt = $f.tt; typ = $f.typ; v = $f.v; val = $f.val; val$1 = $f.val$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\t\tk = new flag(v.flag).kind();\n\t\t\t_1 = k;\n\t\t\t/* */ if (_1 === (20)) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (22)) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (_1 === (20)) { */ case 2:\n\t\t\t\tval = $clone(v, Value).object();\n\t\t\t\tif (val === $ifaceNil) {\n\t\t\t\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t\t\t}\n\t\t\t\ttyp = reflectType(val.constructor);\n\t\t\t\t_r = makeValue(typ, val.$val, (v.flag & 96) >>> 0); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return _r;\n\t\t\t/* } else if (_1 === (22)) { */ case 3:\n\t\t\t\tif ($clone(v, Value).IsNil()) {\n\t\t\t\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t\t\t}\n\t\t\t\tval$1 = $clone(v, Value).object();\n\t\t\t\ttt = v.typ.kindType;\n\t\t\t\tfl = (((((v.flag & 96) >>> 0) | 128) >>> 0) | 256) >>> 0;\n\t\t\t\tfl = (fl | ((tt.elem.Kind() >>> 0))) >>> 0;\n\t\t\t\t$s = -1; return new Value.ptr(tt.elem, wrapJsObject(tt.elem, val$1), fl);\n\t\t\t/* } else { */ case 4:\n\t\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Elem\", k));\n\t\t\t/* } */ case 5:\n\t\tcase 1:\n\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Elem }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f.fl = fl; $f.k = k; $f.tt = tt; $f.typ = typ; $f.v = v; $f.val = val; $f.val$1 = val$1; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Elem = function() { return this.$val.Elem(); };\n\tValue.ptr.prototype.Field = function(i) {\n\t\tvar $ptr, _r, _r$1, _r$2, field, fl, i, jsTag, o, prop, s, tag, tt, typ, v, x, x$1, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; field = $f.field; fl = $f.fl; i = $f.i; jsTag = $f.jsTag; o = $f.o; prop = $f.prop; s = $f.s; tag = $f.tag; tt = $f.tt; typ = $f.typ; v = $f.v; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tjsTag = [jsTag];\n\t\tprop = [prop];\n\t\ts = [s];\n\t\ttyp = [typ];\n\t\tv = this;\n\t\tif (!((new flag(v.flag).kind() === 25))) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Field\", new flag(v.flag).kind()));\n\t\t}\n\t\ttt = v.typ.kindType;\n\t\tif ((i >>> 0) >= (tt.fields.$length >>> 0)) {\n\t\t\t$panic(new $String(\"reflect: Field index out of range\"));\n\t\t}\n\t\tprop[0] = $internalize(jsType(v.typ).fields[i].prop, $String);\n\t\tfield = (x = tt.fields, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\ttyp[0] = field.typ;\n\t\tfl = (((v.flag & 416) >>> 0) | (typ[0].Kind() >>> 0)) >>> 0;\n\t\tif (!$clone(field.name, name).isExported()) {\n\t\t\tif ($clone(field.name, name).name() === \"\") {\n\t\t\t\tfl = (fl | (64)) >>> 0;\n\t\t\t} else {\n\t\t\t\tfl = (fl | (32)) >>> 0;\n\t\t\t}\n\t\t}\n\t\ttag = $clone((x$1 = tt.fields, ((i < 0 || i >= x$1.$length) ? $throwRuntimeError(\"index out of range\") : x$1.$array[x$1.$offset + i])).name, name).tag();\n\t\t/* */ if (!(tag === \"\") && !((i === 0))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!(tag === \"\") && !((i === 0))) { */ case 1:\n\t\t\tjsTag[0] = getJsTag(tag);\n\t\t\t/* */ if (!(jsTag[0] === \"\")) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (!(jsTag[0] === \"\")) { */ case 3:\n\t\t\t\t/* while (true) { */ case 5:\n\t\t\t\t\to = [o];\n\t\t\t\t\t_r = $clone(v, Value).Field(0); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t\tv = _r;\n\t\t\t\t\t/* */ if (v.typ === jsObjectPtr) { $s = 8; continue; }\n\t\t\t\t\t/* */ $s = 9; continue;\n\t\t\t\t\t/* if (v.typ === jsObjectPtr) { */ case 8:\n\t\t\t\t\t\to[0] = $clone(v, Value).object().object;\n\t\t\t\t\t\t$s = -1; return new Value.ptr(typ[0], new (jsType(PtrTo(typ[0])))((function(jsTag, o, prop, s, typ) { return function() {\n\t\t\t\t\t\t\tvar $ptr;\n\t\t\t\t\t\t\treturn $internalize(o[0][$externalize(jsTag[0], $String)], jsType(typ[0]));\n\t\t\t\t\t\t}; })(jsTag, o, prop, s, typ), (function(jsTag, o, prop, s, typ) { return function(x$2) {\n\t\t\t\t\t\t\tvar $ptr, x$2;\n\t\t\t\t\t\t\to[0][$externalize(jsTag[0], $String)] = $externalize(x$2, jsType(typ[0]));\n\t\t\t\t\t\t}; })(jsTag, o, prop, s, typ)), fl);\n\t\t\t\t\t/* } */ case 9:\n\t\t\t\t\t/* */ if (v.typ.Kind() === 22) { $s = 10; continue; }\n\t\t\t\t\t/* */ $s = 11; continue;\n\t\t\t\t\t/* if (v.typ.Kind() === 22) { */ case 10:\n\t\t\t\t\t\t_r$1 = $clone(v, Value).Elem(); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t\t\tv = _r$1;\n\t\t\t\t\t/* } */ case 11:\n\t\t\t\t/* } */ $s = 5; continue; case 6:\n\t\t\t/* } */ case 4:\n\t\t/* } */ case 2:\n\t\ts[0] = v.ptr;\n\t\t/* */ if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { $s = 13; continue; }\n\t\t/* */ $s = 14; continue;\n\t\t/* if (!((((fl & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 13:\n\t\t\t$s = -1; return new Value.ptr(typ[0], new (jsType(PtrTo(typ[0])))((function(jsTag, prop, s, typ) { return function() {\n\t\t\t\tvar $ptr;\n\t\t\t\treturn wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]);\n\t\t\t}; })(jsTag, prop, s, typ), (function(jsTag, prop, s, typ) { return function(x$2) {\n\t\t\t\tvar $ptr, x$2;\n\t\t\t\ts[0][$externalize(prop[0], $String)] = unwrapJsObject(typ[0], x$2);\n\t\t\t}; })(jsTag, prop, s, typ)), fl);\n\t\t/* } */ case 14:\n\t\t_r$2 = makeValue(typ[0], wrapJsObject(typ[0], s[0][$externalize(prop[0], $String)]), fl); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$2;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Field }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.field = field; $f.fl = fl; $f.i = i; $f.jsTag = jsTag; $f.o = o; $f.prop = prop; $f.s = s; $f.tag = tag; $f.tt = tt; $f.typ = typ; $f.v = v; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Field = function(i) { return this.$val.Field(i); };\n\tgetJsTag = function(tag) {\n\t\tvar $ptr, _tuple, i, name$1, qvalue, tag, value;\n\t\twhile (true) {\n\t\t\tif (!(!(tag === \"\"))) { break; }\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < tag.length && (tag.charCodeAt(i) === 32))) { break; }\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\ttag = $substring(tag, i);\n\t\t\tif (tag === \"\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < tag.length && !((tag.charCodeAt(i) === 32)) && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34)))) { break; }\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\tif ((i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tname$1 = $substring(tag, 0, i);\n\t\t\ttag = $substring(tag, (i + 1 >> 0));\n\t\t\ti = 1;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < tag.length && !((tag.charCodeAt(i) === 34)))) { break; }\n\t\t\t\tif (tag.charCodeAt(i) === 92) {\n\t\t\t\t\ti = i + (1) >> 0;\n\t\t\t\t}\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\tif (i >= tag.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqvalue = $substring(tag, 0, (i + 1 >> 0));\n\t\t\ttag = $substring(tag, (i + 1 >> 0));\n\t\t\tif (name$1 === \"js\") {\n\t\t\t\t_tuple = strconv.Unquote(qvalue);\n\t\t\t\tvalue = _tuple[0];\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t};\n\tValue.ptr.prototype.Index = function(i) {\n\t\tvar $ptr, _1, _r, _r$1, a, a$1, c, fl, fl$1, fl$2, i, k, s, str, tt, tt$1, typ, typ$1, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; a = $f.a; a$1 = $f.a$1; c = $f.c; fl = $f.fl; fl$1 = $f.fl$1; fl$2 = $f.fl$2; i = $f.i; k = $f.k; s = $f.s; str = $f.str; tt = $f.tt; tt$1 = $f.tt$1; typ = $f.typ; typ$1 = $f.typ$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ta = [a];\n\t\ta$1 = [a$1];\n\t\tc = [c];\n\t\ti = [i];\n\t\ttyp = [typ];\n\t\ttyp$1 = [typ$1];\n\t\tv = this;\n\t\t\tk = new flag(v.flag).kind();\n\t\t\t_1 = k;\n\t\t\t/* */ if (_1 === (17)) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (23)) { $s = 3; continue; }\n\t\t\t/* */ if (_1 === (24)) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if (_1 === (17)) { */ case 2:\n\t\t\t\ttt = v.typ.kindType;\n\t\t\t\tif (i[0] < 0 || i[0] > (tt.len >> 0)) {\n\t\t\t\t\t$panic(new $String(\"reflect: array index out of range\"));\n\t\t\t\t}\n\t\t\t\ttyp$1[0] = tt.elem;\n\t\t\t\tfl = (v.flag & 480) >>> 0;\n\t\t\t\tfl = (fl | ((typ$1[0].Kind() >>> 0))) >>> 0;\n\t\t\t\ta$1[0] = v.ptr;\n\t\t\t\t/* */ if (!((((fl & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { $s = 7; continue; }\n\t\t\t\t/* */ $s = 8; continue;\n\t\t\t\t/* if (!((((fl & 128) >>> 0) === 0)) && !((typ$1[0].Kind() === 17)) && !((typ$1[0].Kind() === 25))) { */ case 7:\n\t\t\t\t\t$s = -1; return new Value.ptr(typ$1[0], new (jsType(PtrTo(typ$1[0])))((function(a, a$1, c, i, typ, typ$1) { return function() {\n\t\t\t\t\t\tvar $ptr;\n\t\t\t\t\t\treturn wrapJsObject(typ$1[0], a$1[0][i[0]]);\n\t\t\t\t\t}; })(a, a$1, c, i, typ, typ$1), (function(a, a$1, c, i, typ, typ$1) { return function(x) {\n\t\t\t\t\t\tvar $ptr, x;\n\t\t\t\t\t\ta$1[0][i[0]] = unwrapJsObject(typ$1[0], x);\n\t\t\t\t\t}; })(a, a$1, c, i, typ, typ$1)), fl);\n\t\t\t\t/* } */ case 8:\n\t\t\t\t_r = makeValue(typ$1[0], wrapJsObject(typ$1[0], a$1[0][i[0]]), fl); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return _r;\n\t\t\t/* } else if (_1 === (23)) { */ case 3:\n\t\t\t\ts = $clone(v, Value).object();\n\t\t\t\tif (i[0] < 0 || i[0] >= ($parseInt(s.$length) >> 0)) {\n\t\t\t\t\t$panic(new $String(\"reflect: slice index out of range\"));\n\t\t\t\t}\n\t\t\t\ttt$1 = v.typ.kindType;\n\t\t\t\ttyp[0] = tt$1.elem;\n\t\t\t\tfl$1 = (384 | ((v.flag & 96) >>> 0)) >>> 0;\n\t\t\t\tfl$1 = (fl$1 | ((typ[0].Kind() >>> 0))) >>> 0;\n\t\t\t\ti[0] = i[0] + (($parseInt(s.$offset) >> 0)) >> 0;\n\t\t\t\ta[0] = s.$array;\n\t\t\t\t/* */ if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { $s = 10; continue; }\n\t\t\t\t/* */ $s = 11; continue;\n\t\t\t\t/* if (!((((fl$1 & 128) >>> 0) === 0)) && !((typ[0].Kind() === 17)) && !((typ[0].Kind() === 25))) { */ case 10:\n\t\t\t\t\t$s = -1; return new Value.ptr(typ[0], new (jsType(PtrTo(typ[0])))((function(a, a$1, c, i, typ, typ$1) { return function() {\n\t\t\t\t\t\tvar $ptr;\n\t\t\t\t\t\treturn wrapJsObject(typ[0], a[0][i[0]]);\n\t\t\t\t\t}; })(a, a$1, c, i, typ, typ$1), (function(a, a$1, c, i, typ, typ$1) { return function(x) {\n\t\t\t\t\t\tvar $ptr, x;\n\t\t\t\t\t\ta[0][i[0]] = unwrapJsObject(typ[0], x);\n\t\t\t\t\t}; })(a, a$1, c, i, typ, typ$1)), fl$1);\n\t\t\t\t/* } */ case 11:\n\t\t\t\t_r$1 = makeValue(typ[0], wrapJsObject(typ[0], a[0][i[0]]), fl$1); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return _r$1;\n\t\t\t/* } else if (_1 === (24)) { */ case 4:\n\t\t\t\tstr = v.ptr.$get();\n\t\t\t\tif (i[0] < 0 || i[0] >= str.length) {\n\t\t\t\t\t$panic(new $String(\"reflect: string index out of range\"));\n\t\t\t\t}\n\t\t\t\tfl$2 = (((v.flag & 96) >>> 0) | 8) >>> 0;\n\t\t\t\tc[0] = str.charCodeAt(i[0]);\n\t\t\t\t$s = -1; return new Value.ptr(uint8Type, (c.$ptr || (c.$ptr = new ptrType$5(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, c))), (fl$2 | 128) >>> 0);\n\t\t\t/* } else { */ case 5:\n\t\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Index\", k));\n\t\t\t/* } */ case 6:\n\t\tcase 1:\n\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Index }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.a = a; $f.a$1 = a$1; $f.c = c; $f.fl = fl; $f.fl$1 = fl$1; $f.fl$2 = fl$2; $f.i = i; $f.k = k; $f.s = s; $f.str = str; $f.tt = tt; $f.tt$1 = tt$1; $f.typ = typ; $f.typ$1 = typ$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Index = function(i) { return this.$val.Index(i); };\n\tValue.ptr.prototype.InterfaceData = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\t$panic(errors.New(\"InterfaceData is not supported by GopherJS\"));\n\t};\n\tValue.prototype.InterfaceData = function() { return this.$val.InterfaceData(); };\n\tValue.ptr.prototype.IsNil = function() {\n\t\tvar $ptr, _1, k, v;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif ((_1 === (22)) || (_1 === (23))) {\n\t\t\treturn $clone(v, Value).object() === jsType(v.typ).nil;\n\t\t} else if (_1 === (18)) {\n\t\t\treturn $clone(v, Value).object() === $chanNil;\n\t\t} else if (_1 === (19)) {\n\t\t\treturn $clone(v, Value).object() === $throwNilPointerError;\n\t\t} else if (_1 === (21)) {\n\t\t\treturn $clone(v, Value).object() === false;\n\t\t} else if (_1 === (20)) {\n\t\t\treturn $clone(v, Value).object() === $ifaceNil;\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.IsNil\", k));\n\t\t}\n\t};\n\tValue.prototype.IsNil = function() { return this.$val.IsNil(); };\n\tValue.ptr.prototype.Len = function() {\n\t\tvar $ptr, _1, k, v;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif ((_1 === (17)) || (_1 === (24))) {\n\t\t\treturn $parseInt($clone(v, Value).object().length);\n\t\t} else if (_1 === (23)) {\n\t\t\treturn $parseInt($clone(v, Value).object().$length) >> 0;\n\t\t} else if (_1 === (18)) {\n\t\t\treturn $parseInt($clone(v, Value).object().$buffer.length) >> 0;\n\t\t} else if (_1 === (21)) {\n\t\t\treturn $parseInt($keys($clone(v, Value).object()).length);\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Len\", k));\n\t\t}\n\t};\n\tValue.prototype.Len = function() { return this.$val.Len(); };\n\tValue.ptr.prototype.Pointer = function() {\n\t\tvar $ptr, _1, k, v;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif ((_1 === (18)) || (_1 === (21)) || (_1 === (22)) || (_1 === (26))) {\n\t\t\tif ($clone(v, Value).IsNil()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn $clone(v, Value).object();\n\t\t} else if (_1 === (19)) {\n\t\t\tif ($clone(v, Value).IsNil()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t} else if (_1 === (23)) {\n\t\t\tif ($clone(v, Value).IsNil()) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn $clone(v, Value).object().$array;\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Pointer\", k));\n\t\t}\n\t};\n\tValue.prototype.Pointer = function() { return this.$val.Pointer(); };\n\tValue.ptr.prototype.Set = function(x) {\n\t\tvar $ptr, _1, _r, _r$1, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(x.flag).mustBeExported();\n\t\t_r = $clone(x, Value).assignTo(\"reflect.Set\", v.typ, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tx = _r;\n\t\t/* */ if (!((((v.flag & 128) >>> 0) === 0))) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (!((((v.flag & 128) >>> 0) === 0))) { */ case 2:\n\t\t\t\t_1 = v.typ.Kind();\n\t\t\t\t/* */ if (_1 === (17)) { $s = 5; continue; }\n\t\t\t\t/* */ if (_1 === (20)) { $s = 6; continue; }\n\t\t\t\t/* */ if (_1 === (25)) { $s = 7; continue; }\n\t\t\t\t/* */ $s = 8; continue;\n\t\t\t\t/* if (_1 === (17)) { */ case 5:\n\t\t\t\t\tjsType(v.typ).copy(v.ptr, x.ptr);\n\t\t\t\t\t$s = 9; continue;\n\t\t\t\t/* } else if (_1 === (20)) { */ case 6:\n\t\t\t\t\t_r$1 = valueInterface($clone(x, Value), false); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t\tv.ptr.$set(_r$1);\n\t\t\t\t\t$s = 9; continue;\n\t\t\t\t/* } else if (_1 === (25)) { */ case 7:\n\t\t\t\t\tcopyStruct(v.ptr, x.ptr, v.typ);\n\t\t\t\t\t$s = 9; continue;\n\t\t\t\t/* } else { */ case 8:\n\t\t\t\t\tv.ptr.$set($clone(x, Value).object());\n\t\t\t\t/* } */ case 9:\n\t\t\tcase 4:\n\t\t\t$s = -1; return;\n\t\t/* } */ case 3:\n\t\tv.ptr = x.ptr;\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Set }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Set = function(x) { return this.$val.Set(x); };\n\tValue.ptr.prototype.SetBytes = function(x) {\n\t\tvar $ptr, _r, _r$1, _v, slice, typedSlice, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _v = $f._v; slice = $f.slice; typedSlice = $f.typedSlice; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(23);\n\t\t_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (!((_r === 8))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((_r === 8))) { */ case 1:\n\t\t\t$panic(new $String(\"reflect.Value.SetBytes of non-byte slice\"));\n\t\t/* } */ case 2:\n\t\tslice = x;\n\t\tif (!(v.typ.Name() === \"\")) { _v = true; $s = 6; continue s; }\n\t\t_r$1 = v.typ.Elem().Name(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_v = !(_r$1 === \"\"); case 6:\n\t\t/* */ if (_v) { $s = 4; continue; }\n\t\t/* */ $s = 5; continue;\n\t\t/* if (_v) { */ case 4:\n\t\t\ttypedSlice = new (jsType(v.typ))(slice.$array);\n\t\t\ttypedSlice.$offset = slice.$offset;\n\t\t\ttypedSlice.$length = slice.$length;\n\t\t\ttypedSlice.$capacity = slice.$capacity;\n\t\t\tslice = typedSlice;\n\t\t/* } */ case 5:\n\t\tv.ptr.$set(slice);\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetBytes }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._v = _v; $f.slice = slice; $f.typedSlice = typedSlice; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.SetBytes = function(x) { return this.$val.SetBytes(x); };\n\tValue.ptr.prototype.SetCap = function(n) {\n\t\tvar $ptr, n, newSlice, s, v;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(23);\n\t\ts = v.ptr.$get();\n\t\tif (n < ($parseInt(s.$length) >> 0) || n > ($parseInt(s.$capacity) >> 0)) {\n\t\t\t$panic(new $String(\"reflect: slice capacity out of range in SetCap\"));\n\t\t}\n\t\tnewSlice = new (jsType(v.typ))(s.$array);\n\t\tnewSlice.$offset = s.$offset;\n\t\tnewSlice.$length = s.$length;\n\t\tnewSlice.$capacity = n;\n\t\tv.ptr.$set(newSlice);\n\t};\n\tValue.prototype.SetCap = function(n) { return this.$val.SetCap(n); };\n\tValue.ptr.prototype.SetLen = function(n) {\n\t\tvar $ptr, n, newSlice, s, v;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(23);\n\t\ts = v.ptr.$get();\n\t\tif (n < 0 || n > ($parseInt(s.$capacity) >> 0)) {\n\t\t\t$panic(new $String(\"reflect: slice length out of range in SetLen\"));\n\t\t}\n\t\tnewSlice = new (jsType(v.typ))(s.$array);\n\t\tnewSlice.$offset = s.$offset;\n\t\tnewSlice.$length = n;\n\t\tnewSlice.$capacity = s.$capacity;\n\t\tv.ptr.$set(newSlice);\n\t};\n\tValue.prototype.SetLen = function(n) { return this.$val.SetLen(n); };\n\tValue.ptr.prototype.Slice = function(i, j) {\n\t\tvar $ptr, _1, _r, _r$1, cap, i, j, kind, s, str, tt, typ, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; cap = $f.cap; i = $f.i; j = $f.j; kind = $f.kind; s = $f.s; str = $f.str; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tcap = 0;\n\t\ttyp = $ifaceNil;\n\t\ts = null;\n\t\t\tkind = new flag(v.flag).kind();\n\t\t\t_1 = kind;\n\t\t\t/* */ if (_1 === (17)) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (23)) { $s = 3; continue; }\n\t\t\t/* */ if (_1 === (24)) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if (_1 === (17)) { */ case 2:\n\t\t\t\tif (((v.flag & 256) >>> 0) === 0) {\n\t\t\t\t\t$panic(new $String(\"reflect.Value.Slice: slice of unaddressable array\"));\n\t\t\t\t}\n\t\t\t\ttt = v.typ.kindType;\n\t\t\t\tcap = (tt.len >> 0);\n\t\t\t\ttyp = SliceOf(tt.elem);\n\t\t\t\ts = new (jsType(typ))($clone(v, Value).object());\n\t\t\t\t$s = 6; continue;\n\t\t\t/* } else if (_1 === (23)) { */ case 3:\n\t\t\t\ttyp = v.typ;\n\t\t\t\ts = $clone(v, Value).object();\n\t\t\t\tcap = $parseInt(s.$capacity) >> 0;\n\t\t\t\t$s = 6; continue;\n\t\t\t/* } else if (_1 === (24)) { */ case 4:\n\t\t\t\tstr = v.ptr.$get();\n\t\t\t\tif (i < 0 || j < i || j > str.length) {\n\t\t\t\t\t$panic(new $String(\"reflect.Value.Slice: string slice index out of bounds\"));\n\t\t\t\t}\n\t\t\t\t_r = ValueOf(new $String($substring(str, i, j))); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return _r;\n\t\t\t/* } else { */ case 5:\n\t\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Slice\", kind));\n\t\t\t/* } */ case 6:\n\t\tcase 1:\n\t\tif (i < 0 || j < i || j > cap) {\n\t\t\t$panic(new $String(\"reflect.Value.Slice: slice index out of bounds\"));\n\t\t}\n\t\t_r$1 = makeValue(typ, $subslice(s, i, j), (v.flag & 96) >>> 0); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Slice }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.cap = cap; $f.i = i; $f.j = j; $f.kind = kind; $f.s = s; $f.str = str; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Slice = function(i, j) { return this.$val.Slice(i, j); };\n\tValue.ptr.prototype.Slice3 = function(i, j, k) {\n\t\tvar $ptr, _1, _r, cap, i, j, k, kind, s, tt, typ, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; cap = $f.cap; i = $f.i; j = $f.j; k = $f.k; kind = $f.kind; s = $f.s; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tcap = 0;\n\t\ttyp = $ifaceNil;\n\t\ts = null;\n\t\tkind = new flag(v.flag).kind();\n\t\t_1 = kind;\n\t\tif (_1 === (17)) {\n\t\t\tif (((v.flag & 256) >>> 0) === 0) {\n\t\t\t\t$panic(new $String(\"reflect.Value.Slice: slice of unaddressable array\"));\n\t\t\t}\n\t\t\ttt = v.typ.kindType;\n\t\t\tcap = (tt.len >> 0);\n\t\t\ttyp = SliceOf(tt.elem);\n\t\t\ts = new (jsType(typ))($clone(v, Value).object());\n\t\t} else if (_1 === (23)) {\n\t\t\ttyp = v.typ;\n\t\t\ts = $clone(v, Value).object();\n\t\t\tcap = $parseInt(s.$capacity) >> 0;\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Slice3\", kind));\n\t\t}\n\t\tif (i < 0 || j < i || k < j || k > cap) {\n\t\t\t$panic(new $String(\"reflect.Value.Slice3: slice index out of bounds\"));\n\t\t}\n\t\t_r = makeValue(typ, $subslice(s, i, j, k), (v.flag & 96) >>> 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Slice3 }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f.cap = cap; $f.i = i; $f.j = j; $f.k = k; $f.kind = kind; $f.s = s; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Slice3 = function(i, j, k) { return this.$val.Slice3(i, j, k); };\n\tValue.ptr.prototype.Close = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(18);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t$close($clone(v, Value).object());\n\t};\n\tValue.prototype.Close = function() { return this.$val.Close(); };\n\tchanrecv = function(t, ch, nb, val) {\n\t\tvar $ptr, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, ch, comms, nb, received, recvRes, selectRes, selected, t, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; ch = $f.ch; comms = $f.comms; nb = $f.nb; received = $f.received; recvRes = $f.recvRes; selectRes = $f.selectRes; selected = $f.selected; t = $f.t; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tselected = false;\n\t\treceived = false;\n\t\tcomms = new sliceType$12([new sliceType$9([ch])]);\n\t\tif (nb) {\n\t\t\tcomms = $append(comms, new sliceType$9([]));\n\t\t}\n\t\t_r = selectHelper(new sliceType$5([comms])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tselectRes = _r;\n\t\tif (nb && (($parseInt(selectRes[0]) >> 0) === 1)) {\n\t\t\t_tmp = false;\n\t\t\t_tmp$1 = false;\n\t\t\tselected = _tmp;\n\t\t\treceived = _tmp$1;\n\t\t\t$s = -1; return [selected, received];\n\t\t}\n\t\trecvRes = selectRes[1];\n\t\tval.$set(recvRes[0]);\n\t\t_tmp$2 = true;\n\t\t_tmp$3 = !!(recvRes[1]);\n\t\tselected = _tmp$2;\n\t\treceived = _tmp$3;\n\t\t$s = -1; return [selected, received];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: chanrecv }; } $f.$ptr = $ptr; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.ch = ch; $f.comms = comms; $f.nb = nb; $f.received = received; $f.recvRes = recvRes; $f.selectRes = selectRes; $f.selected = selected; $f.t = t; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tchansend = function(t, ch, val, nb) {\n\t\tvar $ptr, _r, ch, comms, nb, selectRes, t, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; ch = $f.ch; comms = $f.comms; nb = $f.nb; selectRes = $f.selectRes; t = $f.t; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tcomms = new sliceType$12([new sliceType$9([ch, val.$get()])]);\n\t\tif (nb) {\n\t\t\tcomms = $append(comms, new sliceType$9([]));\n\t\t}\n\t\t_r = selectHelper(new sliceType$5([comms])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tselectRes = _r;\n\t\tif (nb && (($parseInt(selectRes[0]) >> 0) === 1)) {\n\t\t\t$s = -1; return false;\n\t\t}\n\t\t$s = -1; return true;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: chansend }; } $f.$ptr = $ptr; $f._r = _r; $f.ch = ch; $f.comms = comms; $f.nb = nb; $f.selectRes = selectRes; $f.t = t; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tKind.prototype.String = function() {\n\t\tvar $ptr, k;\n\t\tk = this.$val;\n\t\tif ((k >> 0) < kindNames.$length) {\n\t\t\treturn ((k < 0 || k >= kindNames.$length) ? $throwRuntimeError(\"index out of range\") : kindNames.$array[kindNames.$offset + k]);\n\t\t}\n\t\treturn \"kind\" + strconv.Itoa((k >> 0));\n\t};\n\t$ptrType(Kind).prototype.String = function() { return new Kind(this.$get()).String(); };\n\trtype.ptr.prototype.String = function() {\n\t\tvar $ptr, s, t;\n\t\tt = this;\n\t\ts = $clone(t.nameOff(t.str), name).name();\n\t\tif (!((((t.tflag & 2) >>> 0) === 0))) {\n\t\t\treturn $substring(s, 1);\n\t\t}\n\t\treturn s;\n\t};\n\trtype.prototype.String = function() { return this.$val.String(); };\n\trtype.ptr.prototype.Size = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn t.size;\n\t};\n\trtype.prototype.Size = function() { return this.$val.Size(); };\n\trtype.ptr.prototype.Bits = function() {\n\t\tvar $ptr, k, t;\n\t\tt = this;\n\t\tif (t === ptrType$1.nil) {\n\t\t\t$panic(new $String(\"reflect: Bits of nil Type\"));\n\t\t}\n\t\tk = t.Kind();\n\t\tif (k < 2 || k > 16) {\n\t\t\t$panic(new $String(\"reflect: Bits of non-arithmetic Type \" + t.String()));\n\t\t}\n\t\treturn $imul((t.size >> 0), 8);\n\t};\n\trtype.prototype.Bits = function() { return this.$val.Bits(); };\n\trtype.ptr.prototype.Align = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn (t.align >> 0);\n\t};\n\trtype.prototype.Align = function() { return this.$val.Align(); };\n\trtype.ptr.prototype.FieldAlign = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn (t.fieldAlign >> 0);\n\t};\n\trtype.prototype.FieldAlign = function() { return this.$val.FieldAlign(); };\n\trtype.ptr.prototype.Kind = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn (((t.kind & 31) >>> 0) >>> 0);\n\t};\n\trtype.prototype.Kind = function() { return this.$val.Kind(); };\n\trtype.ptr.prototype.common = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn t;\n\t};\n\trtype.prototype.common = function() { return this.$val.common(); };\n\trtype.ptr.prototype.exportedMethods = function() {\n\t\tvar $ptr, _entry, _i, _i$1, _key, _ref, _ref$1, _tuple, allExported, allm, found, m, m$1, methods, name$1, name$2, t, ut, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _entry = $f._entry; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; allExported = $f.allExported; allm = $f.allm; found = $f.found; m = $f.m; m$1 = $f.m$1; methods = $f.methods; name$1 = $f.name$1; name$2 = $f.name$2; t = $f.t; ut = $f.ut; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\t$r = methodCache.RWMutex.RLock(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t_tuple = (_entry = methodCache.m[ptrType$1.keyFor(t)], _entry !== undefined ? [_entry.v, true] : [sliceType$3.nil, false]);\n\t\tmethods = _tuple[0];\n\t\tfound = _tuple[1];\n\t\t$r = methodCache.RWMutex.RUnlock(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tif (found) {\n\t\t\t$s = -1; return methods;\n\t\t}\n\t\tut = t.uncommon();\n\t\tif (ut === ptrType$6.nil) {\n\t\t\t$s = -1; return sliceType$3.nil;\n\t\t}\n\t\tallm = ut.methods();\n\t\tallExported = true;\n\t\t_ref = allm;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\tm = $clone(((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]), method);\n\t\t\tname$1 = $clone(t.nameOff(m.name), name);\n\t\t\tif (!$clone(name$1, name).isExported()) {\n\t\t\t\tallExported = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\tif (allExported) {\n\t\t\tmethods = allm;\n\t\t} else {\n\t\t\tmethods = $makeSlice(sliceType$3, 0, allm.$length);\n\t\t\t_ref$1 = allm;\n\t\t\t_i$1 = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\t\tm$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? $throwRuntimeError(\"index out of range\") : _ref$1.$array[_ref$1.$offset + _i$1]), method);\n\t\t\t\tname$2 = $clone(t.nameOff(m$1.name), name);\n\t\t\t\tif ($clone(name$2, name).isExported()) {\n\t\t\t\t\tmethods = $append(methods, m$1);\n\t\t\t\t}\n\t\t\t\t_i$1++;\n\t\t\t}\n\t\t\tmethods = $subslice(methods, 0, methods.$length, methods.$length);\n\t\t}\n\t\t$r = methodCache.RWMutex.Lock(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tif (methodCache.m === false) {\n\t\t\tmethodCache.m = {};\n\t\t}\n\t\t_key = t; (methodCache.m || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$1.keyFor(_key)] = { k: _key, v: methods };\n\t\t$r = methodCache.RWMutex.Unlock(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return methods;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.exportedMethods }; } $f.$ptr = $ptr; $f._entry = _entry; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f.allExported = allExported; $f.allm = allm; $f.found = found; $f.m = m; $f.m$1 = m$1; $f.methods = methods; $f.name$1 = name$1; $f.name$2 = name$2; $f.t = t; $f.ut = ut; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.exportedMethods = function() { return this.$val.exportedMethods(); };\n\trtype.ptr.prototype.NumMethod = function() {\n\t\tvar $ptr, _r, t, tt, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif (t.Kind() === 20) {\n\t\t\ttt = t.kindType;\n\t\t\t$s = -1; return tt.NumMethod();\n\t\t}\n\t\tif (((t.tflag & 1) >>> 0) === 0) {\n\t\t\t$s = -1; return 0;\n\t\t}\n\t\t_r = t.exportedMethods(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r.$length;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.NumMethod }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.NumMethod = function() { return this.$val.NumMethod(); };\n\trtype.ptr.prototype.MethodByName = function(name$1) {\n\t\tvar $ptr, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, i, m, name$1, ok, p, pname, t, tt, ut, utmethods, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; i = $f.i; m = $f.m; name$1 = $f.name$1; ok = $f.ok; p = $f.p; pname = $f.pname; t = $f.t; tt = $f.tt; ut = $f.ut; utmethods = $f.utmethods; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tm = new Method.ptr(\"\", \"\", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);\n\t\tok = false;\n\t\tt = this;\n\t\tif (t.Kind() === 20) {\n\t\t\ttt = t.kindType;\n\t\t\t_tuple = tt.MethodByName(name$1);\n\t\t\tMethod.copy(m, _tuple[0]);\n\t\t\tok = _tuple[1];\n\t\t\t$s = -1; return [m, ok];\n\t\t}\n\t\tut = t.uncommon();\n\t\tif (ut === ptrType$6.nil) {\n\t\t\t_tmp = new Method.ptr(\"\", \"\", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);\n\t\t\t_tmp$1 = false;\n\t\t\tMethod.copy(m, _tmp);\n\t\t\tok = _tmp$1;\n\t\t\t$s = -1; return [m, ok];\n\t\t}\n\t\tutmethods = ut.methods();\n\t\ti = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(i < (ut.mcount >> 0))) { break; } */ if(!(i < (ut.mcount >> 0))) { $s = 2; continue; }\n\t\t\tp = $clone(((i < 0 || i >= utmethods.$length) ? $throwRuntimeError(\"index out of range\") : utmethods.$array[utmethods.$offset + i]), method);\n\t\t\tpname = $clone(t.nameOff(p.name), name);\n\t\t\t/* */ if ($clone(pname, name).isExported() && $clone(pname, name).name() === name$1) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if ($clone(pname, name).isExported() && $clone(pname, name).name() === name$1) { */ case 3:\n\t\t\t\t_r = t.Method(i); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t_tmp$2 = $clone(_r, Method);\n\t\t\t\t_tmp$3 = true;\n\t\t\t\tMethod.copy(m, _tmp$2);\n\t\t\t\tok = _tmp$3;\n\t\t\t\t$s = -1; return [m, ok];\n\t\t\t/* } */ case 4:\n\t\t\ti = i + (1) >> 0;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t_tmp$4 = new Method.ptr(\"\", \"\", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);\n\t\t_tmp$5 = false;\n\t\tMethod.copy(m, _tmp$4);\n\t\tok = _tmp$5;\n\t\t$s = -1; return [m, ok];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.MethodByName }; } $f.$ptr = $ptr; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.i = i; $f.m = m; $f.name$1 = name$1; $f.ok = ok; $f.p = p; $f.pname = pname; $f.t = t; $f.tt = tt; $f.ut = ut; $f.utmethods = utmethods; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };\n\trtype.ptr.prototype.PkgPath = function() {\n\t\tvar $ptr, t, ut;\n\t\tt = this;\n\t\tif (((t.tflag & 4) >>> 0) === 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\tut = t.uncommon();\n\t\tif (ut === ptrType$6.nil) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn $clone(t.nameOff(ut.pkgPath), name).name();\n\t};\n\trtype.prototype.PkgPath = function() { return this.$val.PkgPath(); };\n\trtype.ptr.prototype.Name = function() {\n\t\tvar $ptr, i, s, t;\n\t\tt = this;\n\t\tif (((t.tflag & 4) >>> 0) === 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\ts = t.String();\n\t\ti = s.length - 1 >> 0;\n\t\twhile (true) {\n\t\t\tif (!(i >= 0)) { break; }\n\t\t\tif (s.charCodeAt(i) === 46) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = i - (1) >> 0;\n\t\t}\n\t\treturn $substring(s, (i + 1 >> 0));\n\t};\n\trtype.prototype.Name = function() { return this.$val.Name(); };\n\trtype.ptr.prototype.ChanDir = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 18))) {\n\t\t\t$panic(new $String(\"reflect: ChanDir of non-chan type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn (tt.dir >> 0);\n\t};\n\trtype.prototype.ChanDir = function() { return this.$val.ChanDir(); };\n\trtype.ptr.prototype.IsVariadic = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 19))) {\n\t\t\t$panic(new $String(\"reflect: IsVariadic of non-func type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn !((((tt.outCount & 32768) >>> 0) === 0));\n\t};\n\trtype.prototype.IsVariadic = function() { return this.$val.IsVariadic(); };\n\trtype.ptr.prototype.Elem = function() {\n\t\tvar $ptr, _1, t, tt, tt$1, tt$2, tt$3, tt$4;\n\t\tt = this;\n\t\t_1 = t.Kind();\n\t\tif (_1 === (17)) {\n\t\t\ttt = t.kindType;\n\t\t\treturn toType(tt.elem);\n\t\t} else if (_1 === (18)) {\n\t\t\ttt$1 = t.kindType;\n\t\t\treturn toType(tt$1.elem);\n\t\t} else if (_1 === (21)) {\n\t\t\ttt$2 = t.kindType;\n\t\t\treturn toType(tt$2.elem);\n\t\t} else if (_1 === (22)) {\n\t\t\ttt$3 = t.kindType;\n\t\t\treturn toType(tt$3.elem);\n\t\t} else if (_1 === (23)) {\n\t\t\ttt$4 = t.kindType;\n\t\t\treturn toType(tt$4.elem);\n\t\t}\n\t\t$panic(new $String(\"reflect: Elem of invalid type\"));\n\t};\n\trtype.prototype.Elem = function() { return this.$val.Elem(); };\n\trtype.ptr.prototype.Field = function(i) {\n\t\tvar $ptr, _r, i, t, tt, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; i = $f.i; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif (!((t.Kind() === 25))) {\n\t\t\t$panic(new $String(\"reflect: Field of non-struct type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\t_r = tt.Field(i); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Field }; } $f.$ptr = $ptr; $f._r = _r; $f.i = i; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.Field = function(i) { return this.$val.Field(i); };\n\trtype.ptr.prototype.FieldByIndex = function(index) {\n\t\tvar $ptr, _r, index, t, tt, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; index = $f.index; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif (!((t.Kind() === 25))) {\n\t\t\t$panic(new $String(\"reflect: FieldByIndex of non-struct type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\t_r = tt.FieldByIndex(index); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByIndex }; } $f.$ptr = $ptr; $f._r = _r; $f.index = index; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };\n\trtype.ptr.prototype.FieldByName = function(name$1) {\n\t\tvar $ptr, _r, name$1, t, tt, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; name$1 = $f.name$1; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif (!((t.Kind() === 25))) {\n\t\t\t$panic(new $String(\"reflect: FieldByName of non-struct type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\t_r = tt.FieldByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByName }; } $f.$ptr = $ptr; $f._r = _r; $f.name$1 = name$1; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };\n\trtype.ptr.prototype.FieldByNameFunc = function(match) {\n\t\tvar $ptr, _r, match, t, tt, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; match = $f.match; t = $f.t; tt = $f.tt; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif (!((t.Kind() === 25))) {\n\t\t\t$panic(new $String(\"reflect: FieldByNameFunc of non-struct type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\t_r = tt.FieldByNameFunc(match); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.FieldByNameFunc }; } $f.$ptr = $ptr; $f._r = _r; $f.match = match; $f.t = t; $f.tt = tt; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };\n\trtype.ptr.prototype.In = function(i) {\n\t\tvar $ptr, i, t, tt, x;\n\t\tt = this;\n\t\tif (!((t.Kind() === 19))) {\n\t\t\t$panic(new $String(\"reflect: In of non-func type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn toType((x = tt.in$(), ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i])));\n\t};\n\trtype.prototype.In = function(i) { return this.$val.In(i); };\n\trtype.ptr.prototype.Key = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 21))) {\n\t\t\t$panic(new $String(\"reflect: Key of non-map type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn toType(tt.key);\n\t};\n\trtype.prototype.Key = function() { return this.$val.Key(); };\n\trtype.ptr.prototype.Len = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 17))) {\n\t\t\t$panic(new $String(\"reflect: Len of non-array type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn (tt.len >> 0);\n\t};\n\trtype.prototype.Len = function() { return this.$val.Len(); };\n\trtype.ptr.prototype.NumField = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 25))) {\n\t\t\t$panic(new $String(\"reflect: NumField of non-struct type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn tt.fields.$length;\n\t};\n\trtype.prototype.NumField = function() { return this.$val.NumField(); };\n\trtype.ptr.prototype.NumIn = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 19))) {\n\t\t\t$panic(new $String(\"reflect: NumIn of non-func type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn (tt.inCount >> 0);\n\t};\n\trtype.prototype.NumIn = function() { return this.$val.NumIn(); };\n\trtype.ptr.prototype.NumOut = function() {\n\t\tvar $ptr, t, tt;\n\t\tt = this;\n\t\tif (!((t.Kind() === 19))) {\n\t\t\t$panic(new $String(\"reflect: NumOut of non-func type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn tt.out().$length;\n\t};\n\trtype.prototype.NumOut = function() { return this.$val.NumOut(); };\n\trtype.ptr.prototype.Out = function(i) {\n\t\tvar $ptr, i, t, tt, x;\n\t\tt = this;\n\t\tif (!((t.Kind() === 19))) {\n\t\t\t$panic(new $String(\"reflect: Out of non-func type\"));\n\t\t}\n\t\ttt = t.kindType;\n\t\treturn toType((x = tt.out(), ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i])));\n\t};\n\trtype.prototype.Out = function(i) { return this.$val.Out(i); };\n\tChanDir.prototype.String = function() {\n\t\tvar $ptr, _1, d;\n\t\td = this.$val;\n\t\t_1 = d;\n\t\tif (_1 === (2)) {\n\t\t\treturn \"chan<-\";\n\t\t} else if (_1 === (1)) {\n\t\t\treturn \"<-chan\";\n\t\t} else if (_1 === (3)) {\n\t\t\treturn \"chan\";\n\t\t}\n\t\treturn \"ChanDir\" + strconv.Itoa((d >> 0));\n\t};\n\t$ptrType(ChanDir).prototype.String = function() { return new ChanDir(this.$get()).String(); };\n\tinterfaceType.ptr.prototype.Method = function(i) {\n\t\tvar $ptr, i, m, p, pname, t, x;\n\t\tm = new Method.ptr(\"\", \"\", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);\n\t\tt = this;\n\t\tif (i < 0 || i >= t.methods.$length) {\n\t\t\treturn m;\n\t\t}\n\t\tp = (x = t.methods, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\tpname = $clone(t.rtype.nameOff(p.name), name);\n\t\tm.Name = $clone(pname, name).name();\n\t\tif (!$clone(pname, name).isExported()) {\n\t\t\tm.PkgPath = $clone(pname, name).pkgPath();\n\t\t\tif (m.PkgPath === \"\") {\n\t\t\t\tm.PkgPath = $clone(t.pkgPath, name).name();\n\t\t\t}\n\t\t}\n\t\tm.Type = toType(t.rtype.typeOff(p.typ));\n\t\tm.Index = i;\n\t\treturn m;\n\t};\n\tinterfaceType.prototype.Method = function(i) { return this.$val.Method(i); };\n\tinterfaceType.ptr.prototype.NumMethod = function() {\n\t\tvar $ptr, t;\n\t\tt = this;\n\t\treturn t.methods.$length;\n\t};\n\tinterfaceType.prototype.NumMethod = function() { return this.$val.NumMethod(); };\n\tinterfaceType.ptr.prototype.MethodByName = function(name$1) {\n\t\tvar $ptr, _i, _ref, _tmp, _tmp$1, i, m, name$1, ok, p, t, x;\n\t\tm = new Method.ptr(\"\", \"\", $ifaceNil, new Value.ptr(ptrType$1.nil, 0, 0), 0);\n\t\tok = false;\n\t\tt = this;\n\t\tif (t === ptrType$8.nil) {\n\t\t\treturn [m, ok];\n\t\t}\n\t\tp = ptrType$9.nil;\n\t\t_ref = t.methods;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\tp = (x = t.methods, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\tif ($clone(t.rtype.nameOff(p.name), name).name() === name$1) {\n\t\t\t\t_tmp = $clone(t.Method(i), Method);\n\t\t\t\t_tmp$1 = true;\n\t\t\t\tMethod.copy(m, _tmp);\n\t\t\t\tok = _tmp$1;\n\t\t\t\treturn [m, ok];\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\treturn [m, ok];\n\t};\n\tinterfaceType.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };\n\tStructTag.prototype.Get = function(key) {\n\t\tvar $ptr, _tuple, key, tag, v;\n\t\ttag = this.$val;\n\t\t_tuple = new StructTag(tag).Lookup(key);\n\t\tv = _tuple[0];\n\t\treturn v;\n\t};\n\t$ptrType(StructTag).prototype.Get = function(key) { return new StructTag(this.$get()).Get(key); };\n\tStructTag.prototype.Lookup = function(key) {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, err, i, key, name$1, ok, qvalue, tag, value, value$1;\n\t\tvalue = \"\";\n\t\tok = false;\n\t\ttag = this.$val;\n\t\twhile (true) {\n\t\t\tif (!(!(tag === \"\"))) { break; }\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < tag.length && (tag.charCodeAt(i) === 32))) { break; }\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\ttag = $substring(tag, i);\n\t\t\tif (tag === \"\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < tag.length && tag.charCodeAt(i) > 32 && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34)) && !((tag.charCodeAt(i) === 127)))) { break; }\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\tif ((i === 0) || (i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tname$1 = $substring(tag, 0, i);\n\t\t\ttag = $substring(tag, (i + 1 >> 0));\n\t\t\ti = 1;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < tag.length && !((tag.charCodeAt(i) === 34)))) { break; }\n\t\t\t\tif (tag.charCodeAt(i) === 92) {\n\t\t\t\t\ti = i + (1) >> 0;\n\t\t\t\t}\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\tif (i >= tag.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqvalue = $substring(tag, 0, (i + 1 >> 0));\n\t\t\ttag = $substring(tag, (i + 1 >> 0));\n\t\t\tif (key === name$1) {\n\t\t\t\t_tuple = strconv.Unquote(qvalue);\n\t\t\t\tvalue$1 = _tuple[0];\n\t\t\t\terr = _tuple[1];\n\t\t\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t_tmp = value$1;\n\t\t\t\t_tmp$1 = true;\n\t\t\t\tvalue = _tmp;\n\t\t\t\tok = _tmp$1;\n\t\t\t\treturn [value, ok];\n\t\t\t}\n\t\t}\n\t\t_tmp$2 = \"\";\n\t\t_tmp$3 = false;\n\t\tvalue = _tmp$2;\n\t\tok = _tmp$3;\n\t\treturn [value, ok];\n\t};\n\t$ptrType(StructTag).prototype.Lookup = function(key) { return new StructTag(this.$get()).Lookup(key); };\n\tstructType.ptr.prototype.Field = function(i) {\n\t\tvar $ptr, _r, _r$1, _r$2, f, i, name$1, p, t, t$1, tag, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; f = $f.f; i = $f.i; name$1 = $f.name$1; p = $f.p; t = $f.t; t$1 = $f.t$1; tag = $f.tag; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tf = new StructField.ptr(\"\", \"\", $ifaceNil, \"\", 0, sliceType$14.nil, false);\n\t\tt = this;\n\t\tif (i < 0 || i >= t.fields.$length) {\n\t\t\t$panic(new $String(\"reflect: Field index out of bounds\"));\n\t\t}\n\t\tp = (x = t.fields, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\tf.Type = toType(p.typ);\n\t\tname$1 = $clone(p.name, name).name();\n\t\t/* */ if (!(name$1 === \"\")) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!(name$1 === \"\")) { */ case 1:\n\t\t\tf.Name = name$1;\n\t\t\t$s = 3; continue;\n\t\t/* } else { */ case 2:\n\t\t\tt$1 = f.Type;\n\t\t\t_r = t$1.Kind(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t/* */ if (_r === 22) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if (_r === 22) { */ case 4:\n\t\t\t\t_r$1 = t$1.Elem(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\tt$1 = _r$1;\n\t\t\t/* } */ case 5:\n\t\t\t_r$2 = t$1.Name(); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\tf.Name = _r$2;\n\t\t\tf.Anonymous = true;\n\t\t/* } */ case 3:\n\t\tif (!$clone(p.name, name).isExported()) {\n\t\t\tf.PkgPath = $clone(t.pkgPath, name).name();\n\t\t}\n\t\ttag = $clone(p.name, name).tag();\n\t\tif (!(tag === \"\")) {\n\t\t\tf.Tag = tag;\n\t\t}\n\t\tf.Offset = p.offset;\n\t\tf.Index = new sliceType$14([i]);\n\t\t$s = -1; return f;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.Field }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.f = f; $f.i = i; $f.name$1 = name$1; $f.p = p; $f.t = t; $f.t$1 = t$1; $f.tag = tag; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tstructType.prototype.Field = function(i) { return this.$val.Field(i); };\n\tstructType.ptr.prototype.FieldByIndex = function(index) {\n\t\tvar $ptr, _i, _r, _r$1, _r$2, _r$3, _r$4, _ref, _v, f, ft, i, index, t, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _v = $f._v; f = $f.f; ft = $f.ft; i = $f.i; index = $f.index; t = $f.t; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tf = new StructField.ptr(\"\", \"\", $ifaceNil, \"\", 0, sliceType$14.nil, false);\n\t\tt = this;\n\t\tf.Type = toType(t.rtype);\n\t\t_ref = index;\n\t\t_i = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }\n\t\t\ti = _i;\n\t\t\tx = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t/* */ if (i > 0) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (i > 0) { */ case 3:\n\t\t\t\tft = f.Type;\n\t\t\t\t_r = ft.Kind(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\tif (!(_r === 22)) { _v = false; $s = 7; continue s; }\n\t\t\t\t_r$1 = ft.Elem(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t_r$2 = _r$1.Kind(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_v = _r$2 === 25; case 7:\n\t\t\t\t/* */ if (_v) { $s = 5; continue; }\n\t\t\t\t/* */ $s = 6; continue;\n\t\t\t\t/* if (_v) { */ case 5:\n\t\t\t\t\t_r$3 = ft.Elem(); /* */ $s = 11; case 11: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t\t\tft = _r$3;\n\t\t\t\t/* } */ case 6:\n\t\t\t\tf.Type = ft;\n\t\t\t/* } */ case 4:\n\t\t\t_r$4 = f.Type.Field(x); /* */ $s = 12; case 12: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t\tStructField.copy(f, _r$4);\n\t\t\t_i++;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t$s = -1; return f;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByIndex }; } $f.$ptr = $ptr; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._v = _v; $f.f = f; $f.ft = ft; $f.i = i; $f.index = index; $f.t = t; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tstructType.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };\n\tstructType.ptr.prototype.FieldByNameFunc = function(match) {\n\t\tvar $ptr, _entry, _entry$1, _entry$2, _entry$3, _i, _i$1, _key, _key$1, _key$2, _key$3, _r, _r$1, _r$2, _ref, _ref$1, _tmp, _tmp$1, _tmp$2, _tmp$3, count, current, f, fname, i, index, match, name$1, next, nextCount, ntyp, ok, result, scan, styp, t, t$1, visited, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _key$3 = $f._key$3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; count = $f.count; current = $f.current; f = $f.f; fname = $f.fname; i = $f.i; index = $f.index; match = $f.match; name$1 = $f.name$1; next = $f.next; nextCount = $f.nextCount; ntyp = $f.ntyp; ok = $f.ok; result = $f.result; scan = $f.scan; styp = $f.styp; t = $f.t; t$1 = $f.t$1; visited = $f.visited; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tresult = new StructField.ptr(\"\", \"\", $ifaceNil, \"\", 0, sliceType$14.nil, false);\n\t\tok = false;\n\t\tt = this;\n\t\tcurrent = new sliceType$15([]);\n\t\tnext = new sliceType$15([new fieldScan.ptr(t, sliceType$14.nil)]);\n\t\tnextCount = false;\n\t\tvisited = $makeMap(ptrType$10.keyFor, []);\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(next.$length > 0)) { break; } */ if(!(next.$length > 0)) { $s = 2; continue; }\n\t\t\t_tmp = next;\n\t\t\t_tmp$1 = $subslice(current, 0, 0);\n\t\t\tcurrent = _tmp;\n\t\t\tnext = _tmp$1;\n\t\t\tcount = nextCount;\n\t\t\tnextCount = false;\n\t\t\t_ref = current;\n\t\t\t_i = 0;\n\t\t\t/* while (true) { */ case 3:\n\t\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }\n\t\t\t\tscan = $clone(((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]), fieldScan);\n\t\t\t\tt$1 = scan.typ;\n\t\t\t\t/* */ if ((_entry = visited[ptrType$10.keyFor(t$1)], _entry !== undefined ? _entry.v : false)) { $s = 5; continue; }\n\t\t\t\t/* */ $s = 6; continue;\n\t\t\t\t/* if ((_entry = visited[ptrType$10.keyFor(t$1)], _entry !== undefined ? _entry.v : false)) { */ case 5:\n\t\t\t\t\t_i++;\n\t\t\t\t\t/* continue; */ $s = 3; continue;\n\t\t\t\t/* } */ case 6:\n\t\t\t\t_key = t$1; (visited || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$10.keyFor(_key)] = { k: _key, v: true };\n\t\t\t\t_ref$1 = t$1.fields;\n\t\t\t\t_i$1 = 0;\n\t\t\t\t/* while (true) { */ case 7:\n\t\t\t\t\t/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 8; continue; }\n\t\t\t\t\ti = _i$1;\n\t\t\t\t\tf = (x = t$1.fields, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\t\t\tfname = \"\";\n\t\t\t\t\tntyp = ptrType$1.nil;\n\t\t\t\t\tname$1 = $clone(f.name, name).name();\n\t\t\t\t\t/* */ if (!(name$1 === \"\")) { $s = 9; continue; }\n\t\t\t\t\t/* */ $s = 10; continue;\n\t\t\t\t\t/* if (!(name$1 === \"\")) { */ case 9:\n\t\t\t\t\t\tfname = name$1;\n\t\t\t\t\t\t$s = 11; continue;\n\t\t\t\t\t/* } else { */ case 10:\n\t\t\t\t\t\tntyp = f.typ;\n\t\t\t\t\t\t/* */ if (ntyp.Kind() === 22) { $s = 12; continue; }\n\t\t\t\t\t\t/* */ $s = 13; continue;\n\t\t\t\t\t\t/* if (ntyp.Kind() === 22) { */ case 12:\n\t\t\t\t\t\t\t_r = ntyp.Elem().common(); /* */ $s = 14; case 14: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\tntyp = _r;\n\t\t\t\t\t\t/* } */ case 13:\n\t\t\t\t\t\tfname = ntyp.Name();\n\t\t\t\t\t/* } */ case 11:\n\t\t\t\t\t_r$1 = match(fname); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t\t/* */ if (_r$1) { $s = 15; continue; }\n\t\t\t\t\t/* */ $s = 16; continue;\n\t\t\t\t\t/* if (_r$1) { */ case 15:\n\t\t\t\t\t\tif ((_entry$1 = count[ptrType$10.keyFor(t$1)], _entry$1 !== undefined ? _entry$1.v : 0) > 1 || ok) {\n\t\t\t\t\t\t\t_tmp$2 = new StructField.ptr(\"\", \"\", $ifaceNil, \"\", 0, sliceType$14.nil, false);\n\t\t\t\t\t\t\t_tmp$3 = false;\n\t\t\t\t\t\t\tStructField.copy(result, _tmp$2);\n\t\t\t\t\t\t\tok = _tmp$3;\n\t\t\t\t\t\t\t$s = -1; return [result, ok];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_r$2 = t$1.Field(i); /* */ $s = 18; case 18: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t\t\tStructField.copy(result, _r$2);\n\t\t\t\t\t\tresult.Index = sliceType$14.nil;\n\t\t\t\t\t\tresult.Index = $appendSlice(result.Index, scan.index);\n\t\t\t\t\t\tresult.Index = $append(result.Index, i);\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t_i$1++;\n\t\t\t\t\t\t/* continue; */ $s = 7; continue;\n\t\t\t\t\t/* } */ case 16:\n\t\t\t\t\tif (ok || ntyp === ptrType$1.nil || !((ntyp.Kind() === 25))) {\n\t\t\t\t\t\t_i$1++;\n\t\t\t\t\t\t/* continue; */ $s = 7; continue;\n\t\t\t\t\t}\n\t\t\t\t\tstyp = ntyp.kindType;\n\t\t\t\t\tif ((_entry$2 = nextCount[ptrType$10.keyFor(styp)], _entry$2 !== undefined ? _entry$2.v : 0) > 0) {\n\t\t\t\t\t\t_key$1 = styp; (nextCount || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$10.keyFor(_key$1)] = { k: _key$1, v: 2 };\n\t\t\t\t\t\t_i$1++;\n\t\t\t\t\t\t/* continue; */ $s = 7; continue;\n\t\t\t\t\t}\n\t\t\t\t\tif (nextCount === false) {\n\t\t\t\t\t\tnextCount = $makeMap(ptrType$10.keyFor, []);\n\t\t\t\t\t}\n\t\t\t\t\t_key$2 = styp; (nextCount || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$10.keyFor(_key$2)] = { k: _key$2, v: 1 };\n\t\t\t\t\tif ((_entry$3 = count[ptrType$10.keyFor(t$1)], _entry$3 !== undefined ? _entry$3.v : 0) > 1) {\n\t\t\t\t\t\t_key$3 = styp; (nextCount || $throwRuntimeError(\"assignment to entry in nil map\"))[ptrType$10.keyFor(_key$3)] = { k: _key$3, v: 2 };\n\t\t\t\t\t}\n\t\t\t\t\tindex = sliceType$14.nil;\n\t\t\t\t\tindex = $appendSlice(index, scan.index);\n\t\t\t\t\tindex = $append(index, i);\n\t\t\t\t\tnext = $append(next, new fieldScan.ptr(styp, index));\n\t\t\t\t\t_i$1++;\n\t\t\t\t/* } */ $s = 7; continue; case 8:\n\t\t\t\t_i++;\n\t\t\t/* } */ $s = 3; continue; case 4:\n\t\t\tif (ok) {\n\t\t\t\t/* break; */ $s = 2; continue;\n\t\t\t}\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t$s = -1; return [result, ok];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByNameFunc }; } $f.$ptr = $ptr; $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._key$3 = _key$3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.count = count; $f.current = current; $f.f = f; $f.fname = fname; $f.i = i; $f.index = index; $f.match = match; $f.name$1 = name$1; $f.next = next; $f.nextCount = nextCount; $f.ntyp = ntyp; $f.ok = ok; $f.result = result; $f.scan = scan; $f.styp = styp; $f.t = t; $f.t$1 = t$1; $f.visited = visited; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tstructType.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };\n\tstructType.ptr.prototype.FieldByName = function(name$1) {\n\t\tvar $ptr, _i, _r, _r$1, _ref, _tmp, _tmp$1, _tuple, f, hasAnon, i, name$1, present, t, tf, tfname, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; f = $f.f; hasAnon = $f.hasAnon; i = $f.i; name$1 = $f.name$1; present = $f.present; t = $f.t; tf = $f.tf; tfname = $f.tfname; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tname$1 = [name$1];\n\t\tf = new StructField.ptr(\"\", \"\", $ifaceNil, \"\", 0, sliceType$14.nil, false);\n\t\tpresent = false;\n\t\tt = this;\n\t\thasAnon = false;\n\t\t/* */ if (!(name$1[0] === \"\")) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!(name$1[0] === \"\")) { */ case 1:\n\t\t\t_ref = t.fields;\n\t\t\t_i = 0;\n\t\t\t/* while (true) { */ case 3:\n\t\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }\n\t\t\t\ti = _i;\n\t\t\t\ttf = (x = t.fields, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\t\ttfname = $clone(tf.name, name).name();\n\t\t\t\t/* */ if (tfname === \"\") { $s = 5; continue; }\n\t\t\t\t/* */ $s = 6; continue;\n\t\t\t\t/* if (tfname === \"\") { */ case 5:\n\t\t\t\t\thasAnon = true;\n\t\t\t\t\t_i++;\n\t\t\t\t\t/* continue; */ $s = 3; continue;\n\t\t\t\t/* } */ case 6:\n\t\t\t\t/* */ if (tfname === name$1[0]) { $s = 7; continue; }\n\t\t\t\t/* */ $s = 8; continue;\n\t\t\t\t/* if (tfname === name$1[0]) { */ case 7:\n\t\t\t\t\t_r = t.Field(i); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t\t_tmp = $clone(_r, StructField);\n\t\t\t\t\t_tmp$1 = true;\n\t\t\t\t\tStructField.copy(f, _tmp);\n\t\t\t\t\tpresent = _tmp$1;\n\t\t\t\t\t$s = -1; return [f, present];\n\t\t\t\t/* } */ case 8:\n\t\t\t\t_i++;\n\t\t\t/* } */ $s = 3; continue; case 4:\n\t\t/* } */ case 2:\n\t\tif (!hasAnon) {\n\t\t\t$s = -1; return [f, present];\n\t\t}\n\t\t_r$1 = t.FieldByNameFunc((function(name$1) { return function(s) {\n\t\t\tvar $ptr, s;\n\t\t\treturn s === name$1[0];\n\t\t}; })(name$1)); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple = _r$1;\n\t\tStructField.copy(f, _tuple[0]);\n\t\tpresent = _tuple[1];\n\t\t$s = -1; return [f, present];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: structType.ptr.prototype.FieldByName }; } $f.$ptr = $ptr; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.f = f; $f.hasAnon = hasAnon; $f.i = i; $f.name$1 = name$1; $f.present = present; $f.t = t; $f.tf = tf; $f.tfname = tfname; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tstructType.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };\n\tPtrTo = function(t) {\n\t\tvar $ptr, t;\n\t\treturn $assertType(t, ptrType$1).ptrTo();\n\t};\n\t$pkg.PtrTo = PtrTo;\n\trtype.ptr.prototype.Implements = function(u) {\n\t\tvar $ptr, _r, t, u, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; u = $f.u; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif ($interfaceIsEqual(u, $ifaceNil)) {\n\t\t\t$panic(new $String(\"reflect: nil type passed to Type.Implements\"));\n\t\t}\n\t\t_r = u.Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (!((_r === 20))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((_r === 20))) { */ case 1:\n\t\t\t$panic(new $String(\"reflect: non-interface type passed to Type.Implements\"));\n\t\t/* } */ case 2:\n\t\t$s = -1; return implements$1($assertType(u, ptrType$1), t);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.Implements }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.u = u; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.Implements = function(u) { return this.$val.Implements(u); };\n\trtype.ptr.prototype.AssignableTo = function(u) {\n\t\tvar $ptr, t, u, uu;\n\t\tt = this;\n\t\tif ($interfaceIsEqual(u, $ifaceNil)) {\n\t\t\t$panic(new $String(\"reflect: nil type passed to Type.AssignableTo\"));\n\t\t}\n\t\tuu = $assertType(u, ptrType$1);\n\t\treturn directlyAssignable(uu, t) || implements$1(uu, t);\n\t};\n\trtype.prototype.AssignableTo = function(u) { return this.$val.AssignableTo(u); };\n\trtype.ptr.prototype.ConvertibleTo = function(u) {\n\t\tvar $ptr, _r, t, u, uu, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; u = $f.u; uu = $f.uu; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tt = this;\n\t\tif ($interfaceIsEqual(u, $ifaceNil)) {\n\t\t\t$panic(new $String(\"reflect: nil type passed to Type.ConvertibleTo\"));\n\t\t}\n\t\tuu = $assertType(u, ptrType$1);\n\t\t_r = convertOp(uu, t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return !(_r === $throwNilPointerError);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: rtype.ptr.prototype.ConvertibleTo }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.u = u; $f.uu = uu; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\trtype.prototype.ConvertibleTo = function(u) { return this.$val.ConvertibleTo(u); };\n\timplements$1 = function(T, V) {\n\t\tvar $ptr, T, V, i, i$1, j, j$1, t, tm, tm$1, v, v$1, vm, vm$1, vmethods, x, x$1, x$2;\n\t\tif (!((T.Kind() === 20))) {\n\t\t\treturn false;\n\t\t}\n\t\tt = T.kindType;\n\t\tif (t.methods.$length === 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (V.Kind() === 20) {\n\t\t\tv = V.kindType;\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(j < v.methods.$length)) { break; }\n\t\t\t\ttm = (x = t.methods, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\t\tvm = (x$1 = v.methods, ((j < 0 || j >= x$1.$length) ? $throwRuntimeError(\"index out of range\") : x$1.$array[x$1.$offset + j]));\n\t\t\t\tif ($clone(V.nameOff(vm.name), name).name() === $clone(t.rtype.nameOff(tm.name), name).name() && V.typeOff(vm.typ) === t.rtype.typeOff(tm.typ)) {\n\t\t\t\t\ti = i + (1) >> 0;\n\t\t\t\t\tif (i >= t.methods.$length) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj = j + (1) >> 0;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tv$1 = V.uncommon();\n\t\tif (v$1 === ptrType$6.nil) {\n\t\t\treturn false;\n\t\t}\n\t\ti$1 = 0;\n\t\tvmethods = v$1.methods();\n\t\tj$1 = 0;\n\t\twhile (true) {\n\t\t\tif (!(j$1 < (v$1.mcount >> 0))) { break; }\n\t\t\ttm$1 = (x$2 = t.methods, ((i$1 < 0 || i$1 >= x$2.$length) ? $throwRuntimeError(\"index out of range\") : x$2.$array[x$2.$offset + i$1]));\n\t\t\tvm$1 = $clone(((j$1 < 0 || j$1 >= vmethods.$length) ? $throwRuntimeError(\"index out of range\") : vmethods.$array[vmethods.$offset + j$1]), method);\n\t\t\tif ($clone(V.nameOff(vm$1.name), name).name() === $clone(t.rtype.nameOff(tm$1.name), name).name() && V.typeOff(vm$1.mtyp) === t.rtype.typeOff(tm$1.typ)) {\n\t\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t\t\tif (i$1 >= t.methods.$length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj$1 = j$1 + (1) >> 0;\n\t\t}\n\t\treturn false;\n\t};\n\tdirectlyAssignable = function(T, V) {\n\t\tvar $ptr, T, V;\n\t\tif (T === V) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(T.Name() === \"\") && !(V.Name() === \"\") || !((T.Kind() === V.Kind()))) {\n\t\t\treturn false;\n\t\t}\n\t\treturn haveIdenticalUnderlyingType(T, V);\n\t};\n\thaveIdenticalUnderlyingType = function(T, V) {\n\t\tvar $ptr, T, V, _1, _i, _ref, i, i$1, i$2, kind, t, t$1, t$2, tf, v, v$1, v$2, vf, x, x$1;\n\t\tif (T === V) {\n\t\t\treturn true;\n\t\t}\n\t\tkind = T.Kind();\n\t\tif (!((kind === V.Kind()))) {\n\t\t\treturn false;\n\t\t}\n\t\tif (1 <= kind && kind <= 16 || (kind === 24) || (kind === 26)) {\n\t\t\treturn true;\n\t\t}\n\t\t_1 = kind;\n\t\tif (_1 === (17)) {\n\t\t\treturn $interfaceIsEqual(T.Elem(), V.Elem()) && (T.Len() === V.Len());\n\t\t} else if (_1 === (18)) {\n\t\t\tif ((V.ChanDir() === 3) && $interfaceIsEqual(T.Elem(), V.Elem())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn (V.ChanDir() === T.ChanDir()) && $interfaceIsEqual(T.Elem(), V.Elem());\n\t\t} else if (_1 === (19)) {\n\t\t\tt = T.kindType;\n\t\t\tv = V.kindType;\n\t\t\tif (!((t.outCount === v.outCount)) || !((t.inCount === v.inCount))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i < t.rtype.NumIn())) { break; }\n\t\t\t\tif (!($interfaceIsEqual(t.rtype.In(i), v.rtype.In(i)))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti = i + (1) >> 0;\n\t\t\t}\n\t\t\ti$1 = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(i$1 < t.rtype.NumOut())) { break; }\n\t\t\t\tif (!($interfaceIsEqual(t.rtype.Out(i$1), v.rtype.Out(i$1)))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (_1 === (20)) {\n\t\t\tt$1 = T.kindType;\n\t\t\tv$1 = V.kindType;\n\t\t\tif ((t$1.methods.$length === 0) && (v$1.methods.$length === 0)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} else if (_1 === (21)) {\n\t\t\treturn $interfaceIsEqual(T.Key(), V.Key()) && $interfaceIsEqual(T.Elem(), V.Elem());\n\t\t} else if ((_1 === (22)) || (_1 === (23))) {\n\t\t\treturn $interfaceIsEqual(T.Elem(), V.Elem());\n\t\t} else if (_1 === (25)) {\n\t\t\tt$2 = T.kindType;\n\t\t\tv$2 = V.kindType;\n\t\t\tif (!((t$2.fields.$length === v$2.fields.$length))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t_ref = t$2.fields;\n\t\t\t_i = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\t\ti$2 = _i;\n\t\t\t\ttf = (x = t$2.fields, ((i$2 < 0 || i$2 >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i$2]));\n\t\t\t\tvf = (x$1 = v$2.fields, ((i$2 < 0 || i$2 >= x$1.$length) ? $throwRuntimeError(\"index out of range\") : x$1.$array[x$1.$offset + i$2]));\n\t\t\t\tif (!($clone(tf.name, name).name() === $clone(vf.name, name).name())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!(tf.typ === vf.typ)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!($clone(tf.name, name).tag() === $clone(vf.name, name).tag())) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!((tf.offset === vf.offset))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_i++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\ttoType = function(t) {\n\t\tvar $ptr, t;\n\t\tif (t === ptrType$1.nil) {\n\t\t\treturn $ifaceNil;\n\t\t}\n\t\treturn t;\n\t};\n\tifaceIndir = function(t) {\n\t\tvar $ptr, t;\n\t\treturn ((t.kind & 32) >>> 0) === 0;\n\t};\n\tflag.prototype.kind = function() {\n\t\tvar $ptr, f;\n\t\tf = this.$val;\n\t\treturn (((f & 31) >>> 0) >>> 0);\n\t};\n\t$ptrType(flag).prototype.kind = function() { return new flag(this.$get()).kind(); };\n\tValue.ptr.prototype.pointer = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\tif (!((v.typ.size === 4)) || !v.typ.pointers()) {\n\t\t\t$panic(new $String(\"can't call pointer on a non-pointer Value\"));\n\t\t}\n\t\tif (!((((v.flag & 128) >>> 0) === 0))) {\n\t\t\treturn v.ptr.$get();\n\t\t}\n\t\treturn v.ptr;\n\t};\n\tValue.prototype.pointer = function() { return this.$val.pointer(); };\n\tValueError.ptr.prototype.Error = function() {\n\t\tvar $ptr, e;\n\t\te = this;\n\t\tif (e.Kind === 0) {\n\t\t\treturn \"reflect: call of \" + e.Method + \" on zero Value\";\n\t\t}\n\t\treturn \"reflect: call of \" + e.Method + \" on \" + new Kind(e.Kind).String() + \" Value\";\n\t};\n\tValueError.prototype.Error = function() { return this.$val.Error(); };\n\tflag.prototype.mustBe = function(expected) {\n\t\tvar $ptr, expected, f;\n\t\tf = this.$val;\n\t\tif (!((new flag(f).kind() === expected))) {\n\t\t\t$panic(new ValueError.ptr(methodName(), new flag(f).kind()));\n\t\t}\n\t};\n\t$ptrType(flag).prototype.mustBe = function(expected) { return new flag(this.$get()).mustBe(expected); };\n\tflag.prototype.mustBeExported = function() {\n\t\tvar $ptr, f;\n\t\tf = this.$val;\n\t\tif (f === 0) {\n\t\t\t$panic(new ValueError.ptr(methodName(), 0));\n\t\t}\n\t\tif (!((((f & 96) >>> 0) === 0))) {\n\t\t\t$panic(new $String(\"reflect: \" + methodName() + \" using value obtained using unexported field\"));\n\t\t}\n\t};\n\t$ptrType(flag).prototype.mustBeExported = function() { return new flag(this.$get()).mustBeExported(); };\n\tflag.prototype.mustBeAssignable = function() {\n\t\tvar $ptr, f;\n\t\tf = this.$val;\n\t\tif (f === 0) {\n\t\t\t$panic(new ValueError.ptr(methodName(), 0));\n\t\t}\n\t\tif (!((((f & 96) >>> 0) === 0))) {\n\t\t\t$panic(new $String(\"reflect: \" + methodName() + \" using value obtained using unexported field\"));\n\t\t}\n\t\tif (((f & 256) >>> 0) === 0) {\n\t\t\t$panic(new $String(\"reflect: \" + methodName() + \" using unaddressable value\"));\n\t\t}\n\t};\n\t$ptrType(flag).prototype.mustBeAssignable = function() { return new flag(this.$get()).mustBeAssignable(); };\n\tValue.ptr.prototype.Addr = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\tif (((v.flag & 256) >>> 0) === 0) {\n\t\t\t$panic(new $String(\"reflect.Value.Addr of unaddressable value\"));\n\t\t}\n\t\treturn new Value.ptr(v.typ.ptrTo(), v.ptr, ((((v.flag & 96) >>> 0)) | 22) >>> 0);\n\t};\n\tValue.prototype.Addr = function() { return this.$val.Addr(); };\n\tValue.ptr.prototype.Bool = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(1);\n\t\treturn v.ptr.$get();\n\t};\n\tValue.prototype.Bool = function() { return this.$val.Bool(); };\n\tValue.ptr.prototype.Bytes = function() {\n\t\tvar $ptr, _r, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(23);\n\t\t_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (!((_r === 8))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((_r === 8))) { */ case 1:\n\t\t\t$panic(new $String(\"reflect.Value.Bytes of non-byte slice\"));\n\t\t/* } */ case 2:\n\t\t$s = -1; return v.ptr.$get();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Bytes }; } $f.$ptr = $ptr; $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Bytes = function() { return this.$val.Bytes(); };\n\tValue.ptr.prototype.runes = function() {\n\t\tvar $ptr, _r, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(23);\n\t\t_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (!((_r === 5))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((_r === 5))) { */ case 1:\n\t\t\t$panic(new $String(\"reflect.Value.Bytes of non-rune slice\"));\n\t\t/* } */ case 2:\n\t\t$s = -1; return v.ptr.$get();\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.runes }; } $f.$ptr = $ptr; $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.runes = function() { return this.$val.runes(); };\n\tValue.ptr.prototype.CanAddr = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\treturn !((((v.flag & 256) >>> 0) === 0));\n\t};\n\tValue.prototype.CanAddr = function() { return this.$val.CanAddr(); };\n\tValue.ptr.prototype.CanSet = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\treturn ((v.flag & 352) >>> 0) === 256;\n\t};\n\tValue.prototype.CanSet = function() { return this.$val.CanSet(); };\n\tValue.ptr.prototype.Call = function(in$1) {\n\t\tvar $ptr, _r, in$1, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; in$1 = $f.in$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(19);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t_r = $clone(v, Value).call(\"Call\", in$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Call }; } $f.$ptr = $ptr; $f._r = _r; $f.in$1 = in$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Call = function(in$1) { return this.$val.Call(in$1); };\n\tValue.ptr.prototype.CallSlice = function(in$1) {\n\t\tvar $ptr, _r, in$1, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; in$1 = $f.in$1; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(19);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t_r = $clone(v, Value).call(\"CallSlice\", in$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.CallSlice }; } $f.$ptr = $ptr; $f._r = _r; $f.in$1 = in$1; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.CallSlice = function(in$1) { return this.$val.CallSlice(in$1); };\n\tValue.ptr.prototype.Complex = function() {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (15)) {\n\t\t\treturn (x = v.ptr.$get(), new $Complex128(x.$real, x.$imag));\n\t\t} else if (_1 === (16)) {\n\t\t\treturn v.ptr.$get();\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.Complex\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.Complex = function() { return this.$val.Complex(); };\n\tValue.ptr.prototype.FieldByIndex = function(index) {\n\t\tvar $ptr, _i, _r, _r$1, _r$2, _r$3, _ref, _v, i, index, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _v = $f._v; i = $f.i; index = $f.index; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\t/* */ if (index.$length === 1) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (index.$length === 1) { */ case 1:\n\t\t\t_r = $clone(v, Value).Field((0 >= index.$length ? $throwRuntimeError(\"index out of range\") : index.$array[index.$offset + 0])); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return _r;\n\t\t/* } */ case 2:\n\t\tnew flag(v.flag).mustBe(25);\n\t\t_ref = index;\n\t\t_i = 0;\n\t\t/* while (true) { */ case 4:\n\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }\n\t\t\ti = _i;\n\t\t\tx = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t/* */ if (i > 0) { $s = 6; continue; }\n\t\t\t/* */ $s = 7; continue;\n\t\t\t/* if (i > 0) { */ case 6:\n\t\t\t\tif (!($clone(v, Value).Kind() === 22)) { _v = false; $s = 10; continue s; }\n\t\t\t\t_r$1 = v.typ.Elem().Kind(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t_v = _r$1 === 25; case 10:\n\t\t\t\t/* */ if (_v) { $s = 8; continue; }\n\t\t\t\t/* */ $s = 9; continue;\n\t\t\t\t/* if (_v) { */ case 8:\n\t\t\t\t\tif ($clone(v, Value).IsNil()) {\n\t\t\t\t\t\t$panic(new $String(\"reflect: indirection through nil pointer to embedded struct\"));\n\t\t\t\t\t}\n\t\t\t\t\t_r$2 = $clone(v, Value).Elem(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t\tv = _r$2;\n\t\t\t\t/* } */ case 9:\n\t\t\t/* } */ case 7:\n\t\t\t_r$3 = $clone(v, Value).Field(x); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\tv = _r$3;\n\t\t\t_i++;\n\t\t/* } */ $s = 4; continue; case 5:\n\t\t$s = -1; return v;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByIndex }; } $f.$ptr = $ptr; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._v = _v; $f.i = i; $f.index = index; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.FieldByIndex = function(index) { return this.$val.FieldByIndex(index); };\n\tValue.ptr.prototype.FieldByName = function(name$1) {\n\t\tvar $ptr, _r, _r$1, _tuple, f, name$1, ok, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; f = $f.f; name$1 = $f.name$1; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(25);\n\t\t_r = v.typ.FieldByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tf = $clone(_tuple[0], StructField);\n\t\tok = _tuple[1];\n\t\t/* */ if (ok) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (ok) { */ case 2:\n\t\t\t_r$1 = $clone(v, Value).FieldByIndex(f.Index); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return _r$1;\n\t\t/* } */ case 3:\n\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByName }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.f = f; $f.name$1 = name$1; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.FieldByName = function(name$1) { return this.$val.FieldByName(name$1); };\n\tValue.ptr.prototype.FieldByNameFunc = function(match) {\n\t\tvar $ptr, _r, _r$1, _tuple, f, match, ok, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; f = $f.f; match = $f.match; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\t_r = v.typ.FieldByNameFunc(match); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tf = $clone(_tuple[0], StructField);\n\t\tok = _tuple[1];\n\t\t/* */ if (ok) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (ok) { */ case 2:\n\t\t\t_r$1 = $clone(v, Value).FieldByIndex(f.Index); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return _r$1;\n\t\t/* } */ case 3:\n\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.FieldByNameFunc }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.f = f; $f.match = match; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.FieldByNameFunc = function(match) { return this.$val.FieldByNameFunc(match); };\n\tValue.ptr.prototype.Float = function() {\n\t\tvar $ptr, _1, k, v;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (13)) {\n\t\t\treturn v.ptr.$get();\n\t\t} else if (_1 === (14)) {\n\t\t\treturn v.ptr.$get();\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.Float\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.Float = function() { return this.$val.Float(); };\n\tValue.ptr.prototype.Int = function() {\n\t\tvar $ptr, _1, k, p, v;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\tp = v.ptr;\n\t\t_1 = k;\n\t\tif (_1 === (2)) {\n\t\t\treturn new $Int64(0, p.$get());\n\t\t} else if (_1 === (3)) {\n\t\t\treturn new $Int64(0, p.$get());\n\t\t} else if (_1 === (4)) {\n\t\t\treturn new $Int64(0, p.$get());\n\t\t} else if (_1 === (5)) {\n\t\t\treturn new $Int64(0, p.$get());\n\t\t} else if (_1 === (6)) {\n\t\t\treturn p.$get();\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.Int\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.Int = function() { return this.$val.Int(); };\n\tValue.ptr.prototype.CanInterface = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\tif (v.flag === 0) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.CanInterface\", 0));\n\t\t}\n\t\treturn ((v.flag & 96) >>> 0) === 0;\n\t};\n\tValue.prototype.CanInterface = function() { return this.$val.CanInterface(); };\n\tValue.ptr.prototype.Interface = function() {\n\t\tvar $ptr, _r, i, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; i = $f.i; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ti = $ifaceNil;\n\t\tv = this;\n\t\t_r = valueInterface($clone(v, Value), true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\ti = _r;\n\t\t$s = -1; return i;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Interface }; } $f.$ptr = $ptr; $f._r = _r; $f.i = i; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Interface = function() { return this.$val.Interface(); };\n\tValue.ptr.prototype.IsValid = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\treturn !((v.flag === 0));\n\t};\n\tValue.prototype.IsValid = function() { return this.$val.IsValid(); };\n\tValue.ptr.prototype.Kind = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\treturn new flag(v.flag).kind();\n\t};\n\tValue.prototype.Kind = function() { return this.$val.Kind(); };\n\tValue.ptr.prototype.MapIndex = function(key) {\n\t\tvar $ptr, _r, c, e, fl, k, key, tt, typ, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; c = $f.c; e = $f.e; fl = $f.fl; k = $f.k; key = $f.key; tt = $f.tt; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(21);\n\t\ttt = v.typ.kindType;\n\t\t_r = $clone(key, Value).assignTo(\"reflect.Value.MapIndex\", tt.key, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tkey = _r;\n\t\tk = 0;\n\t\tif (!((((key.flag & 128) >>> 0) === 0))) {\n\t\t\tk = key.ptr;\n\t\t} else {\n\t\t\tk = (key.$ptr_ptr || (key.$ptr_ptr = new ptrType$16(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, key)));\n\t\t}\n\t\te = mapaccess(v.typ, $clone(v, Value).pointer(), k);\n\t\tif (e === 0) {\n\t\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t}\n\t\ttyp = tt.elem;\n\t\tfl = ((((v.flag | key.flag) >>> 0)) & 96) >>> 0;\n\t\tfl = (fl | ((typ.Kind() >>> 0))) >>> 0;\n\t\tif (ifaceIndir(typ)) {\n\t\t\tc = unsafe_New(typ);\n\t\t\ttypedmemmove(typ, c, e);\n\t\t\t$s = -1; return new Value.ptr(typ, c, (fl | 128) >>> 0);\n\t\t} else {\n\t\t\t$s = -1; return new Value.ptr(typ, e.$get(), fl);\n\t\t}\n\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MapIndex }; } $f.$ptr = $ptr; $f._r = _r; $f.c = c; $f.e = e; $f.fl = fl; $f.k = k; $f.key = key; $f.tt = tt; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.MapIndex = function(key) { return this.$val.MapIndex(key); };\n\tValue.ptr.prototype.MapKeys = function() {\n\t\tvar $ptr, _r, a, c, fl, i, it, key, keyType, m, mlen, tt, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; a = $f.a; c = $f.c; fl = $f.fl; i = $f.i; it = $f.it; key = $f.key; keyType = $f.keyType; m = $f.m; mlen = $f.mlen; tt = $f.tt; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(21);\n\t\ttt = v.typ.kindType;\n\t\tkeyType = tt.key;\n\t\tfl = (((v.flag & 96) >>> 0) | (keyType.Kind() >>> 0)) >>> 0;\n\t\tm = $clone(v, Value).pointer();\n\t\tmlen = 0;\n\t\tif (!(m === 0)) {\n\t\t\tmlen = maplen(m);\n\t\t}\n\t\tit = mapiterinit(v.typ, m);\n\t\ta = $makeSlice(sliceType$10, mlen);\n\t\ti = 0;\n\t\ti = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(i < a.$length)) { break; } */ if(!(i < a.$length)) { $s = 2; continue; }\n\t\t\t_r = mapiterkey(it); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tkey = _r;\n\t\t\tif (key === 0) {\n\t\t\t\t/* break; */ $s = 2; continue;\n\t\t\t}\n\t\t\tif (ifaceIndir(keyType)) {\n\t\t\t\tc = unsafe_New(keyType);\n\t\t\t\ttypedmemmove(keyType, c, key);\n\t\t\t\t((i < 0 || i >= a.$length) ? $throwRuntimeError(\"index out of range\") : a.$array[a.$offset + i] = new Value.ptr(keyType, c, (fl | 128) >>> 0));\n\t\t\t} else {\n\t\t\t\t((i < 0 || i >= a.$length) ? $throwRuntimeError(\"index out of range\") : a.$array[a.$offset + i] = new Value.ptr(keyType, key.$get(), fl));\n\t\t\t}\n\t\t\tmapiternext(it);\n\t\t\ti = i + (1) >> 0;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t$s = -1; return $subslice(a, 0, i);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MapKeys }; } $f.$ptr = $ptr; $f._r = _r; $f.a = a; $f.c = c; $f.fl = fl; $f.i = i; $f.it = it; $f.key = key; $f.keyType = keyType; $f.m = m; $f.mlen = mlen; $f.tt = tt; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.MapKeys = function() { return this.$val.MapKeys(); };\n\tValue.ptr.prototype.Method = function(i) {\n\t\tvar $ptr, _r, _v, fl, i, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _v = $f._v; fl = $f.fl; i = $f.i; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tif (v.typ === ptrType$1.nil) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Method\", 0));\n\t\t}\n\t\tif (!((((v.flag & 512) >>> 0) === 0))) { _v = true; $s = 3; continue s; }\n\t\t_r = v.typ.NumMethod(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_v = (i >>> 0) >= (_r >>> 0); case 3:\n\t\t/* */ if (_v) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (_v) { */ case 1:\n\t\t\t$panic(new $String(\"reflect: Method index out of range\"));\n\t\t/* } */ case 2:\n\t\tif ((v.typ.Kind() === 20) && $clone(v, Value).IsNil()) {\n\t\t\t$panic(new $String(\"reflect: Method on nil interface value\"));\n\t\t}\n\t\tfl = (v.flag & 160) >>> 0;\n\t\tfl = (fl | (19)) >>> 0;\n\t\tfl = (fl | (((((i >>> 0) << 10 >>> 0) | 512) >>> 0))) >>> 0;\n\t\t$s = -1; return new Value.ptr(v.typ, v.ptr, fl);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Method }; } $f.$ptr = $ptr; $f._r = _r; $f._v = _v; $f.fl = fl; $f.i = i; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Method = function(i) { return this.$val.Method(i); };\n\tValue.ptr.prototype.NumMethod = function() {\n\t\tvar $ptr, _r, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tif (v.typ === ptrType$1.nil) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.NumMethod\", 0));\n\t\t}\n\t\tif (!((((v.flag & 512) >>> 0) === 0))) {\n\t\t\t$s = -1; return 0;\n\t\t}\n\t\t_r = v.typ.NumMethod(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.NumMethod }; } $f.$ptr = $ptr; $f._r = _r; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.NumMethod = function() { return this.$val.NumMethod(); };\n\tValue.ptr.prototype.MethodByName = function(name$1) {\n\t\tvar $ptr, _r, _r$1, _tuple, m, name$1, ok, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; m = $f.m; name$1 = $f.name$1; ok = $f.ok; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tif (v.typ === ptrType$1.nil) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.MethodByName\", 0));\n\t\t}\n\t\tif (!((((v.flag & 512) >>> 0) === 0))) {\n\t\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t}\n\t\t_r = v.typ.MethodByName(name$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tm = $clone(_tuple[0], Method);\n\t\tok = _tuple[1];\n\t\tif (!ok) {\n\t\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t}\n\t\t_r$1 = $clone(v, Value).Method(m.Index); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.MethodByName }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.m = m; $f.name$1 = name$1; $f.ok = ok; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.MethodByName = function(name$1) { return this.$val.MethodByName(name$1); };\n\tValue.ptr.prototype.NumField = function() {\n\t\tvar $ptr, tt, v;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(25);\n\t\ttt = v.typ.kindType;\n\t\treturn tt.fields.$length;\n\t};\n\tValue.prototype.NumField = function() { return this.$val.NumField(); };\n\tValue.ptr.prototype.OverflowComplex = function(x) {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (15)) {\n\t\t\treturn overflowFloat32(x.$real) || overflowFloat32(x.$imag);\n\t\t} else if (_1 === (16)) {\n\t\t\treturn false;\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.OverflowComplex\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.OverflowComplex = function(x) { return this.$val.OverflowComplex(x); };\n\tValue.ptr.prototype.OverflowFloat = function(x) {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (13)) {\n\t\t\treturn overflowFloat32(x);\n\t\t} else if (_1 === (14)) {\n\t\t\treturn false;\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.OverflowFloat\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.OverflowFloat = function(x) { return this.$val.OverflowFloat(x); };\n\toverflowFloat32 = function(x) {\n\t\tvar $ptr, x;\n\t\tif (x < 0) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn 3.4028234663852886e+38 < x && x <= 1.7976931348623157e+308;\n\t};\n\tValue.ptr.prototype.OverflowInt = function(x) {\n\t\tvar $ptr, _1, bitSize, k, trunc, v, x;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) {\n\t\t\tbitSize = $imul(v.typ.size, 8) >>> 0;\n\t\t\ttrunc = $shiftRightInt64(($shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));\n\t\t\treturn !((x.$high === trunc.$high && x.$low === trunc.$low));\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.OverflowInt\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.OverflowInt = function(x) { return this.$val.OverflowInt(x); };\n\tValue.ptr.prototype.OverflowUint = function(x) {\n\t\tvar $ptr, _1, bitSize, k, trunc, v, x;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif ((_1 === (7)) || (_1 === (12)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11))) {\n\t\t\tbitSize = $imul(v.typ.size, 8) >>> 0;\n\t\t\ttrunc = $shiftRightUint64(($shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));\n\t\t\treturn !((x.$high === trunc.$high && x.$low === trunc.$low));\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.OverflowUint\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.OverflowUint = function(x) { return this.$val.OverflowUint(x); };\n\tValue.ptr.prototype.Recv = function() {\n\t\tvar $ptr, _r, _tuple, ok, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; ok = $f.ok; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tx = new Value.ptr(ptrType$1.nil, 0, 0);\n\t\tok = false;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(18);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t_r = $clone(v, Value).recv(false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tx = _tuple[0];\n\t\tok = _tuple[1];\n\t\t$s = -1; return [x, ok];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Recv }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.ok = ok; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Recv = function() { return this.$val.Recv(); };\n\tValue.ptr.prototype.recv = function(nb) {\n\t\tvar $ptr, _r, _tuple, nb, ok, p, selected, t, tt, v, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; nb = $f.nb; ok = $f.ok; p = $f.p; selected = $f.selected; t = $f.t; tt = $f.tt; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tval = new Value.ptr(ptrType$1.nil, 0, 0);\n\t\tok = false;\n\t\tv = this;\n\t\ttt = v.typ.kindType;\n\t\tif (((tt.dir >> 0) & 1) === 0) {\n\t\t\t$panic(new $String(\"reflect: recv on send-only channel\"));\n\t\t}\n\t\tt = tt.elem;\n\t\tval = new Value.ptr(t, 0, (t.Kind() >>> 0));\n\t\tp = 0;\n\t\tif (ifaceIndir(t)) {\n\t\t\tp = unsafe_New(t);\n\t\t\tval.ptr = p;\n\t\t\tval.flag = (val.flag | (128)) >>> 0;\n\t\t} else {\n\t\t\tp = (val.$ptr_ptr || (val.$ptr_ptr = new ptrType$16(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, val)));\n\t\t}\n\t\t_r = chanrecv(v.typ, $clone(v, Value).pointer(), nb, p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tselected = _tuple[0];\n\t\tok = _tuple[1];\n\t\tif (!selected) {\n\t\t\tval = new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t}\n\t\t$s = -1; return [val, ok];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.recv }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.nb = nb; $f.ok = ok; $f.p = p; $f.selected = selected; $f.t = t; $f.tt = tt; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.recv = function(nb) { return this.$val.recv(nb); };\n\tValue.ptr.prototype.Send = function(x) {\n\t\tvar $ptr, _r, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(18);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t_r = $clone(v, Value).send($clone(x, Value), false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r;\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Send }; } $f.$ptr = $ptr; $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Send = function(x) { return this.$val.Send(x); };\n\tValue.ptr.prototype.send = function(x, nb) {\n\t\tvar $ptr, _r, _r$1, nb, p, selected, tt, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; nb = $f.nb; p = $f.p; selected = $f.selected; tt = $f.tt; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tselected = false;\n\t\tv = this;\n\t\ttt = v.typ.kindType;\n\t\tif (((tt.dir >> 0) & 2) === 0) {\n\t\t\t$panic(new $String(\"reflect: send on recv-only channel\"));\n\t\t}\n\t\tnew flag(x.flag).mustBeExported();\n\t\t_r = $clone(x, Value).assignTo(\"reflect.Value.Send\", tt.elem, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tx = _r;\n\t\tp = 0;\n\t\tif (!((((x.flag & 128) >>> 0) === 0))) {\n\t\t\tp = x.ptr;\n\t\t} else {\n\t\t\tp = (x.$ptr_ptr || (x.$ptr_ptr = new ptrType$16(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, x)));\n\t\t}\n\t\t_r$1 = chansend(v.typ, $clone(v, Value).pointer(), p, nb); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tselected = _r$1;\n\t\t$s = -1; return selected;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.send }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.nb = nb; $f.p = p; $f.selected = selected; $f.tt = tt; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.send = function(x, nb) { return this.$val.send(x, nb); };\n\tValue.ptr.prototype.SetBool = function(x) {\n\t\tvar $ptr, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(1);\n\t\tv.ptr.$set(x);\n\t};\n\tValue.prototype.SetBool = function(x) { return this.$val.SetBool(x); };\n\tValue.ptr.prototype.setRunes = function(x) {\n\t\tvar $ptr, _r, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(23);\n\t\t_r = v.typ.Elem().Kind(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t/* */ if (!((_r === 5))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((_r === 5))) { */ case 1:\n\t\t\t$panic(new $String(\"reflect.Value.setRunes of non-rune slice\"));\n\t\t/* } */ case 2:\n\t\tv.ptr.$set(x);\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.setRunes }; } $f.$ptr = $ptr; $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.setRunes = function(x) { return this.$val.setRunes(x); };\n\tValue.ptr.prototype.SetComplex = function(x) {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (15)) {\n\t\t\tv.ptr.$set(new $Complex64(x.$real, x.$imag));\n\t\t} else if (_1 === (16)) {\n\t\t\tv.ptr.$set(x);\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.SetComplex\", new flag(v.flag).kind()));\n\t\t}\n\t};\n\tValue.prototype.SetComplex = function(x) { return this.$val.SetComplex(x); };\n\tValue.ptr.prototype.SetFloat = function(x) {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (13)) {\n\t\t\tv.ptr.$set($fround(x));\n\t\t} else if (_1 === (14)) {\n\t\t\tv.ptr.$set(x);\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.SetFloat\", new flag(v.flag).kind()));\n\t\t}\n\t};\n\tValue.prototype.SetFloat = function(x) { return this.$val.SetFloat(x); };\n\tValue.ptr.prototype.SetInt = function(x) {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (2)) {\n\t\t\tv.ptr.$set(((x.$low + ((x.$high >> 31) * 4294967296)) >> 0));\n\t\t} else if (_1 === (3)) {\n\t\t\tv.ptr.$set(((x.$low + ((x.$high >> 31) * 4294967296)) << 24 >> 24));\n\t\t} else if (_1 === (4)) {\n\t\t\tv.ptr.$set(((x.$low + ((x.$high >> 31) * 4294967296)) << 16 >> 16));\n\t\t} else if (_1 === (5)) {\n\t\t\tv.ptr.$set(((x.$low + ((x.$high >> 31) * 4294967296)) >> 0));\n\t\t} else if (_1 === (6)) {\n\t\t\tv.ptr.$set(x);\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.SetInt\", new flag(v.flag).kind()));\n\t\t}\n\t};\n\tValue.prototype.SetInt = function(x) { return this.$val.SetInt(x); };\n\tValue.ptr.prototype.SetMapIndex = function(key, val) {\n\t\tvar $ptr, _r, _r$1, e, k, key, tt, v, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; e = $f.e; k = $f.k; key = $f.key; tt = $f.tt; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(21);\n\t\tnew flag(v.flag).mustBeExported();\n\t\tnew flag(key.flag).mustBeExported();\n\t\ttt = v.typ.kindType;\n\t\t_r = $clone(key, Value).assignTo(\"reflect.Value.SetMapIndex\", tt.key, 0); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tkey = _r;\n\t\tk = 0;\n\t\tif (!((((key.flag & 128) >>> 0) === 0))) {\n\t\t\tk = key.ptr;\n\t\t} else {\n\t\t\tk = (key.$ptr_ptr || (key.$ptr_ptr = new ptrType$16(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, key)));\n\t\t}\n\t\tif (val.typ === ptrType$1.nil) {\n\t\t\tmapdelete(v.typ, $clone(v, Value).pointer(), k);\n\t\t\t$s = -1; return;\n\t\t}\n\t\tnew flag(val.flag).mustBeExported();\n\t\t_r$1 = $clone(val, Value).assignTo(\"reflect.Value.SetMapIndex\", tt.elem, 0); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tval = _r$1;\n\t\te = 0;\n\t\tif (!((((val.flag & 128) >>> 0) === 0))) {\n\t\t\te = val.ptr;\n\t\t} else {\n\t\t\te = (val.$ptr_ptr || (val.$ptr_ptr = new ptrType$16(function() { return this.$target.ptr; }, function($v) { this.$target.ptr = $v; }, val)));\n\t\t}\n\t\t$r = mapassign(v.typ, $clone(v, Value).pointer(), k, e); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.SetMapIndex }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.e = e; $f.k = k; $f.key = key; $f.tt = tt; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.SetMapIndex = function(key, val) { return this.$val.SetMapIndex(key, val); };\n\tValue.ptr.prototype.SetUint = function(x) {\n\t\tvar $ptr, _1, k, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (7)) {\n\t\t\tv.ptr.$set((x.$low >>> 0));\n\t\t} else if (_1 === (8)) {\n\t\t\tv.ptr.$set((x.$low << 24 >>> 24));\n\t\t} else if (_1 === (9)) {\n\t\t\tv.ptr.$set((x.$low << 16 >>> 16));\n\t\t} else if (_1 === (10)) {\n\t\t\tv.ptr.$set((x.$low >>> 0));\n\t\t} else if (_1 === (11)) {\n\t\t\tv.ptr.$set(x);\n\t\t} else if (_1 === (12)) {\n\t\t\tv.ptr.$set((x.$low >>> 0));\n\t\t} else {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.SetUint\", new flag(v.flag).kind()));\n\t\t}\n\t};\n\tValue.prototype.SetUint = function(x) { return this.$val.SetUint(x); };\n\tValue.ptr.prototype.SetPointer = function(x) {\n\t\tvar $ptr, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(26);\n\t\tv.ptr.$set(x);\n\t};\n\tValue.prototype.SetPointer = function(x) { return this.$val.SetPointer(x); };\n\tValue.ptr.prototype.SetString = function(x) {\n\t\tvar $ptr, v, x;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBeAssignable();\n\t\tnew flag(v.flag).mustBe(24);\n\t\tv.ptr.$set(x);\n\t};\n\tValue.prototype.SetString = function(x) { return this.$val.SetString(x); };\n\tValue.ptr.prototype.String = function() {\n\t\tvar $ptr, _1, _r, k, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; k = $f.k; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\t_1 = k;\n\t\tif (_1 === (0)) {\n\t\t\t$s = -1; return \"<invalid Value>\";\n\t\t} else if (_1 === (24)) {\n\t\t\t$s = -1; return v.ptr.$get();\n\t\t}\n\t\t_r = $clone(v, Value).Type().String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return \"<\" + _r + \" Value>\";\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.String }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f.k = k; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.String = function() { return this.$val.String(); };\n\tValue.ptr.prototype.TryRecv = function() {\n\t\tvar $ptr, _r, _tuple, ok, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; ok = $f.ok; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tx = new Value.ptr(ptrType$1.nil, 0, 0);\n\t\tok = false;\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(18);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t_r = $clone(v, Value).recv(true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tx = _tuple[0];\n\t\tok = _tuple[1];\n\t\t$s = -1; return [x, ok];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.TryRecv }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.ok = ok; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.TryRecv = function() { return this.$val.TryRecv(); };\n\tValue.ptr.prototype.TrySend = function(x) {\n\t\tvar $ptr, _r, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\tnew flag(v.flag).mustBe(18);\n\t\tnew flag(v.flag).mustBeExported();\n\t\t_r = $clone(v, Value).send($clone(x, Value), true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.TrySend }; } $f.$ptr = $ptr; $f._r = _r; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.TrySend = function(x) { return this.$val.TrySend(x); };\n\tValue.ptr.prototype.Type = function() {\n\t\tvar $ptr, f, i, m, m$1, tt, ut, v, x, x$1;\n\t\tv = this;\n\t\tf = v.flag;\n\t\tif (f === 0) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.Type\", 0));\n\t\t}\n\t\tif (((f & 512) >>> 0) === 0) {\n\t\t\treturn v.typ;\n\t\t}\n\t\ti = (v.flag >> 0) >> 10 >> 0;\n\t\tif (v.typ.Kind() === 20) {\n\t\t\ttt = v.typ.kindType;\n\t\t\tif ((i >>> 0) >= (tt.methods.$length >>> 0)) {\n\t\t\t\t$panic(new $String(\"reflect: internal error: invalid method index\"));\n\t\t\t}\n\t\t\tm = (x = tt.methods, ((i < 0 || i >= x.$length) ? $throwRuntimeError(\"index out of range\") : x.$array[x.$offset + i]));\n\t\t\treturn v.typ.typeOff(m.typ);\n\t\t}\n\t\tut = v.typ.uncommon();\n\t\tif (ut === ptrType$6.nil || (i >>> 0) >= (ut.mcount >>> 0)) {\n\t\t\t$panic(new $String(\"reflect: internal error: invalid method index\"));\n\t\t}\n\t\tm$1 = $clone((x$1 = ut.methods(), ((i < 0 || i >= x$1.$length) ? $throwRuntimeError(\"index out of range\") : x$1.$array[x$1.$offset + i])), method);\n\t\treturn v.typ.typeOff(m$1.mtyp);\n\t};\n\tValue.prototype.Type = function() { return this.$val.Type(); };\n\tValue.ptr.prototype.Uint = function() {\n\t\tvar $ptr, _1, k, p, v, x;\n\t\tv = this;\n\t\tk = new flag(v.flag).kind();\n\t\tp = v.ptr;\n\t\t_1 = k;\n\t\tif (_1 === (7)) {\n\t\t\treturn new $Uint64(0, p.$get());\n\t\t} else if (_1 === (8)) {\n\t\t\treturn new $Uint64(0, p.$get());\n\t\t} else if (_1 === (9)) {\n\t\t\treturn new $Uint64(0, p.$get());\n\t\t} else if (_1 === (10)) {\n\t\t\treturn new $Uint64(0, p.$get());\n\t\t} else if (_1 === (11)) {\n\t\t\treturn p.$get();\n\t\t} else if (_1 === (12)) {\n\t\t\treturn (x = p.$get(), new $Uint64(0, x.constructor === Number ? x : 1));\n\t\t}\n\t\t$panic(new ValueError.ptr(\"reflect.Value.Uint\", new flag(v.flag).kind()));\n\t};\n\tValue.prototype.Uint = function() { return this.$val.Uint(); };\n\tValue.ptr.prototype.UnsafeAddr = function() {\n\t\tvar $ptr, v;\n\t\tv = this;\n\t\tif (v.typ === ptrType$1.nil) {\n\t\t\t$panic(new ValueError.ptr(\"reflect.Value.UnsafeAddr\", 0));\n\t\t}\n\t\tif (((v.flag & 256) >>> 0) === 0) {\n\t\t\t$panic(new $String(\"reflect.Value.UnsafeAddr of unaddressable value\"));\n\t\t}\n\t\treturn v.ptr;\n\t};\n\tValue.prototype.UnsafeAddr = function() { return this.$val.UnsafeAddr(); };\n\tNew = function(typ) {\n\t\tvar $ptr, _r, _r$1, fl, ptr, typ, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; fl = $f.fl; ptr = $f.ptr; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tif ($interfaceIsEqual(typ, $ifaceNil)) {\n\t\t\t$panic(new $String(\"reflect: New(nil)\"));\n\t\t}\n\t\tptr = unsafe_New($assertType(typ, ptrType$1));\n\t\tfl = 22;\n\t\t_r = typ.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r$1 = _r.ptrTo(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return new Value.ptr(_r$1, ptr, fl);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: New }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.fl = fl; $f.ptr = ptr; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.New = New;\n\tValue.ptr.prototype.assignTo = function(context, dst, target) {\n\t\tvar $ptr, _r, _r$1, _r$2, context, dst, fl, target, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; context = $f.context; dst = $f.dst; fl = $f.fl; target = $f.target; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\t/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:\n\t\t\t_r = makeMethodValue(context, $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tv = _r;\n\t\t/* } */ case 2:\n\t\t\t/* */ if (directlyAssignable(dst, v.typ)) { $s = 5; continue; }\n\t\t\t/* */ if (implements$1(dst, v.typ)) { $s = 6; continue; }\n\t\t\t/* */ $s = 7; continue;\n\t\t\t/* if (directlyAssignable(dst, v.typ)) { */ case 5:\n\t\t\t\tv.typ = dst;\n\t\t\t\tfl = (v.flag & 480) >>> 0;\n\t\t\t\tfl = (fl | ((dst.Kind() >>> 0))) >>> 0;\n\t\t\t\t$s = -1; return new Value.ptr(dst, v.ptr, fl);\n\t\t\t/* } else if (implements$1(dst, v.typ)) { */ case 6:\n\t\t\t\tif (target === 0) {\n\t\t\t\t\ttarget = unsafe_New(dst);\n\t\t\t\t}\n\t\t\t\t_r$1 = valueInterface($clone(v, Value), false); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\tx = _r$1;\n\t\t\t\t_r$2 = dst.NumMethod(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t/* */ if (_r$2 === 0) { $s = 9; continue; }\n\t\t\t\t/* */ $s = 10; continue;\n\t\t\t\t/* if (_r$2 === 0) { */ case 9:\n\t\t\t\t\ttarget.$set(x);\n\t\t\t\t\t$s = 11; continue;\n\t\t\t\t/* } else { */ case 10:\n\t\t\t\t\tifaceE2I(dst, x, target);\n\t\t\t\t/* } */ case 11:\n\t\t\t\t$s = -1; return new Value.ptr(dst, target, 148);\n\t\t\t/* } */ case 7:\n\t\tcase 4:\n\t\t$panic(new $String(context + \": value of type \" + v.typ.String() + \" is not assignable to type \" + dst.String()));\n\t\t$s = -1; return new Value.ptr(ptrType$1.nil, 0, 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.assignTo }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.context = context; $f.dst = dst; $f.fl = fl; $f.target = target; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.assignTo = function(context, dst, target) { return this.$val.assignTo(context, dst, target); };\n\tValue.ptr.prototype.Convert = function(t) {\n\t\tvar $ptr, _r, _r$1, _r$2, _r$3, _r$4, op, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; op = $f.op; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tv = this;\n\t\t/* */ if (!((((v.flag & 512) >>> 0) === 0))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!((((v.flag & 512) >>> 0) === 0))) { */ case 1:\n\t\t\t_r = makeMethodValue(\"Convert\", $clone(v, Value)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tv = _r;\n\t\t/* } */ case 2:\n\t\t_r$1 = t.common(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_r$2 = convertOp(_r$1, v.typ); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\top = _r$2;\n\t\t/* */ if (op === $throwNilPointerError) { $s = 6; continue; }\n\t\t/* */ $s = 7; continue;\n\t\t/* if (op === $throwNilPointerError) { */ case 6:\n\t\t\t_r$3 = t.String(); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t$panic(new $String(\"reflect.Value.Convert: value of type \" + v.typ.String() + \" cannot be converted to type \" + _r$3));\n\t\t/* } */ case 7:\n\t\t_r$4 = op($clone(v, Value), t); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$4;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Value.ptr.prototype.Convert }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.op = op; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tValue.prototype.Convert = function(t) { return this.$val.Convert(t); };\n\tconvertOp = function(dst, src) {\n\t\tvar $ptr, _1, _2, _3, _4, _5, _6, _7, _arg, _arg$1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _r$6, _v, _v$1, _v$2, dst, src, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _arg = $f._arg; _arg$1 = $f._arg$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _v = $f._v; _v$1 = $f._v$1; _v$2 = $f._v$2; dst = $f.dst; src = $f.src; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t\t_1 = src.Kind();\n\t\t\t/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }\n\t\t\t/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 3; continue; }\n\t\t\t/* */ if ((_1 === (13)) || (_1 === (14))) { $s = 4; continue; }\n\t\t\t/* */ if ((_1 === (15)) || (_1 === (16))) { $s = 5; continue; }\n\t\t\t/* */ if (_1 === (24)) { $s = 6; continue; }\n\t\t\t/* */ if (_1 === (23)) { $s = 7; continue; }\n\t\t\t/* */ $s = 8; continue;\n\t\t\t/* if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 2:\n\t\t\t\t_2 = dst.Kind();\n\t\t\t\tif ((_2 === (2)) || (_2 === (3)) || (_2 === (4)) || (_2 === (5)) || (_2 === (6)) || (_2 === (7)) || (_2 === (8)) || (_2 === (9)) || (_2 === (10)) || (_2 === (11)) || (_2 === (12))) {\n\t\t\t\t\t$s = -1; return cvtInt;\n\t\t\t\t} else if ((_2 === (13)) || (_2 === (14))) {\n\t\t\t\t\t$s = -1; return cvtIntFloat;\n\t\t\t\t} else if (_2 === (24)) {\n\t\t\t\t\t$s = -1; return cvtIntString;\n\t\t\t\t}\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 3:\n\t\t\t\t_3 = dst.Kind();\n\t\t\t\tif ((_3 === (2)) || (_3 === (3)) || (_3 === (4)) || (_3 === (5)) || (_3 === (6)) || (_3 === (7)) || (_3 === (8)) || (_3 === (9)) || (_3 === (10)) || (_3 === (11)) || (_3 === (12))) {\n\t\t\t\t\t$s = -1; return cvtUint;\n\t\t\t\t} else if ((_3 === (13)) || (_3 === (14))) {\n\t\t\t\t\t$s = -1; return cvtUintFloat;\n\t\t\t\t} else if (_3 === (24)) {\n\t\t\t\t\t$s = -1; return cvtUintString;\n\t\t\t\t}\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if ((_1 === (13)) || (_1 === (14))) { */ case 4:\n\t\t\t\t_4 = dst.Kind();\n\t\t\t\tif ((_4 === (2)) || (_4 === (3)) || (_4 === (4)) || (_4 === (5)) || (_4 === (6))) {\n\t\t\t\t\t$s = -1; return cvtFloatInt;\n\t\t\t\t} else if ((_4 === (7)) || (_4 === (8)) || (_4 === (9)) || (_4 === (10)) || (_4 === (11)) || (_4 === (12))) {\n\t\t\t\t\t$s = -1; return cvtFloatUint;\n\t\t\t\t} else if ((_4 === (13)) || (_4 === (14))) {\n\t\t\t\t\t$s = -1; return cvtFloat;\n\t\t\t\t}\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if ((_1 === (15)) || (_1 === (16))) { */ case 5:\n\t\t\t\t_5 = dst.Kind();\n\t\t\t\tif ((_5 === (15)) || (_5 === (16))) {\n\t\t\t\t\t$s = -1; return cvtComplex;\n\t\t\t\t}\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (24)) { */ case 6:\n\t\t\t\tif (!(dst.Kind() === 23)) { _v = false; $s = 11; continue s; }\n\t\t\t\t_r = dst.Elem().PkgPath(); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t_v = _r === \"\"; case 11:\n\t\t\t\t/* */ if (_v) { $s = 9; continue; }\n\t\t\t\t/* */ $s = 10; continue;\n\t\t\t\t/* if (_v) { */ case 9:\n\t\t\t\t\t\t_r$1 = dst.Elem().Kind(); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t\t\t_6 = _r$1;\n\t\t\t\t\t\tif (_6 === (8)) {\n\t\t\t\t\t\t\t$s = -1; return cvtStringBytes;\n\t\t\t\t\t\t} else if (_6 === (5)) {\n\t\t\t\t\t\t\t$s = -1; return cvtStringRunes;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 13:\n\t\t\t\t/* } */ case 10:\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (23)) { */ case 7:\n\t\t\t\tif (!(dst.Kind() === 24)) { _v$1 = false; $s = 17; continue s; }\n\t\t\t\t_r$2 = src.Elem().PkgPath(); /* */ $s = 18; case 18: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_v$1 = _r$2 === \"\"; case 17:\n\t\t\t\t/* */ if (_v$1) { $s = 15; continue; }\n\t\t\t\t/* */ $s = 16; continue;\n\t\t\t\t/* if (_v$1) { */ case 15:\n\t\t\t\t\t\t_r$3 = src.Elem().Kind(); /* */ $s = 20; case 20: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t\t\t\t_7 = _r$3;\n\t\t\t\t\t\tif (_7 === (8)) {\n\t\t\t\t\t\t\t$s = -1; return cvtBytesString;\n\t\t\t\t\t\t} else if (_7 === (5)) {\n\t\t\t\t\t\t\t$s = -1; return cvtRunesString;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 19:\n\t\t\t\t/* } */ case 16:\n\t\t\t/* } */ case 8:\n\t\tcase 1:\n\t\tif (haveIdenticalUnderlyingType(dst, src)) {\n\t\t\t$s = -1; return cvtDirect;\n\t\t}\n\t\tif (!((dst.Kind() === 22) && dst.Name() === \"\" && (src.Kind() === 22) && src.Name() === \"\")) { _v$2 = false; $s = 23; continue s; }\n\t\t_r$4 = dst.Elem().common(); /* */ $s = 24; case 24: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t_arg = _r$4;\n\t\t_r$5 = src.Elem().common(); /* */ $s = 25; case 25: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }\n\t\t_arg$1 = _r$5;\n\t\t_r$6 = haveIdenticalUnderlyingType(_arg, _arg$1); /* */ $s = 26; case 26: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }\n\t\t_v$2 = _r$6; case 23:\n\t\t/* */ if (_v$2) { $s = 21; continue; }\n\t\t/* */ $s = 22; continue;\n\t\t/* if (_v$2) { */ case 21:\n\t\t\t$s = -1; return cvtDirect;\n\t\t/* } */ case 22:\n\t\tif (implements$1(dst, src)) {\n\t\t\tif (src.Kind() === 20) {\n\t\t\t\t$s = -1; return cvtI2I;\n\t\t\t}\n\t\t\t$s = -1; return cvtT2I;\n\t\t}\n\t\t$s = -1; return $throwNilPointerError;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: convertOp }; } $f.$ptr = $ptr; $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._arg = _arg; $f._arg$1 = _arg$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._v = _v; $f._v$1 = _v$1; $f._v$2 = _v$2; $f.dst = dst; $f.src = src; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmakeFloat = function(f, v, t) {\n\t\tvar $ptr, _1, _r, f, ptr, t, typ, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\ttyp = _r;\n\t\tptr = unsafe_New(typ);\n\t\t_1 = typ.size;\n\t\tif (_1 === (4)) {\n\t\t\tptr.$set($fround(v));\n\t\t} else if (_1 === (8)) {\n\t\t\tptr.$set(v);\n\t\t}\n\t\t$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeFloat }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmakeComplex = function(f, v, t) {\n\t\tvar $ptr, _1, _r, f, ptr, t, typ, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; f = $f.f; ptr = $f.ptr; t = $f.t; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = t.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\ttyp = _r;\n\t\tptr = unsafe_New(typ);\n\t\t_1 = typ.size;\n\t\tif (_1 === (8)) {\n\t\t\tptr.$set(new $Complex64(v.$real, v.$imag));\n\t\t} else if (_1 === (16)) {\n\t\t\tptr.$set(v);\n\t\t}\n\t\t$s = -1; return new Value.ptr(typ, ptr, (((f | 128) >>> 0) | (typ.Kind() >>> 0)) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeComplex }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f.f = f; $f.ptr = ptr; $f.t = t; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmakeString = function(f, v, t) {\n\t\tvar $ptr, _r, _r$1, f, ret, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = New(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r$1 = $clone(_r, Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tret = _r$1;\n\t\t$clone(ret, Value).SetString(v);\n\t\tret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;\n\t\t$s = -1; return ret;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeString }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmakeBytes = function(f, v, t) {\n\t\tvar $ptr, _r, _r$1, f, ret, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = New(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r$1 = $clone(_r, Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tret = _r$1;\n\t\t$r = $clone(ret, Value).SetBytes(v); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;\n\t\t$s = -1; return ret;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeBytes }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tmakeRunes = function(f, v, t) {\n\t\tvar $ptr, _r, _r$1, f, ret, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; f = $f.f; ret = $f.ret; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = New(t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r$1 = $clone(_r, Value).Elem(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\tret = _r$1;\n\t\t$r = $clone(ret, Value).setRunes(v); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tret.flag = (((ret.flag & ~256) >>> 0) | f) >>> 0;\n\t\t$s = -1; return ret;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: makeRunes }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.ret = ret; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtInt = function(v, t) {\n\t\tvar $ptr, _r, t, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeInt((v.flag & 96) >>> 0, (x = $clone(v, Value).Int(), new $Uint64(x.$high, x.$low)), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtInt }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtUint = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeInt((v.flag & 96) >>> 0, $clone(v, Value).Uint(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUint }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtFloatInt = function(v, t) {\n\t\tvar $ptr, _r, t, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeInt((v.flag & 96) >>> 0, (x = new $Int64(0, $clone(v, Value).Float()), new $Uint64(x.$high, x.$low)), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloatInt }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtFloatUint = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeInt((v.flag & 96) >>> 0, new $Uint64(0, $clone(v, Value).Float()), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloatUint }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtIntFloat = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeFloat((v.flag & 96) >>> 0, $flatten64($clone(v, Value).Int()), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtIntFloat }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtUintFloat = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeFloat((v.flag & 96) >>> 0, $flatten64($clone(v, Value).Uint()), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUintFloat }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtFloat = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeFloat((v.flag & 96) >>> 0, $clone(v, Value).Float(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtFloat }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtComplex = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeComplex((v.flag & 96) >>> 0, $clone(v, Value).Complex(), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtComplex }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtIntString = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeString((v.flag & 96) >>> 0, $encodeRune($clone(v, Value).Int().$low), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtIntString }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtUintString = function(v, t) {\n\t\tvar $ptr, _r, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = makeString((v.flag & 96) >>> 0, $encodeRune($clone(v, Value).Uint().$low), t); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtUintString }; } $f.$ptr = $ptr; $f._r = _r; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtBytesString = function(v, t) {\n\t\tvar $ptr, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_arg = (v.flag & 96) >>> 0;\n\t\t_r = $clone(v, Value).Bytes(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_arg$1 = $bytesToString(_r);\n\t\t_arg$2 = t;\n\t\t_r$1 = makeString(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtBytesString }; } $f.$ptr = $ptr; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtStringBytes = function(v, t) {\n\t\tvar $ptr, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_arg = (v.flag & 96) >>> 0;\n\t\t_r = $clone(v, Value).String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_arg$1 = new sliceType$16($stringToBytes(_r));\n\t\t_arg$2 = t;\n\t\t_r$1 = makeBytes(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtStringBytes }; } $f.$ptr = $ptr; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtRunesString = function(v, t) {\n\t\tvar $ptr, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_arg = (v.flag & 96) >>> 0;\n\t\t_r = $clone(v, Value).runes(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_arg$1 = $runesToString(_r);\n\t\t_arg$2 = t;\n\t\t_r$1 = makeString(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtRunesString }; } $f.$ptr = $ptr; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtStringRunes = function(v, t) {\n\t\tvar $ptr, _arg, _arg$1, _arg$2, _r, _r$1, t, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _r = $f._r; _r$1 = $f._r$1; t = $f.t; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_arg = (v.flag & 96) >>> 0;\n\t\t_r = $clone(v, Value).String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_arg$1 = new sliceType$18($stringToRunes(_r));\n\t\t_arg$2 = t;\n\t\t_r$1 = makeRunes(_arg, _arg$1, _arg$2); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$1;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtStringRunes }; } $f.$ptr = $ptr; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._r = _r; $f._r$1 = _r$1; $f.t = t; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtT2I = function(v, typ) {\n\t\tvar $ptr, _r, _r$1, _r$2, _r$3, _r$4, target, typ, v, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; target = $f.target; typ = $f.typ; v = $f.v; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = typ.common(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r$1 = unsafe_New(_r); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\ttarget = _r$1;\n\t\t_r$2 = valueInterface($clone(v, Value), false); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\tx = _r$2;\n\t\t_r$3 = typ.NumMethod(); /* */ $s = 7; case 7: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t/* */ if (_r$3 === 0) { $s = 4; continue; }\n\t\t/* */ $s = 5; continue;\n\t\t/* if (_r$3 === 0) { */ case 4:\n\t\t\ttarget.$set(x);\n\t\t\t$s = 6; continue;\n\t\t/* } else { */ case 5:\n\t\t\tifaceE2I($assertType(typ, ptrType$1), x, target);\n\t\t/* } */ case 6:\n\t\t_r$4 = typ.common(); /* */ $s = 8; case 8: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t$s = -1; return new Value.ptr(_r$4, target, (((((v.flag & 96) >>> 0) | 128) >>> 0) | 20) >>> 0);\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtT2I }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.target = target; $f.typ = typ; $f.v = v; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tcvtI2I = function(v, typ) {\n\t\tvar $ptr, _r, _r$1, _r$2, ret, typ, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; ret = $f.ret; typ = $f.typ; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t/* */ if ($clone(v, Value).IsNil()) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if ($clone(v, Value).IsNil()) { */ case 1:\n\t\t\t_r = Zero(typ); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tret = _r;\n\t\t\tret.flag = (ret.flag | (((v.flag & 96) >>> 0))) >>> 0;\n\t\t\t$s = -1; return ret;\n\t\t/* } */ case 2:\n\t\t_r$1 = $clone(v, Value).Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_r$2 = cvtT2I($clone(_r$1, Value), typ); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t$s = -1; return _r$2;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: cvtI2I }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.ret = ret; $f.typ = typ; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tptrType$6.methods = [{prop: \"methods\", name: \"methods\", pkg: \"reflect\", typ: $funcType([], [sliceType$3], false)}];\n\tptrType$17.methods = [{prop: \"in$\", name: \"in\", pkg: \"reflect\", typ: $funcType([], [sliceType$2], false)}, {prop: \"out\", name: \"out\", pkg: \"reflect\", typ: $funcType([], [sliceType$2], false)}];\n\tname.methods = [{prop: \"name\", name: \"name\", pkg: \"reflect\", typ: $funcType([], [$String], false)}, {prop: \"tag\", name: \"tag\", pkg: \"reflect\", typ: $funcType([], [$String], false)}, {prop: \"pkgPath\", name: \"pkgPath\", pkg: \"reflect\", typ: $funcType([], [$String], false)}, {prop: \"isExported\", name: \"isExported\", pkg: \"reflect\", typ: $funcType([], [$Bool], false)}, {prop: \"data\", name: \"data\", pkg: \"reflect\", typ: $funcType([$Int], [ptrType$5], false)}, {prop: \"nameLen\", name: \"nameLen\", pkg: \"reflect\", typ: $funcType([], [$Int], false)}, {prop: \"tagLen\", name: \"tagLen\", pkg: \"reflect\", typ: $funcType([], [$Int], false)}];\n\tKind.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tptrType$1.methods = [{prop: \"uncommon\", name: \"uncommon\", pkg: \"reflect\", typ: $funcType([], [ptrType$6], false)}, {prop: \"nameOff\", name: \"nameOff\", pkg: \"reflect\", typ: $funcType([nameOff], [name], false)}, {prop: \"typeOff\", name: \"typeOff\", pkg: \"reflect\", typ: $funcType([typeOff], [ptrType$1], false)}, {prop: \"ptrTo\", name: \"ptrTo\", pkg: \"reflect\", typ: $funcType([], [ptrType$1], false)}, {prop: \"pointers\", name: \"pointers\", pkg: \"reflect\", typ: $funcType([], [$Bool], false)}, {prop: \"Comparable\", name: \"Comparable\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Method\", name: \"Method\", pkg: \"\", typ: $funcType([$Int], [Method], false)}, {prop: \"textOff\", name: \"textOff\", pkg: \"reflect\", typ: $funcType([textOff], [$UnsafePointer], false)}, {prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Size\", name: \"Size\", pkg: \"\", typ: $funcType([], [$Uintptr], false)}, {prop: \"Bits\", name: \"Bits\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Align\", name: \"Align\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"FieldAlign\", name: \"FieldAlign\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Kind\", name: \"Kind\", pkg: \"\", typ: $funcType([], [Kind], false)}, {prop: \"common\", name: \"common\", pkg: \"reflect\", typ: $funcType([], [ptrType$1], false)}, {prop: \"exportedMethods\", name: \"exportedMethods\", pkg: \"reflect\", typ: $funcType([], [sliceType$3], false)}, {prop: \"NumMethod\", name: \"NumMethod\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"MethodByName\", name: \"MethodByName\", pkg: \"\", typ: $funcType([$String], [Method, $Bool], false)}, {prop: \"PkgPath\", name: \"PkgPath\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Name\", name: \"Name\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"ChanDir\", name: \"ChanDir\", pkg: \"\", typ: $funcType([], [ChanDir], false)}, {prop: \"IsVariadic\", name: \"IsVariadic\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Elem\", name: \"Elem\", pkg: \"\", typ: $funcType([], [Type], false)}, {prop: \"Field\", name: \"Field\", pkg: \"\", typ: $funcType([$Int], [StructField], false)}, {prop: \"FieldByIndex\", name: \"FieldByIndex\", pkg: \"\", typ: $funcType([sliceType$14], [StructField], false)}, {prop: \"FieldByName\", name: \"FieldByName\", pkg: \"\", typ: $funcType([$String], [StructField, $Bool], false)}, {prop: \"FieldByNameFunc\", name: \"FieldByNameFunc\", pkg: \"\", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: \"In\", name: \"In\", pkg: \"\", typ: $funcType([$Int], [Type], false)}, {prop: \"Key\", name: \"Key\", pkg: \"\", typ: $funcType([], [Type], false)}, {prop: \"Len\", name: \"Len\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"NumField\", name: \"NumField\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"NumIn\", name: \"NumIn\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"NumOut\", name: \"NumOut\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Out\", name: \"Out\", pkg: \"\", typ: $funcType([$Int], [Type], false)}, {prop: \"Implements\", name: \"Implements\", pkg: \"\", typ: $funcType([Type], [$Bool], false)}, {prop: \"AssignableTo\", name: \"AssignableTo\", pkg: \"\", typ: $funcType([Type], [$Bool], false)}, {prop: \"ConvertibleTo\", name: \"ConvertibleTo\", pkg: \"\", typ: $funcType([Type], [$Bool], false)}];\n\tChanDir.methods = [{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tptrType$8.methods = [{prop: \"Method\", name: \"Method\", pkg: \"\", typ: $funcType([$Int], [Method], false)}, {prop: \"NumMethod\", name: \"NumMethod\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"MethodByName\", name: \"MethodByName\", pkg: \"\", typ: $funcType([$String], [Method, $Bool], false)}];\n\tptrType$10.methods = [{prop: \"Field\", name: \"Field\", pkg: \"\", typ: $funcType([$Int], [StructField], false)}, {prop: \"FieldByIndex\", name: \"FieldByIndex\", pkg: \"\", typ: $funcType([sliceType$14], [StructField], false)}, {prop: \"FieldByNameFunc\", name: \"FieldByNameFunc\", pkg: \"\", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: \"FieldByName\", name: \"FieldByName\", pkg: \"\", typ: $funcType([$String], [StructField, $Bool], false)}];\n\tStructTag.methods = [{prop: \"Get\", name: \"Get\", pkg: \"\", typ: $funcType([$String], [$String], false)}, {prop: \"Lookup\", name: \"Lookup\", pkg: \"\", typ: $funcType([$String], [$String, $Bool], false)}];\n\tValue.methods = [{prop: \"object\", name: \"object\", pkg: \"reflect\", typ: $funcType([], [ptrType$3], false)}, {prop: \"call\", name: \"call\", pkg: \"reflect\", typ: $funcType([$String, sliceType$10], [sliceType$10], false)}, {prop: \"Cap\", name: \"Cap\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Elem\", name: \"Elem\", pkg: \"\", typ: $funcType([], [Value], false)}, {prop: \"Field\", name: \"Field\", pkg: \"\", typ: $funcType([$Int], [Value], false)}, {prop: \"Index\", name: \"Index\", pkg: \"\", typ: $funcType([$Int], [Value], false)}, {prop: \"InterfaceData\", name: \"InterfaceData\", pkg: \"\", typ: $funcType([], [arrayType$12], false)}, {prop: \"IsNil\", name: \"IsNil\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Len\", name: \"Len\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Pointer\", name: \"Pointer\", pkg: \"\", typ: $funcType([], [$Uintptr], false)}, {prop: \"Set\", name: \"Set\", pkg: \"\", typ: $funcType([Value], [], false)}, {prop: \"SetBytes\", name: \"SetBytes\", pkg: \"\", typ: $funcType([sliceType$16], [], false)}, {prop: \"SetCap\", name: \"SetCap\", pkg: \"\", typ: $funcType([$Int], [], false)}, {prop: \"SetLen\", name: \"SetLen\", pkg: \"\", typ: $funcType([$Int], [], false)}, {prop: \"Slice\", name: \"Slice\", pkg: \"\", typ: $funcType([$Int, $Int], [Value], false)}, {prop: \"Slice3\", name: \"Slice3\", pkg: \"\", typ: $funcType([$Int, $Int, $Int], [Value], false)}, {prop: \"Close\", name: \"Close\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"pointer\", name: \"pointer\", pkg: \"reflect\", typ: $funcType([], [$UnsafePointer], false)}, {prop: \"Addr\", name: \"Addr\", pkg: \"\", typ: $funcType([], [Value], false)}, {prop: \"Bool\", name: \"Bool\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Bytes\", name: \"Bytes\", pkg: \"\", typ: $funcType([], [sliceType$16], false)}, {prop: \"runes\", name: \"runes\", pkg: \"reflect\", typ: $funcType([], [sliceType$18], false)}, {prop: \"CanAddr\", name: \"CanAddr\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"CanSet\", name: \"CanSet\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Call\", name: \"Call\", pkg: \"\", typ: $funcType([sliceType$10], [sliceType$10], false)}, {prop: \"CallSlice\", name: \"CallSlice\", pkg: \"\", typ: $funcType([sliceType$10], [sliceType$10], false)}, {prop: \"Complex\", name: \"Complex\", pkg: \"\", typ: $funcType([], [$Complex128], false)}, {prop: \"FieldByIndex\", name: \"FieldByIndex\", pkg: \"\", typ: $funcType([sliceType$14], [Value], false)}, {prop: \"FieldByName\", name: \"FieldByName\", pkg: \"\", typ: $funcType([$String], [Value], false)}, {prop: \"FieldByNameFunc\", name: \"FieldByNameFunc\", pkg: \"\", typ: $funcType([funcType$3], [Value], false)}, {prop: \"Float\", name: \"Float\", pkg: \"\", typ: $funcType([], [$Float64], false)}, {prop: \"Int\", name: \"Int\", pkg: \"\", typ: $funcType([], [$Int64], false)}, {prop: \"CanInterface\", name: \"CanInterface\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Interface\", name: \"Interface\", pkg: \"\", typ: $funcType([], [$emptyInterface], false)}, {prop: \"IsValid\", name: \"IsValid\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Kind\", name: \"Kind\", pkg: \"\", typ: $funcType([], [Kind], false)}, {prop: \"MapIndex\", name: \"MapIndex\", pkg: \"\", typ: $funcType([Value], [Value], false)}, {prop: \"MapKeys\", name: \"MapKeys\", pkg: \"\", typ: $funcType([], [sliceType$10], false)}, {prop: \"Method\", name: \"Method\", pkg: \"\", typ: $funcType([$Int], [Value], false)}, {prop: \"NumMethod\", name: \"NumMethod\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"MethodByName\", name: \"MethodByName\", pkg: \"\", typ: $funcType([$String], [Value], false)}, {prop: \"NumField\", name: \"NumField\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"OverflowComplex\", name: \"OverflowComplex\", pkg: \"\", typ: $funcType([$Complex128], [$Bool], false)}, {prop: \"OverflowFloat\", name: \"OverflowFloat\", pkg: \"\", typ: $funcType([$Float64], [$Bool], false)}, {prop: \"OverflowInt\", name: \"OverflowInt\", pkg: \"\", typ: $funcType([$Int64], [$Bool], false)}, {prop: \"OverflowUint\", name: \"OverflowUint\", pkg: \"\", typ: $funcType([$Uint64], [$Bool], false)}, {prop: \"Recv\", name: \"Recv\", pkg: \"\", typ: $funcType([], [Value, $Bool], false)}, {prop: \"recv\", name: \"recv\", pkg: \"reflect\", typ: $funcType([$Bool], [Value, $Bool], false)}, {prop: \"Send\", name: \"Send\", pkg: \"\", typ: $funcType([Value], [], false)}, {prop: \"send\", name: \"send\", pkg: \"reflect\", typ: $funcType([Value, $Bool], [$Bool], false)}, {prop: \"SetBool\", name: \"SetBool\", pkg: \"\", typ: $funcType([$Bool], [], false)}, {prop: \"setRunes\", name: \"setRunes\", pkg: \"reflect\", typ: $funcType([sliceType$18], [], false)}, {prop: \"SetComplex\", name: \"SetComplex\", pkg: \"\", typ: $funcType([$Complex128], [], false)}, {prop: \"SetFloat\", name: \"SetFloat\", pkg: \"\", typ: $funcType([$Float64], [], false)}, {prop: \"SetInt\", name: \"SetInt\", pkg: \"\", typ: $funcType([$Int64], [], false)}, {prop: \"SetMapIndex\", name: \"SetMapIndex\", pkg: \"\", typ: $funcType([Value, Value], [], false)}, {prop: \"SetUint\", name: \"SetUint\", pkg: \"\", typ: $funcType([$Uint64], [], false)}, {prop: \"SetPointer\", name: \"SetPointer\", pkg: \"\", typ: $funcType([$UnsafePointer], [], false)}, {prop: \"SetString\", name: \"SetString\", pkg: \"\", typ: $funcType([$String], [], false)}, {prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"TryRecv\", name: \"TryRecv\", pkg: \"\", typ: $funcType([], [Value, $Bool], false)}, {prop: \"TrySend\", name: \"TrySend\", pkg: \"\", typ: $funcType([Value], [$Bool], false)}, {prop: \"Type\", name: \"Type\", pkg: \"\", typ: $funcType([], [Type], false)}, {prop: \"Uint\", name: \"Uint\", pkg: \"\", typ: $funcType([], [$Uint64], false)}, {prop: \"UnsafeAddr\", name: \"UnsafeAddr\", pkg: \"\", typ: $funcType([], [$Uintptr], false)}, {prop: \"assignTo\", name: \"assignTo\", pkg: \"reflect\", typ: $funcType([$String, ptrType$1, $UnsafePointer], [Value], false)}, {prop: \"Convert\", name: \"Convert\", pkg: \"\", typ: $funcType([Type], [Value], false)}];\n\tflag.methods = [{prop: \"kind\", name: \"kind\", pkg: \"reflect\", typ: $funcType([], [Kind], false)}, {prop: \"mustBe\", name: \"mustBe\", pkg: \"reflect\", typ: $funcType([Kind], [], false)}, {prop: \"mustBeExported\", name: \"mustBeExported\", pkg: \"reflect\", typ: $funcType([], [], false)}, {prop: \"mustBeAssignable\", name: \"mustBeAssignable\", pkg: \"reflect\", typ: $funcType([], [], false)}];\n\tptrType$18.methods = [{prop: \"Error\", name: \"Error\", pkg: \"\", typ: $funcType([], [$String], false)}];\n\tuncommonType.init(\"reflect\", [{prop: \"pkgPath\", name: \"pkgPath\", exported: false, typ: nameOff, tag: \"\"}, {prop: \"mcount\", name: \"mcount\", exported: false, typ: $Uint16, tag: \"\"}, {prop: \"_$2\", name: \"_\", exported: false, typ: $Uint16, tag: \"\"}, {prop: \"moff\", name: \"moff\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"_$4\", name: \"_\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"_methods\", name: \"_methods\", exported: false, typ: sliceType$3, tag: \"\"}]);\n\tfuncType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"func\\\"\"}, {prop: \"inCount\", name: \"inCount\", exported: false, typ: $Uint16, tag: \"\"}, {prop: \"outCount\", name: \"outCount\", exported: false, typ: $Uint16, tag: \"\"}, {prop: \"_in\", name: \"_in\", exported: false, typ: sliceType$2, tag: \"\"}, {prop: \"_out\", name: \"_out\", exported: false, typ: sliceType$2, tag: \"\"}]);\n\tname.init(\"reflect\", [{prop: \"bytes\", name: \"bytes\", exported: false, typ: ptrType$5, tag: \"\"}]);\n\tnameData.init(\"reflect\", [{prop: \"name\", name: \"name\", exported: false, typ: $String, tag: \"\"}, {prop: \"tag\", name: \"tag\", exported: false, typ: $String, tag: \"\"}, {prop: \"pkgPath\", name: \"pkgPath\", exported: false, typ: $String, tag: \"\"}, {prop: \"exported\", name: \"exported\", exported: false, typ: $Bool, tag: \"\"}]);\n\tmapIter.init(\"reflect\", [{prop: \"t\", name: \"t\", exported: false, typ: Type, tag: \"\"}, {prop: \"m\", name: \"m\", exported: false, typ: ptrType$3, tag: \"\"}, {prop: \"keys\", name: \"keys\", exported: false, typ: ptrType$3, tag: \"\"}, {prop: \"i\", name: \"i\", exported: false, typ: $Int, tag: \"\"}]);\n\tType.init([{prop: \"Align\", name: \"Align\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"AssignableTo\", name: \"AssignableTo\", pkg: \"\", typ: $funcType([Type], [$Bool], false)}, {prop: \"Bits\", name: \"Bits\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"ChanDir\", name: \"ChanDir\", pkg: \"\", typ: $funcType([], [ChanDir], false)}, {prop: \"Comparable\", name: \"Comparable\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"ConvertibleTo\", name: \"ConvertibleTo\", pkg: \"\", typ: $funcType([Type], [$Bool], false)}, {prop: \"Elem\", name: \"Elem\", pkg: \"\", typ: $funcType([], [Type], false)}, {prop: \"Field\", name: \"Field\", pkg: \"\", typ: $funcType([$Int], [StructField], false)}, {prop: \"FieldAlign\", name: \"FieldAlign\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"FieldByIndex\", name: \"FieldByIndex\", pkg: \"\", typ: $funcType([sliceType$14], [StructField], false)}, {prop: \"FieldByName\", name: \"FieldByName\", pkg: \"\", typ: $funcType([$String], [StructField, $Bool], false)}, {prop: \"FieldByNameFunc\", name: \"FieldByNameFunc\", pkg: \"\", typ: $funcType([funcType$3], [StructField, $Bool], false)}, {prop: \"Implements\", name: \"Implements\", pkg: \"\", typ: $funcType([Type], [$Bool], false)}, {prop: \"In\", name: \"In\", pkg: \"\", typ: $funcType([$Int], [Type], false)}, {prop: \"IsVariadic\", name: \"IsVariadic\", pkg: \"\", typ: $funcType([], [$Bool], false)}, {prop: \"Key\", name: \"Key\", pkg: \"\", typ: $funcType([], [Type], false)}, {prop: \"Kind\", name: \"Kind\", pkg: \"\", typ: $funcType([], [Kind], false)}, {prop: \"Len\", name: \"Len\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Method\", name: \"Method\", pkg: \"\", typ: $funcType([$Int], [Method], false)}, {prop: \"MethodByName\", name: \"MethodByName\", pkg: \"\", typ: $funcType([$String], [Method, $Bool], false)}, {prop: \"Name\", name: \"Name\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"NumField\", name: \"NumField\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"NumIn\", name: \"NumIn\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"NumMethod\", name: \"NumMethod\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"NumOut\", name: \"NumOut\", pkg: \"\", typ: $funcType([], [$Int], false)}, {prop: \"Out\", name: \"Out\", pkg: \"\", typ: $funcType([$Int], [Type], false)}, {prop: \"PkgPath\", name: \"PkgPath\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"Size\", name: \"Size\", pkg: \"\", typ: $funcType([], [$Uintptr], false)}, {prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}, {prop: \"common\", name: \"common\", pkg: \"reflect\", typ: $funcType([], [ptrType$1], false)}, {prop: \"uncommon\", name: \"uncommon\", pkg: \"reflect\", typ: $funcType([], [ptrType$6], false)}]);\n\trtype.init(\"reflect\", [{prop: \"size\", name: \"size\", exported: false, typ: $Uintptr, tag: \"\"}, {prop: \"ptrdata\", name: \"ptrdata\", exported: false, typ: $Uintptr, tag: \"\"}, {prop: \"hash\", name: \"hash\", exported: false, typ: $Uint32, tag: \"\"}, {prop: \"tflag\", name: \"tflag\", exported: false, typ: tflag, tag: \"\"}, {prop: \"align\", name: \"align\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"fieldAlign\", name: \"fieldAlign\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"kind\", name: \"kind\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"alg\", name: \"alg\", exported: false, typ: ptrType$4, tag: \"\"}, {prop: \"gcdata\", name: \"gcdata\", exported: false, typ: ptrType$5, tag: \"\"}, {prop: \"str\", name: \"str\", exported: false, typ: nameOff, tag: \"\"}, {prop: \"ptrToThis\", name: \"ptrToThis\", exported: false, typ: typeOff, tag: \"\"}]);\n\ttypeAlg.init(\"reflect\", [{prop: \"hash\", name: \"hash\", exported: false, typ: funcType$4, tag: \"\"}, {prop: \"equal\", name: \"equal\", exported: false, typ: funcType$5, tag: \"\"}]);\n\tmethod.init(\"reflect\", [{prop: \"name\", name: \"name\", exported: false, typ: nameOff, tag: \"\"}, {prop: \"mtyp\", name: \"mtyp\", exported: false, typ: typeOff, tag: \"\"}, {prop: \"ifn\", name: \"ifn\", exported: false, typ: textOff, tag: \"\"}, {prop: \"tfn\", name: \"tfn\", exported: false, typ: textOff, tag: \"\"}]);\n\tarrayType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"array\\\"\"}, {prop: \"elem\", name: \"elem\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"slice\", name: \"slice\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"len\", name: \"len\", exported: false, typ: $Uintptr, tag: \"\"}]);\n\tchanType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"chan\\\"\"}, {prop: \"elem\", name: \"elem\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"dir\", name: \"dir\", exported: false, typ: $Uintptr, tag: \"\"}]);\n\timethod.init(\"reflect\", [{prop: \"name\", name: \"name\", exported: false, typ: nameOff, tag: \"\"}, {prop: \"typ\", name: \"typ\", exported: false, typ: typeOff, tag: \"\"}]);\n\tinterfaceType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"interface\\\"\"}, {prop: \"pkgPath\", name: \"pkgPath\", exported: false, typ: name, tag: \"\"}, {prop: \"methods\", name: \"methods\", exported: false, typ: sliceType$7, tag: \"\"}]);\n\tmapType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"map\\\"\"}, {prop: \"key\", name: \"key\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"elem\", name: \"elem\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"bucket\", name: \"bucket\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"hmap\", name: \"hmap\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"keysize\", name: \"keysize\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"indirectkey\", name: \"indirectkey\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"valuesize\", name: \"valuesize\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"indirectvalue\", name: \"indirectvalue\", exported: false, typ: $Uint8, tag: \"\"}, {prop: \"bucketsize\", name: \"bucketsize\", exported: false, typ: $Uint16, tag: \"\"}, {prop: \"reflexivekey\", name: \"reflexivekey\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"needkeyupdate\", name: \"needkeyupdate\", exported: false, typ: $Bool, tag: \"\"}]);\n\tptrType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"ptr\\\"\"}, {prop: \"elem\", name: \"elem\", exported: false, typ: ptrType$1, tag: \"\"}]);\n\tsliceType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"slice\\\"\"}, {prop: \"elem\", name: \"elem\", exported: false, typ: ptrType$1, tag: \"\"}]);\n\tstructField.init(\"reflect\", [{prop: \"name\", name: \"name\", exported: false, typ: name, tag: \"\"}, {prop: \"typ\", name: \"typ\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"offset\", name: \"offset\", exported: false, typ: $Uintptr, tag: \"\"}]);\n\tstructType.init(\"reflect\", [{prop: \"rtype\", name: \"\", exported: false, typ: rtype, tag: \"reflect:\\\"struct\\\"\"}, {prop: \"pkgPath\", name: \"pkgPath\", exported: false, typ: name, tag: \"\"}, {prop: \"fields\", name: \"fields\", exported: false, typ: sliceType$8, tag: \"\"}]);\n\tMethod.init(\"\", [{prop: \"Name\", name: \"Name\", exported: true, typ: $String, tag: \"\"}, {prop: \"PkgPath\", name: \"PkgPath\", exported: true, typ: $String, tag: \"\"}, {prop: \"Type\", name: \"Type\", exported: true, typ: Type, tag: \"\"}, {prop: \"Func\", name: \"Func\", exported: true, typ: Value, tag: \"\"}, {prop: \"Index\", name: \"Index\", exported: true, typ: $Int, tag: \"\"}]);\n\tStructField.init(\"\", [{prop: \"Name\", name: \"Name\", exported: true, typ: $String, tag: \"\"}, {prop: \"PkgPath\", name: \"PkgPath\", exported: true, typ: $String, tag: \"\"}, {prop: \"Type\", name: \"Type\", exported: true, typ: Type, tag: \"\"}, {prop: \"Tag\", name: \"Tag\", exported: true, typ: StructTag, tag: \"\"}, {prop: \"Offset\", name: \"Offset\", exported: true, typ: $Uintptr, tag: \"\"}, {prop: \"Index\", name: \"Index\", exported: true, typ: sliceType$14, tag: \"\"}, {prop: \"Anonymous\", name: \"Anonymous\", exported: true, typ: $Bool, tag: \"\"}]);\n\tfieldScan.init(\"reflect\", [{prop: \"typ\", name: \"typ\", exported: false, typ: ptrType$10, tag: \"\"}, {prop: \"index\", name: \"index\", exported: false, typ: sliceType$14, tag: \"\"}]);\n\tValue.init(\"reflect\", [{prop: \"typ\", name: \"typ\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"ptr\", name: \"ptr\", exported: false, typ: $UnsafePointer, tag: \"\"}, {prop: \"flag\", name: \"\", exported: false, typ: flag, tag: \"\"}]);\n\tValueError.init(\"\", [{prop: \"Method\", name: \"Method\", exported: true, typ: $String, tag: \"\"}, {prop: \"Kind\", name: \"Kind\", exported: true, typ: Kind, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = runtime.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = strconv.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = sync.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tnameOffList = sliceType$1.nil;\n\t\ttypeOffList = sliceType$2.nil;\n\t\tmethodCache = new structType$1.ptr(new sync.RWMutex.ptr(new sync.Mutex.ptr(0, 0), 0, 0, 0, 0), false);\n\t\tinitialized = false;\n\t\tuncommonTypeMap = {};\n\t\tnameMap = {};\n\t\tcallHelper = $assertType($internalize($call, $emptyInterface), funcType$1);\n\t\tselectHelper = $assertType($internalize($select, $emptyInterface), funcType$1);\n\t\tkindNames = new sliceType$6([\"invalid\", \"bool\", \"int\", \"int8\", \"int16\", \"int32\", \"int64\", \"uint\", \"uint8\", \"uint16\", \"uint32\", \"uint64\", \"uintptr\", \"float32\", \"float64\", \"complex64\", \"complex128\", \"array\", \"chan\", \"func\", \"interface\", \"map\", \"ptr\", \"slice\", \"string\", \"struct\", \"unsafe.Pointer\"]);\n\t\tjsObjectPtr = reflectType($jsObjectPtr);\n\t\tuint8Type = $assertType(TypeOf(new $Uint8(0)), ptrType$1);\n\t\t$r = init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\"fmt\"] = (function() {\n\tvar $pkg = {}, $init, errors, io, math, os, reflect, strconv, sync, utf8, fmtFlags, fmt, State, Formatter, Stringer, GoStringer, buffer, pp, scanError, ss, ssave, sliceType, ptrType, ptrType$1, arrayType, arrayType$1, sliceType$1, sliceType$2, ptrType$2, ptrType$5, ptrType$25, funcType, ppFree, byteType, space, ssFree, complexError, boolError, newPrinter, Fprintln, Println, getField, isSpace, notSpace, indexRune;\n\terrors = $packages[\"errors\"];\n\tio = $packages[\"io\"];\n\tmath = $packages[\"math\"];\n\tos = $packages[\"os\"];\n\treflect = $packages[\"reflect\"];\n\tstrconv = $packages[\"strconv\"];\n\tsync = $packages[\"sync\"];\n\tutf8 = $packages[\"unicode/utf8\"];\n\tfmtFlags = $pkg.fmtFlags = $newType(0, $kindStruct, \"fmt.fmtFlags\", true, \"fmt\", false, function(widPresent_, precPresent_, minus_, plus_, sharp_, space_, zero_, plusV_, sharpV_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.widPresent = false;\n\t\t\tthis.precPresent = false;\n\t\t\tthis.minus = false;\n\t\t\tthis.plus = false;\n\t\t\tthis.sharp = false;\n\t\t\tthis.space = false;\n\t\t\tthis.zero = false;\n\t\t\tthis.plusV = false;\n\t\t\tthis.sharpV = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.widPresent = widPresent_;\n\t\tthis.precPresent = precPresent_;\n\t\tthis.minus = minus_;\n\t\tthis.plus = plus_;\n\t\tthis.sharp = sharp_;\n\t\tthis.space = space_;\n\t\tthis.zero = zero_;\n\t\tthis.plusV = plusV_;\n\t\tthis.sharpV = sharpV_;\n\t});\n\tfmt = $pkg.fmt = $newType(0, $kindStruct, \"fmt.fmt\", true, \"fmt\", false, function(buf_, fmtFlags_, wid_, prec_, intbuf_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.buf = ptrType$1.nil;\n\t\t\tthis.fmtFlags = new fmtFlags.ptr(false, false, false, false, false, false, false, false, false);\n\t\t\tthis.wid = 0;\n\t\t\tthis.prec = 0;\n\t\t\tthis.intbuf = arrayType.zero();\n\t\t\treturn;\n\t\t}\n\t\tthis.buf = buf_;\n\t\tthis.fmtFlags = fmtFlags_;\n\t\tthis.wid = wid_;\n\t\tthis.prec = prec_;\n\t\tthis.intbuf = intbuf_;\n\t});\n\tState = $pkg.State = $newType(8, $kindInterface, \"fmt.State\", true, \"fmt\", true, null);\n\tFormatter = $pkg.Formatter = $newType(8, $kindInterface, \"fmt.Formatter\", true, \"fmt\", true, null);\n\tStringer = $pkg.Stringer = $newType(8, $kindInterface, \"fmt.Stringer\", true, \"fmt\", true, null);\n\tGoStringer = $pkg.GoStringer = $newType(8, $kindInterface, \"fmt.GoStringer\", true, \"fmt\", true, null);\n\tbuffer = $pkg.buffer = $newType(12, $kindSlice, \"fmt.buffer\", true, \"fmt\", false, null);\n\tpp = $pkg.pp = $newType(0, $kindStruct, \"fmt.pp\", true, \"fmt\", false, function(buf_, arg_, value_, fmt_, reordered_, goodArgNum_, panicking_, erroring_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.buf = buffer.nil;\n\t\t\tthis.arg = $ifaceNil;\n\t\t\tthis.value = new reflect.Value.ptr(ptrType.nil, 0, 0);\n\t\t\tthis.fmt = new fmt.ptr(ptrType$1.nil, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false), 0, 0, arrayType.zero());\n\t\t\tthis.reordered = false;\n\t\t\tthis.goodArgNum = false;\n\t\t\tthis.panicking = false;\n\t\t\tthis.erroring = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.buf = buf_;\n\t\tthis.arg = arg_;\n\t\tthis.value = value_;\n\t\tthis.fmt = fmt_;\n\t\tthis.reordered = reordered_;\n\t\tthis.goodArgNum = goodArgNum_;\n\t\tthis.panicking = panicking_;\n\t\tthis.erroring = erroring_;\n\t});\n\tscanError = $pkg.scanError = $newType(0, $kindStruct, \"fmt.scanError\", true, \"fmt\", false, function(err_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.err = $ifaceNil;\n\t\t\treturn;\n\t\t}\n\t\tthis.err = err_;\n\t});\n\tss = $pkg.ss = $newType(0, $kindStruct, \"fmt.ss\", true, \"fmt\", false, function(rs_, buf_, count_, atEOF_, ssave_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.rs = $ifaceNil;\n\t\t\tthis.buf = buffer.nil;\n\t\t\tthis.count = 0;\n\t\t\tthis.atEOF = false;\n\t\t\tthis.ssave = new ssave.ptr(false, false, false, 0, 0, 0);\n\t\t\treturn;\n\t\t}\n\t\tthis.rs = rs_;\n\t\tthis.buf = buf_;\n\t\tthis.count = count_;\n\t\tthis.atEOF = atEOF_;\n\t\tthis.ssave = ssave_;\n\t});\n\tssave = $pkg.ssave = $newType(0, $kindStruct, \"fmt.ssave\", true, \"fmt\", false, function(validSave_, nlIsEnd_, nlIsSpace_, argLimit_, limit_, maxWid_) {\n\t\tthis.$val = this;\n\t\tif (arguments.length === 0) {\n\t\t\tthis.validSave = false;\n\t\t\tthis.nlIsEnd = false;\n\t\t\tthis.nlIsSpace = false;\n\t\t\tthis.argLimit = 0;\n\t\t\tthis.limit = 0;\n\t\t\tthis.maxWid = 0;\n\t\t\treturn;\n\t\t}\n\t\tthis.validSave = validSave_;\n\t\tthis.nlIsEnd = nlIsEnd_;\n\t\tthis.nlIsSpace = nlIsSpace_;\n\t\tthis.argLimit = argLimit_;\n\t\tthis.limit = limit_;\n\t\tthis.maxWid = maxWid_;\n\t});\n\tsliceType = $sliceType($emptyInterface);\n\tptrType = $ptrType(reflect.rtype);\n\tptrType$1 = $ptrType(buffer);\n\tarrayType = $arrayType($Uint8, 68);\n\tarrayType$1 = $arrayType($Uint16, 2);\n\tsliceType$1 = $sliceType(arrayType$1);\n\tsliceType$2 = $sliceType($Uint8);\n\tptrType$2 = $ptrType(pp);\n\tptrType$5 = $ptrType(ss);\n\tptrType$25 = $ptrType(fmt);\n\tfuncType = $funcType([$Int32], [$Bool], false);\n\tfmt.ptr.prototype.clearflags = function() {\n\t\tvar $ptr, f;\n\t\tf = this;\n\t\tfmtFlags.copy(f.fmtFlags, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false));\n\t};\n\tfmt.prototype.clearflags = function() { return this.$val.clearflags(); };\n\tfmt.ptr.prototype.init = function(buf) {\n\t\tvar $ptr, buf, f;\n\t\tf = this;\n\t\tf.buf = buf;\n\t\tf.clearflags();\n\t};\n\tfmt.prototype.init = function(buf) { return this.$val.init(buf); };\n\tfmt.ptr.prototype.writePadding = function(n) {\n\t\tvar $ptr, _i, _ref, buf, f, i, n, newLen, oldLen, padByte, padding;\n\t\tf = this;\n\t\tif (n <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tbuf = f.buf.$get();\n\t\toldLen = buf.$length;\n\t\tnewLen = oldLen + n >> 0;\n\t\tif (newLen > buf.$capacity) {\n\t\t\tbuf = $makeSlice(buffer, (($imul(buf.$capacity, 2)) + n >> 0));\n\t\t\t$copySlice(buf, f.buf.$get());\n\t\t}\n\t\tpadByte = 32;\n\t\tif (f.fmtFlags.zero) {\n\t\t\tpadByte = 48;\n\t\t}\n\t\tpadding = $subslice(buf, oldLen, newLen);\n\t\t_ref = padding;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\ti = _i;\n\t\t\t((i < 0 || i >= padding.$length) ? $throwRuntimeError(\"index out of range\") : padding.$array[padding.$offset + i] = padByte);\n\t\t\t_i++;\n\t\t}\n\t\tf.buf.$set($subslice(buf, 0, newLen));\n\t};\n\tfmt.prototype.writePadding = function(n) { return this.$val.writePadding(n); };\n\tfmt.ptr.prototype.pad = function(b) {\n\t\tvar $ptr, b, f, width;\n\t\tf = this;\n\t\tif (!f.fmtFlags.widPresent || (f.wid === 0)) {\n\t\t\tf.buf.Write(b);\n\t\t\treturn;\n\t\t}\n\t\twidth = f.wid - utf8.RuneCount(b) >> 0;\n\t\tif (!f.fmtFlags.minus) {\n\t\t\tf.writePadding(width);\n\t\t\tf.buf.Write(b);\n\t\t} else {\n\t\t\tf.buf.Write(b);\n\t\t\tf.writePadding(width);\n\t\t}\n\t};\n\tfmt.prototype.pad = function(b) { return this.$val.pad(b); };\n\tfmt.ptr.prototype.padString = function(s) {\n\t\tvar $ptr, f, s, width;\n\t\tf = this;\n\t\tif (!f.fmtFlags.widPresent || (f.wid === 0)) {\n\t\t\tf.buf.WriteString(s);\n\t\t\treturn;\n\t\t}\n\t\twidth = f.wid - utf8.RuneCountInString(s) >> 0;\n\t\tif (!f.fmtFlags.minus) {\n\t\t\tf.writePadding(width);\n\t\t\tf.buf.WriteString(s);\n\t\t} else {\n\t\t\tf.buf.WriteString(s);\n\t\t\tf.writePadding(width);\n\t\t}\n\t};\n\tfmt.prototype.padString = function(s) { return this.$val.padString(s); };\n\tfmt.ptr.prototype.fmt_boolean = function(v) {\n\t\tvar $ptr, f, v;\n\t\tf = this;\n\t\tif (v) {\n\t\t\tf.padString(\"true\");\n\t\t} else {\n\t\t\tf.padString(\"false\");\n\t\t}\n\t};\n\tfmt.prototype.fmt_boolean = function(v) { return this.$val.fmt_boolean(v); };\n\tfmt.ptr.prototype.fmt_unicode = function(u) {\n\t\tvar $ptr, buf, f, i, oldZero, prec, u, width;\n\t\tf = this;\n\t\tbuf = $subslice(new sliceType$2(f.intbuf), 0);\n\t\tprec = 4;\n\t\tif (f.fmtFlags.precPresent && f.prec > 4) {\n\t\t\tprec = f.prec;\n\t\t\twidth = (((2 + prec >> 0) + 2 >> 0) + 4 >> 0) + 1 >> 0;\n\t\t\tif (width > buf.$length) {\n\t\t\t\tbuf = $makeSlice(sliceType$2, width);\n\t\t\t}\n\t\t}\n\t\ti = buf.$length;\n\t\tif (f.fmtFlags.sharp && (u.$high < 0 || (u.$high === 0 && u.$low <= 1114111)) && strconv.IsPrint((u.$low >> 0))) {\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 39);\n\t\t\ti = i - (utf8.RuneLen((u.$low >> 0))) >> 0;\n\t\t\tutf8.EncodeRune($subslice(buf, i), (u.$low >> 0));\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 39);\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 32);\n\t\t}\n\t\twhile (true) {\n\t\t\tif (!((u.$high > 0 || (u.$high === 0 && u.$low >= 16)))) { break; }\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = \"0123456789ABCDEFX\".charCodeAt($flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))));\n\t\t\tprec = prec - (1) >> 0;\n\t\t\tu = $shiftRightUint64(u, (4));\n\t\t}\n\t\ti = i - (1) >> 0;\n\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = \"0123456789ABCDEFX\".charCodeAt($flatten64(u)));\n\t\tprec = prec - (1) >> 0;\n\t\twhile (true) {\n\t\t\tif (!(prec > 0)) { break; }\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 48);\n\t\t\tprec = prec - (1) >> 0;\n\t\t}\n\t\ti = i - (1) >> 0;\n\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 43);\n\t\ti = i - (1) >> 0;\n\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 85);\n\t\toldZero = f.fmtFlags.zero;\n\t\tf.fmtFlags.zero = false;\n\t\tf.pad($subslice(buf, i));\n\t\tf.fmtFlags.zero = oldZero;\n\t};\n\tfmt.prototype.fmt_unicode = function(u) { return this.$val.fmt_unicode(u); };\n\tfmt.ptr.prototype.fmt_integer = function(u, base, isSigned, digits) {\n\t\tvar $ptr, _1, _2, base, buf, digits, f, i, isSigned, negative, next, oldZero, oldZero$1, prec, u, width, x, x$1, x$2, x$3, x$4;\n\t\tf = this;\n\t\tnegative = isSigned && (x = new $Int64(u.$high, u.$low), (x.$high < 0 || (x.$high === 0 && x.$low < 0)));\n\t\tif (negative) {\n\t\t\tu = new $Uint64(-u.$high, -u.$low);\n\t\t}\n\t\tbuf = $subslice(new sliceType$2(f.intbuf), 0);\n\t\tif (f.fmtFlags.widPresent || f.fmtFlags.precPresent) {\n\t\t\twidth = (3 + f.wid >> 0) + f.prec >> 0;\n\t\t\tif (width > buf.$length) {\n\t\t\t\tbuf = $makeSlice(sliceType$2, width);\n\t\t\t}\n\t\t}\n\t\tprec = 0;\n\t\tif (f.fmtFlags.precPresent) {\n\t\t\tprec = f.prec;\n\t\t\tif ((prec === 0) && (u.$high === 0 && u.$low === 0)) {\n\t\t\t\toldZero = f.fmtFlags.zero;\n\t\t\t\tf.fmtFlags.zero = false;\n\t\t\t\tf.writePadding(f.wid);\n\t\t\t\tf.fmtFlags.zero = oldZero;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (f.fmtFlags.zero && f.fmtFlags.widPresent) {\n\t\t\tprec = f.wid;\n\t\t\tif (negative || f.fmtFlags.plus || f.fmtFlags.space) {\n\t\t\t\tprec = prec - (1) >> 0;\n\t\t\t}\n\t\t}\n\t\ti = buf.$length;\n\t\t_1 = base;\n\t\tif (_1 === (10)) {\n\t\t\twhile (true) {\n\t\t\t\tif (!((u.$high > 0 || (u.$high === 0 && u.$low >= 10)))) { break; }\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\tnext = $div64(u, new $Uint64(0, 10), false);\n\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = ((x$1 = new $Uint64(0 + u.$high, 48 + u.$low), x$2 = $mul64(next, new $Uint64(0, 10)), new $Uint64(x$1.$high - x$2.$high, x$1.$low - x$2.$low)).$low << 24 >>> 24));\n\t\t\t\tu = next;\n\t\t\t}\n\t\t} else if (_1 === (16)) {\n\t\t\twhile (true) {\n\t\t\t\tif (!((u.$high > 0 || (u.$high === 0 && u.$low >= 16)))) { break; }\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(new $Uint64(u.$high & 0, (u.$low & 15) >>> 0))));\n\t\t\t\tu = $shiftRightUint64(u, (4));\n\t\t\t}\n\t\t} else if (_1 === (8)) {\n\t\t\twhile (true) {\n\t\t\t\tif (!((u.$high > 0 || (u.$high === 0 && u.$low >= 8)))) { break; }\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = ((x$3 = new $Uint64(u.$high & 0, (u.$low & 7) >>> 0), new $Uint64(0 + x$3.$high, 48 + x$3.$low)).$low << 24 >>> 24));\n\t\t\t\tu = $shiftRightUint64(u, (3));\n\t\t\t}\n\t\t} else if (_1 === (2)) {\n\t\t\twhile (true) {\n\t\t\t\tif (!((u.$high > 0 || (u.$high === 0 && u.$low >= 2)))) { break; }\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = ((x$4 = new $Uint64(u.$high & 0, (u.$low & 1) >>> 0), new $Uint64(0 + x$4.$high, 48 + x$4.$low)).$low << 24 >>> 24));\n\t\t\t\tu = $shiftRightUint64(u, (1));\n\t\t\t}\n\t\t} else {\n\t\t\t$panic(new $String(\"fmt: unknown base; can't happen\"));\n\t\t}\n\t\ti = i - (1) >> 0;\n\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = digits.charCodeAt($flatten64(u)));\n\t\twhile (true) {\n\t\t\tif (!(i > 0 && prec > (buf.$length - i >> 0))) { break; }\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 48);\n\t\t}\n\t\tif (f.fmtFlags.sharp) {\n\t\t\t_2 = base;\n\t\t\tif (_2 === (8)) {\n\t\t\t\tif (!((((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i]) === 48))) {\n\t\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 48);\n\t\t\t\t}\n\t\t\t} else if (_2 === (16)) {\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = digits.charCodeAt(16));\n\t\t\t\ti = i - (1) >> 0;\n\t\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 48);\n\t\t\t}\n\t\t}\n\t\tif (negative) {\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 45);\n\t\t} else if (f.fmtFlags.plus) {\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 43);\n\t\t} else if (f.fmtFlags.space) {\n\t\t\ti = i - (1) >> 0;\n\t\t\t((i < 0 || i >= buf.$length) ? $throwRuntimeError(\"index out of range\") : buf.$array[buf.$offset + i] = 32);\n\t\t}\n\t\toldZero$1 = f.fmtFlags.zero;\n\t\tf.fmtFlags.zero = false;\n\t\tf.pad($subslice(buf, i));\n\t\tf.fmtFlags.zero = oldZero$1;\n\t};\n\tfmt.prototype.fmt_integer = function(u, base, isSigned, digits) { return this.$val.fmt_integer(u, base, isSigned, digits); };\n\tfmt.ptr.prototype.truncate = function(s) {\n\t\tvar $ptr, _i, _ref, _rune, f, i, n, s;\n\t\tf = this;\n\t\tif (f.fmtFlags.precPresent) {\n\t\t\tn = f.prec;\n\t\t\t_ref = s;\n\t\t\t_i = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (!(_i < _ref.length)) { break; }\n\t\t\t\t_rune = $decodeRune(_ref, _i);\n\t\t\t\ti = _i;\n\t\t\t\tn = n - (1) >> 0;\n\t\t\t\tif (n < 0) {\n\t\t\t\t\treturn $substring(s, 0, i);\n\t\t\t\t}\n\t\t\t\t_i += _rune[1];\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t};\n\tfmt.prototype.truncate = function(s) { return this.$val.truncate(s); };\n\tfmt.ptr.prototype.fmt_s = function(s) {\n\t\tvar $ptr, f, s;\n\t\tf = this;\n\t\ts = f.truncate(s);\n\t\tf.padString(s);\n\t};\n\tfmt.prototype.fmt_s = function(s) { return this.$val.fmt_s(s); };\n\tfmt.ptr.prototype.fmt_sbx = function(s, b, digits) {\n\t\tvar $ptr, b, buf, c, digits, f, i, length, s, width;\n\t\tf = this;\n\t\tlength = b.$length;\n\t\tif (b === sliceType$2.nil) {\n\t\t\tlength = s.length;\n\t\t}\n\t\tif (f.fmtFlags.precPresent && f.prec < length) {\n\t\t\tlength = f.prec;\n\t\t}\n\t\twidth = $imul(2, length);\n\t\tif (width > 0) {\n\t\t\tif (f.fmtFlags.space) {\n\t\t\t\tif (f.fmtFlags.sharp) {\n\t\t\t\t\twidth = $imul(width, (2));\n\t\t\t\t}\n\t\t\t\twidth = width + ((length - 1 >> 0)) >> 0;\n\t\t\t} else if (f.fmtFlags.sharp) {\n\t\t\t\twidth = width + (2) >> 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (f.fmtFlags.widPresent) {\n\t\t\t\tf.writePadding(f.wid);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (f.fmtFlags.widPresent && f.wid > width && !f.fmtFlags.minus) {\n\t\t\tf.writePadding(f.wid - width >> 0);\n\t\t}\n\t\tbuf = f.buf.$get();\n\t\tif (f.fmtFlags.sharp) {\n\t\t\tbuf = $append(buf, 48, digits.charCodeAt(16));\n\t\t}\n\t\tc = 0;\n\t\ti = 0;\n\t\twhile (true) {\n\t\t\tif (!(i < length)) { break; }\n\t\t\tif (f.fmtFlags.space && i > 0) {\n\t\t\t\tbuf = $append(buf, 32);\n\t\t\t\tif (f.fmtFlags.sharp) {\n\t\t\t\t\tbuf = $append(buf, 48, digits.charCodeAt(16));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(b === sliceType$2.nil)) {\n\t\t\t\tc = ((i < 0 || i >= b.$length) ? $throwRuntimeError(\"index out of range\") : b.$array[b.$offset + i]);\n\t\t\t} else {\n\t\t\t\tc = s.charCodeAt(i);\n\t\t\t}\n\t\t\tbuf = $append(buf, digits.charCodeAt((c >>> 4 << 24 >>> 24)), digits.charCodeAt(((c & 15) >>> 0)));\n\t\t\ti = i + (1) >> 0;\n\t\t}\n\t\tf.buf.$set(buf);\n\t\tif (f.fmtFlags.widPresent && f.wid > width && f.fmtFlags.minus) {\n\t\t\tf.writePadding(f.wid - width >> 0);\n\t\t}\n\t};\n\tfmt.prototype.fmt_sbx = function(s, b, digits) { return this.$val.fmt_sbx(s, b, digits); };\n\tfmt.ptr.prototype.fmt_sx = function(s, digits) {\n\t\tvar $ptr, digits, f, s;\n\t\tf = this;\n\t\tf.fmt_sbx(s, sliceType$2.nil, digits);\n\t};\n\tfmt.prototype.fmt_sx = function(s, digits) { return this.$val.fmt_sx(s, digits); };\n\tfmt.ptr.prototype.fmt_bx = function(b, digits) {\n\t\tvar $ptr, b, digits, f;\n\t\tf = this;\n\t\tf.fmt_sbx(\"\", b, digits);\n\t};\n\tfmt.prototype.fmt_bx = function(b, digits) { return this.$val.fmt_bx(b, digits); };\n\tfmt.ptr.prototype.fmt_q = function(s) {\n\t\tvar $ptr, buf, f, s;\n\t\tf = this;\n\t\ts = f.truncate(s);\n\t\tif (f.fmtFlags.sharp && strconv.CanBackquote(s)) {\n\t\t\tf.padString(\"`\" + s + \"`\");\n\t\t\treturn;\n\t\t}\n\t\tbuf = $subslice(new sliceType$2(f.intbuf), 0, 0);\n\t\tif (f.fmtFlags.plus) {\n\t\t\tf.pad(strconv.AppendQuoteToASCII(buf, s));\n\t\t} else {\n\t\t\tf.pad(strconv.AppendQuote(buf, s));\n\t\t}\n\t};\n\tfmt.prototype.fmt_q = function(s) { return this.$val.fmt_q(s); };\n\tfmt.ptr.prototype.fmt_c = function(c) {\n\t\tvar $ptr, buf, c, f, r, w;\n\t\tf = this;\n\t\tr = (c.$low >> 0);\n\t\tif ((c.$high > 0 || (c.$high === 0 && c.$low > 1114111))) {\n\t\t\tr = 65533;\n\t\t}\n\t\tbuf = $subslice(new sliceType$2(f.intbuf), 0, 0);\n\t\tw = utf8.EncodeRune($subslice(buf, 0, 4), r);\n\t\tf.pad($subslice(buf, 0, w));\n\t};\n\tfmt.prototype.fmt_c = function(c) { return this.$val.fmt_c(c); };\n\tfmt.ptr.prototype.fmt_qc = function(c) {\n\t\tvar $ptr, buf, c, f, r;\n\t\tf = this;\n\t\tr = (c.$low >> 0);\n\t\tif ((c.$high > 0 || (c.$high === 0 && c.$low > 1114111))) {\n\t\t\tr = 65533;\n\t\t}\n\t\tbuf = $subslice(new sliceType$2(f.intbuf), 0, 0);\n\t\tif (f.fmtFlags.plus) {\n\t\t\tf.pad(strconv.AppendQuoteRuneToASCII(buf, r));\n\t\t} else {\n\t\t\tf.pad(strconv.AppendQuoteRune(buf, r));\n\t\t}\n\t};\n\tfmt.prototype.fmt_qc = function(c) { return this.$val.fmt_qc(c); };\n\tfmt.ptr.prototype.fmt_float = function(v, size, verb, prec) {\n\t\tvar $ptr, f, num, oldZero, prec, size, v, verb;\n\t\tf = this;\n\t\tif (f.fmtFlags.precPresent) {\n\t\t\tprec = f.prec;\n\t\t}\n\t\tnum = strconv.AppendFloat($subslice(new sliceType$2(f.intbuf), 0, 1), v, (verb << 24 >>> 24), prec, size);\n\t\tif (((1 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 1]) === 45) || ((1 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 1]) === 43)) {\n\t\t\tnum = $subslice(num, 1);\n\t\t} else {\n\t\t\t(0 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 0] = 43);\n\t\t}\n\t\tif (f.fmtFlags.space && ((0 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 0]) === 43) && !f.fmtFlags.plus) {\n\t\t\t(0 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 0] = 32);\n\t\t}\n\t\tif (((1 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 1]) === 73) || ((1 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 1]) === 78)) {\n\t\t\toldZero = f.fmtFlags.zero;\n\t\t\tf.fmtFlags.zero = false;\n\t\t\tif (((1 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 1]) === 78) && !f.fmtFlags.space && !f.fmtFlags.plus) {\n\t\t\t\tnum = $subslice(num, 1);\n\t\t\t}\n\t\t\tf.pad(num);\n\t\t\tf.fmtFlags.zero = oldZero;\n\t\t\treturn;\n\t\t}\n\t\tif (f.fmtFlags.plus || !(((0 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 0]) === 43))) {\n\t\t\tif (f.fmtFlags.zero && f.fmtFlags.widPresent && f.wid > num.$length) {\n\t\t\t\tf.buf.WriteByte((0 >= num.$length ? $throwRuntimeError(\"index out of range\") : num.$array[num.$offset + 0]));\n\t\t\t\tf.writePadding(f.wid - num.$length >> 0);\n\t\t\t\tf.buf.Write($subslice(num, 1));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tf.pad(num);\n\t\t\treturn;\n\t\t}\n\t\tf.pad($subslice(num, 1));\n\t};\n\tfmt.prototype.fmt_float = function(v, size, verb, prec) { return this.$val.fmt_float(v, size, verb, prec); };\n\t$ptrType(buffer).prototype.Write = function(p) {\n\t\tvar $ptr, b, p;\n\t\tb = this;\n\t\tb.$set($appendSlice(b.$get(), p));\n\t};\n\t$ptrType(buffer).prototype.WriteString = function(s) {\n\t\tvar $ptr, b, s;\n\t\tb = this;\n\t\tb.$set($appendSlice(b.$get(), s));\n\t};\n\t$ptrType(buffer).prototype.WriteByte = function(c) {\n\t\tvar $ptr, b, c;\n\t\tb = this;\n\t\tb.$set($append(b.$get(), c));\n\t};\n\t$ptrType(buffer).prototype.WriteRune = function(r) {\n\t\tvar $ptr, b, bp, n, r, w, x;\n\t\tbp = this;\n\t\tif (r < 128) {\n\t\t\tbp.$set($append(bp.$get(), (r << 24 >>> 24)));\n\t\t\treturn;\n\t\t}\n\t\tb = bp.$get();\n\t\tn = b.$length;\n\t\twhile (true) {\n\t\t\tif (!((n + 4 >> 0) > b.$capacity)) { break; }\n\t\t\tb = $append(b, 0);\n\t\t}\n\t\tw = utf8.EncodeRune((x = $subslice(b, n, (n + 4 >> 0)), $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length)), r);\n\t\tbp.$set($subslice(b, 0, (n + w >> 0)));\n\t};\n\tnewPrinter = function() {\n\t\tvar $ptr, _r, p, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = ppFree.Get(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tp = $assertType(_r, ptrType$2);\n\t\tp.panicking = false;\n\t\tp.erroring = false;\n\t\tp.fmt.init((p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))));\n\t\t$s = -1; return p;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: newPrinter }; } $f.$ptr = $ptr; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.ptr.prototype.free = function() {\n\t\tvar $ptr, p;\n\t\tp = this;\n\t\tp.buf = $subslice(p.buf, 0, 0);\n\t\tp.arg = $ifaceNil;\n\t\tp.value = new reflect.Value.ptr(ptrType.nil, 0, 0);\n\t\tppFree.Put(p);\n\t};\n\tpp.prototype.free = function() { return this.$val.free(); };\n\tpp.ptr.prototype.Width = function() {\n\t\tvar $ptr, _tmp, _tmp$1, ok, p, wid;\n\t\twid = 0;\n\t\tok = false;\n\t\tp = this;\n\t\t_tmp = p.fmt.wid;\n\t\t_tmp$1 = p.fmt.fmtFlags.widPresent;\n\t\twid = _tmp;\n\t\tok = _tmp$1;\n\t\treturn [wid, ok];\n\t};\n\tpp.prototype.Width = function() { return this.$val.Width(); };\n\tpp.ptr.prototype.Precision = function() {\n\t\tvar $ptr, _tmp, _tmp$1, ok, p, prec;\n\t\tprec = 0;\n\t\tok = false;\n\t\tp = this;\n\t\t_tmp = p.fmt.prec;\n\t\t_tmp$1 = p.fmt.fmtFlags.precPresent;\n\t\tprec = _tmp;\n\t\tok = _tmp$1;\n\t\treturn [prec, ok];\n\t};\n\tpp.prototype.Precision = function() { return this.$val.Precision(); };\n\tpp.ptr.prototype.Flag = function(b) {\n\t\tvar $ptr, _1, b, p;\n\t\tp = this;\n\t\t_1 = b;\n\t\tif (_1 === (45)) {\n\t\t\treturn p.fmt.fmtFlags.minus;\n\t\t} else if (_1 === (43)) {\n\t\t\treturn p.fmt.fmtFlags.plus || p.fmt.fmtFlags.plusV;\n\t\t} else if (_1 === (35)) {\n\t\t\treturn p.fmt.fmtFlags.sharp || p.fmt.fmtFlags.sharpV;\n\t\t} else if (_1 === (32)) {\n\t\t\treturn p.fmt.fmtFlags.space;\n\t\t} else if (_1 === (48)) {\n\t\t\treturn p.fmt.fmtFlags.zero;\n\t\t}\n\t\treturn false;\n\t};\n\tpp.prototype.Flag = function(b) { return this.$val.Flag(b); };\n\tpp.ptr.prototype.Write = function(b) {\n\t\tvar $ptr, _tmp, _tmp$1, b, err, p, ret;\n\t\tret = 0;\n\t\terr = $ifaceNil;\n\t\tp = this;\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).Write(b);\n\t\t_tmp = b.$length;\n\t\t_tmp$1 = $ifaceNil;\n\t\tret = _tmp;\n\t\terr = _tmp$1;\n\t\treturn [ret, err];\n\t};\n\tpp.prototype.Write = function(b) { return this.$val.Write(b); };\n\tFprintln = function(w, a) {\n\t\tvar $ptr, _r, _r$1, _tuple, a, err, n, p, w, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; a = $f.a; err = $f.err; n = $f.n; p = $f.p; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_r = newPrinter(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tp = _r;\n\t\t$r = p.doPrintln(a); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t_r$1 = w.Write((x = p.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length))); /* */ $s = 3; case 3: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t_tuple = _r$1;\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\tp.free();\n\t\t$s = -1; return [n, err];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Fprintln }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.n = n; $f.p = p; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.Fprintln = Fprintln;\n\tPrintln = function(a) {\n\t\tvar $ptr, _r, _tuple, a, err, n, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; a = $f.a; err = $f.err; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\t_r = Fprintln(os.Stdout, a); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tn = _tuple[0];\n\t\terr = _tuple[1];\n\t\t$s = -1; return [n, err];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Println }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.a = a; $f.err = err; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.Println = Println;\n\tgetField = function(v, i) {\n\t\tvar $ptr, _r, _r$1, i, v, val, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; i = $f.i; v = $f.v; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = $clone(v, reflect.Value).Field(i); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tval = _r;\n\t\t/* */ if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (($clone(val, reflect.Value).Kind() === 20) && !$clone(val, reflect.Value).IsNil()) { */ case 2:\n\t\t\t_r$1 = $clone(val, reflect.Value).Elem(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\tval = _r$1;\n\t\t/* } */ case 3:\n\t\t$s = -1; return val;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: getField }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.v = v; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.ptr.prototype.unknownType = function(v) {\n\t\tvar $ptr, _r, p, v, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; p = $f.p; v = $f.v; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\tif (!$clone(v, reflect.Value).IsValid()) {\n\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"<nil>\");\n\t\t\t$s = -1; return;\n\t\t}\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(63);\n\t\t_r = $clone(v, reflect.Value).Type().String(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(63);\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.unknownType }; } $f.$ptr = $ptr; $f._r = _r; $f.p = p; $f.v = v; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.unknownType = function(v) { return this.$val.unknownType(v); };\n\tpp.ptr.prototype.badVerb = function(verb) {\n\t\tvar $ptr, _r, _r$1, p, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; p = $f.p; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\tp.erroring = true;\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"%!\");\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);\n\t\t\t/* */ if (!($interfaceIsEqual(p.arg, $ifaceNil))) { $s = 2; continue; }\n\t\t\t/* */ if ($clone(p.value, reflect.Value).IsValid()) { $s = 3; continue; }\n\t\t\t/* */ $s = 4; continue;\n\t\t\t/* if (!($interfaceIsEqual(p.arg, $ifaceNil))) { */ case 2:\n\t\t\t\t_r = reflect.TypeOf(p.arg).String(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);\n\t\t\t\t$r = p.printArg(p.arg, 118); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 5; continue;\n\t\t\t/* } else if ($clone(p.value, reflect.Value).IsValid()) { */ case 3:\n\t\t\t\t_r$1 = $clone(p.value, reflect.Value).Type().String(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$1); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(61);\n\t\t\t\t$r = p.printValue($clone(p.value, reflect.Value), 118, 0); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 5; continue;\n\t\t\t/* } else { */ case 4:\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"<nil>\");\n\t\t\t/* } */ case 5:\n\t\tcase 1:\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);\n\t\tp.erroring = false;\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.badVerb }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.badVerb = function(verb) { return this.$val.badVerb(verb); };\n\tpp.ptr.prototype.fmtBool = function(v, verb) {\n\t\tvar $ptr, _1, p, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t\t_1 = verb;\n\t\t\t/* */ if ((_1 === (116)) || (_1 === (118))) { $s = 2; continue; }\n\t\t\t/* */ $s = 3; continue;\n\t\t\t/* if ((_1 === (116)) || (_1 === (118))) { */ case 2:\n\t\t\t\tp.fmt.fmt_boolean(v);\n\t\t\t\t$s = 4; continue;\n\t\t\t/* } else { */ case 3:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 4:\n\t\tcase 1:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtBool }; } $f.$ptr = $ptr; $f._1 = _1; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtBool = function(v, verb) { return this.$val.fmtBool(v, verb); };\n\tpp.ptr.prototype.fmt0x64 = function(v, leading0x) {\n\t\tvar $ptr, leading0x, p, sharp, v;\n\t\tp = this;\n\t\tsharp = p.fmt.fmtFlags.sharp;\n\t\tp.fmt.fmtFlags.sharp = leading0x;\n\t\tp.fmt.fmt_integer(v, 16, false, \"0123456789abcdefx\");\n\t\tp.fmt.fmtFlags.sharp = sharp;\n\t};\n\tpp.prototype.fmt0x64 = function(v, leading0x) { return this.$val.fmt0x64(v, leading0x); };\n\tpp.ptr.prototype.fmtInteger = function(v, isSigned, verb) {\n\t\tvar $ptr, _1, isSigned, p, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; isSigned = $f.isSigned; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t\t_1 = verb;\n\t\t\t/* */ if (_1 === (118)) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (100)) { $s = 3; continue; }\n\t\t\t/* */ if (_1 === (98)) { $s = 4; continue; }\n\t\t\t/* */ if (_1 === (111)) { $s = 5; continue; }\n\t\t\t/* */ if (_1 === (120)) { $s = 6; continue; }\n\t\t\t/* */ if (_1 === (88)) { $s = 7; continue; }\n\t\t\t/* */ if (_1 === (99)) { $s = 8; continue; }\n\t\t\t/* */ if (_1 === (113)) { $s = 9; continue; }\n\t\t\t/* */ if (_1 === (85)) { $s = 10; continue; }\n\t\t\t/* */ $s = 11; continue;\n\t\t\t/* if (_1 === (118)) { */ case 2:\n\t\t\t\tif (p.fmt.fmtFlags.sharpV && !isSigned) {\n\t\t\t\t\tp.fmt0x64(v, true);\n\t\t\t\t} else {\n\t\t\t\t\tp.fmt.fmt_integer(v, 10, isSigned, \"0123456789abcdefx\");\n\t\t\t\t}\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (100)) { */ case 3:\n\t\t\t\tp.fmt.fmt_integer(v, 10, isSigned, \"0123456789abcdefx\");\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (98)) { */ case 4:\n\t\t\t\tp.fmt.fmt_integer(v, 2, isSigned, \"0123456789abcdefx\");\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (111)) { */ case 5:\n\t\t\t\tp.fmt.fmt_integer(v, 8, isSigned, \"0123456789abcdefx\");\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (120)) { */ case 6:\n\t\t\t\tp.fmt.fmt_integer(v, 16, isSigned, \"0123456789abcdefx\");\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (88)) { */ case 7:\n\t\t\t\tp.fmt.fmt_integer(v, 16, isSigned, \"0123456789ABCDEFX\");\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (99)) { */ case 8:\n\t\t\t\tp.fmt.fmt_c(v);\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (113)) { */ case 9:\n\t\t\t\t/* */ if ((v.$high < 0 || (v.$high === 0 && v.$low <= 1114111))) { $s = 13; continue; }\n\t\t\t\t/* */ $s = 14; continue;\n\t\t\t\t/* if ((v.$high < 0 || (v.$high === 0 && v.$low <= 1114111))) { */ case 13:\n\t\t\t\t\tp.fmt.fmt_qc(v);\n\t\t\t\t\t$s = 15; continue;\n\t\t\t\t/* } else { */ case 14:\n\t\t\t\t\t$r = p.badVerb(verb); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t/* } */ case 15:\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else if (_1 === (85)) { */ case 10:\n\t\t\t\tp.fmt.fmt_unicode(v);\n\t\t\t\t$s = 12; continue;\n\t\t\t/* } else { */ case 11:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 12:\n\t\tcase 1:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtInteger }; } $f.$ptr = $ptr; $f._1 = _1; $f.isSigned = isSigned; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtInteger = function(v, isSigned, verb) { return this.$val.fmtInteger(v, isSigned, verb); };\n\tpp.ptr.prototype.fmtFloat = function(v, size, verb) {\n\t\tvar $ptr, _1, p, size, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; p = $f.p; size = $f.size; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t\t_1 = verb;\n\t\t\t/* */ if (_1 === (118)) { $s = 2; continue; }\n\t\t\t/* */ if ((_1 === (98)) || (_1 === (103)) || (_1 === (71))) { $s = 3; continue; }\n\t\t\t/* */ if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { $s = 4; continue; }\n\t\t\t/* */ if (_1 === (70)) { $s = 5; continue; }\n\t\t\t/* */ $s = 6; continue;\n\t\t\t/* if (_1 === (118)) { */ case 2:\n\t\t\t\tp.fmt.fmt_float(v, size, 103, -1);\n\t\t\t\t$s = 7; continue;\n\t\t\t/* } else if ((_1 === (98)) || (_1 === (103)) || (_1 === (71))) { */ case 3:\n\t\t\t\tp.fmt.fmt_float(v, size, verb, -1);\n\t\t\t\t$s = 7; continue;\n\t\t\t/* } else if ((_1 === (102)) || (_1 === (101)) || (_1 === (69))) { */ case 4:\n\t\t\t\tp.fmt.fmt_float(v, size, verb, 6);\n\t\t\t\t$s = 7; continue;\n\t\t\t/* } else if (_1 === (70)) { */ case 5:\n\t\t\t\tp.fmt.fmt_float(v, size, 102, 6);\n\t\t\t\t$s = 7; continue;\n\t\t\t/* } else { */ case 6:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 7:\n\t\tcase 1:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtFloat }; } $f.$ptr = $ptr; $f._1 = _1; $f.p = p; $f.size = size; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtFloat = function(v, size, verb) { return this.$val.fmtFloat(v, size, verb); };\n\tpp.ptr.prototype.fmtComplex = function(v, size, verb) {\n\t\tvar $ptr, _1, _q, _q$1, oldPlus, p, size, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _q = $f._q; _q$1 = $f._q$1; oldPlus = $f.oldPlus; p = $f.p; size = $f.size; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t\t_1 = verb;\n\t\t\t/* */ if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { $s = 2; continue; }\n\t\t\t/* */ $s = 3; continue;\n\t\t\t/* if ((_1 === (118)) || (_1 === (98)) || (_1 === (103)) || (_1 === (71)) || (_1 === (102)) || (_1 === (70)) || (_1 === (101)) || (_1 === (69))) { */ case 2:\n\t\t\t\toldPlus = p.fmt.fmtFlags.plus;\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);\n\t\t\t\t$r = p.fmtFloat(v.$real, (_q = size / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError(\"integer divide by zero\")), verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\tp.fmt.fmtFlags.plus = true;\n\t\t\t\t$r = p.fmtFloat(v.$imag, (_q$1 = size / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError(\"integer divide by zero\")), verb); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"i)\");\n\t\t\t\tp.fmt.fmtFlags.plus = oldPlus;\n\t\t\t\t$s = 4; continue;\n\t\t\t/* } else { */ case 3:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 4:\n\t\tcase 1:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtComplex }; } $f.$ptr = $ptr; $f._1 = _1; $f._q = _q; $f._q$1 = _q$1; $f.oldPlus = oldPlus; $f.p = p; $f.size = size; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtComplex = function(v, size, verb) { return this.$val.fmtComplex(v, size, verb); };\n\tpp.ptr.prototype.fmtString = function(v, verb) {\n\t\tvar $ptr, _1, p, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t\t_1 = verb;\n\t\t\t/* */ if (_1 === (118)) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (115)) { $s = 3; continue; }\n\t\t\t/* */ if (_1 === (120)) { $s = 4; continue; }\n\t\t\t/* */ if (_1 === (88)) { $s = 5; continue; }\n\t\t\t/* */ if (_1 === (113)) { $s = 6; continue; }\n\t\t\t/* */ $s = 7; continue;\n\t\t\t/* if (_1 === (118)) { */ case 2:\n\t\t\t\tif (p.fmt.fmtFlags.sharpV) {\n\t\t\t\t\tp.fmt.fmt_q(v);\n\t\t\t\t} else {\n\t\t\t\t\tp.fmt.fmt_s(v);\n\t\t\t\t}\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (115)) { */ case 3:\n\t\t\t\tp.fmt.fmt_s(v);\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (120)) { */ case 4:\n\t\t\t\tp.fmt.fmt_sx(v, \"0123456789abcdefx\");\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (88)) { */ case 5:\n\t\t\t\tp.fmt.fmt_sx(v, \"0123456789ABCDEFX\");\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (113)) { */ case 6:\n\t\t\t\tp.fmt.fmt_q(v);\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else { */ case 7:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 8:\n\t\tcase 1:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtString }; } $f.$ptr = $ptr; $f._1 = _1; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtString = function(v, verb) { return this.$val.fmtString(v, verb); };\n\tpp.ptr.prototype.fmtBytes = function(v, verb, typeString) {\n\t\tvar $ptr, _1, _i, _i$1, _r, _ref, _ref$1, c, c$1, i, i$1, p, typeString, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; c = $f.c; c$1 = $f.c$1; i = $f.i; i$1 = $f.i$1; p = $f.p; typeString = $f.typeString; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t\t_1 = verb;\n\t\t\t/* */ if ((_1 === (118)) || (_1 === (100))) { $s = 2; continue; }\n\t\t\t/* */ if (_1 === (115)) { $s = 3; continue; }\n\t\t\t/* */ if (_1 === (120)) { $s = 4; continue; }\n\t\t\t/* */ if (_1 === (88)) { $s = 5; continue; }\n\t\t\t/* */ if (_1 === (113)) { $s = 6; continue; }\n\t\t\t/* */ $s = 7; continue;\n\t\t\t/* if ((_1 === (118)) || (_1 === (100))) { */ case 2:\n\t\t\t\tif (p.fmt.fmtFlags.sharpV) {\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(typeString);\n\t\t\t\t\tif (v === sliceType$2.nil) {\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"(nil)\");\n\t\t\t\t\t\t$s = -1; return;\n\t\t\t\t\t}\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);\n\t\t\t\t\t_ref = v;\n\t\t\t\t\t_i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\t\t\t\ti = _i;\n\t\t\t\t\t\tc = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.fmt0x64(new $Uint64(0, c), true);\n\t\t\t\t\t\t_i++;\n\t\t\t\t\t}\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);\n\t\t\t\t} else {\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(91);\n\t\t\t\t\t_ref$1 = v;\n\t\t\t\t\t_i$1 = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (!(_i$1 < _ref$1.$length)) { break; }\n\t\t\t\t\t\ti$1 = _i$1;\n\t\t\t\t\t\tc$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? $throwRuntimeError(\"index out of range\") : _ref$1.$array[_ref$1.$offset + _i$1]);\n\t\t\t\t\t\tif (i$1 > 0) {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.fmt.fmt_integer(new $Uint64(0, c$1), 10, false, \"0123456789abcdefx\");\n\t\t\t\t\t\t_i$1++;\n\t\t\t\t\t}\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);\n\t\t\t\t}\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (115)) { */ case 3:\n\t\t\t\tp.fmt.fmt_s($bytesToString(v));\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (120)) { */ case 4:\n\t\t\t\tp.fmt.fmt_bx(v, \"0123456789abcdefx\");\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (88)) { */ case 5:\n\t\t\t\tp.fmt.fmt_bx(v, \"0123456789ABCDEFX\");\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else if (_1 === (113)) { */ case 6:\n\t\t\t\tp.fmt.fmt_q($bytesToString(v));\n\t\t\t\t$s = 8; continue;\n\t\t\t/* } else { */ case 7:\n\t\t\t\t_r = reflect.ValueOf(v); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$r = p.printValue($clone(_r, reflect.Value), verb, 0); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 8:\n\t\tcase 1:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtBytes }; } $f.$ptr = $ptr; $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.i$1 = i$1; $f.p = p; $f.typeString = typeString; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtBytes = function(v, verb, typeString) { return this.$val.fmtBytes(v, verb, typeString); };\n\tpp.ptr.prototype.fmtPointer = function(value, verb) {\n\t\tvar $ptr, _1, _2, _r, p, u, value, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _2 = $f._2; _r = $f._r; p = $f.p; u = $f.u; value = $f.value; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\tu = 0;\n\t\t\t_1 = $clone(value, reflect.Value).Kind();\n\t\t\t/* */ if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { $s = 2; continue; }\n\t\t\t/* */ $s = 3; continue;\n\t\t\t/* if ((_1 === (18)) || (_1 === (19)) || (_1 === (21)) || (_1 === (22)) || (_1 === (23)) || (_1 === (26))) { */ case 2:\n\t\t\t\tu = $clone(value, reflect.Value).Pointer();\n\t\t\t\t$s = 4; continue;\n\t\t\t/* } else { */ case 3:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return;\n\t\t\t/* } */ case 4:\n\t\tcase 1:\n\t\t\t_2 = verb;\n\t\t\t/* */ if (_2 === (118)) { $s = 7; continue; }\n\t\t\t/* */ if (_2 === (112)) { $s = 8; continue; }\n\t\t\t/* */ if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { $s = 9; continue; }\n\t\t\t/* */ $s = 10; continue;\n\t\t\t/* if (_2 === (118)) { */ case 7:\n\t\t\t\t/* */ if (p.fmt.fmtFlags.sharpV) { $s = 12; continue; }\n\t\t\t\t/* */ $s = 13; continue;\n\t\t\t\t/* if (p.fmt.fmtFlags.sharpV) { */ case 12:\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(40);\n\t\t\t\t\t_r = $clone(value, reflect.Value).Type().String(); /* */ $s = 15; case 15: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r); /* */ $s = 16; case 16: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\")(\");\n\t\t\t\t\tif (u === 0) {\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"nil\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp.fmt0x64(new $Uint64(0, u.constructor === Number ? u : 1), true);\n\t\t\t\t\t}\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);\n\t\t\t\t\t$s = 14; continue;\n\t\t\t\t/* } else { */ case 13:\n\t\t\t\t\tif (u === 0) {\n\t\t\t\t\t\tp.fmt.padString(\"<nil>\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp.fmt0x64(new $Uint64(0, u.constructor === Number ? u : 1), !p.fmt.fmtFlags.sharp);\n\t\t\t\t\t}\n\t\t\t\t/* } */ case 14:\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else if (_2 === (112)) { */ case 8:\n\t\t\t\tp.fmt0x64(new $Uint64(0, u.constructor === Number ? u : 1), !p.fmt.fmtFlags.sharp);\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else if ((_2 === (98)) || (_2 === (111)) || (_2 === (100)) || (_2 === (120)) || (_2 === (88))) { */ case 9:\n\t\t\t\t$r = p.fmtInteger(new $Uint64(0, u.constructor === Number ? u : 1), false, verb); /* */ $s = 17; case 17: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 11; continue;\n\t\t\t/* } else { */ case 10:\n\t\t\t\t$r = p.badVerb(verb); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 11:\n\t\tcase 6:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.fmtPointer }; } $f.$ptr = $ptr; $f._1 = _1; $f._2 = _2; $f._r = _r; $f.p = p; $f.u = u; $f.value = value; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.fmtPointer = function(value, verb) { return this.$val.fmtPointer(value, verb); };\n\tpp.ptr.prototype.catchPanic = function(arg, verb) {\n\t\tvar $ptr, _r, arg, err, p, v, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; arg = $f.arg; err = $f.err; p = $f.p; v = $f.v; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\terr = $recover();\n\t\t/* */ if (!($interfaceIsEqual(err, $ifaceNil))) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (!($interfaceIsEqual(err, $ifaceNil))) { */ case 1:\n\t\t\t_r = reflect.ValueOf(arg); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tv = _r;\n\t\t\tif (($clone(v, reflect.Value).Kind() === 22) && $clone(v, reflect.Value).IsNil()) {\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"<nil>\");\n\t\t\t\t$s = -1; return;\n\t\t\t}\n\t\t\tif (p.panicking) {\n\t\t\t\t$panic(err);\n\t\t\t}\n\t\t\tp.fmt.clearflags();\n\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"%!\");\n\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteRune(verb);\n\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"(PANIC=\");\n\t\t\tp.panicking = true;\n\t\t\t$r = p.printArg(err, 118); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\tp.panicking = false;\n\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(41);\n\t\t/* } */ case 2:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.catchPanic }; } $f.$ptr = $ptr; $f._r = _r; $f.arg = arg; $f.err = err; $f.p = p; $f.v = v; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.catchPanic = function(arg, verb) { return this.$val.catchPanic(arg, verb); };\n\tpp.ptr.prototype.handleMethods = function(verb) {\n\t\tvar $ptr, _1, _r, _r$1, _r$2, _ref, _tuple, _tuple$1, formatter, handled, ok, ok$1, p, stringer, v, v$1, verb, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; formatter = $f.formatter; handled = $f.handled; ok = $f.ok; ok$1 = $f.ok$1; p = $f.p; stringer = $f.stringer; v = $f.v; v$1 = $f.v$1; verb = $f.verb; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\thandled = false;\n\t\tp = this;\n\t\tif (p.erroring) {\n\t\t\t$s = -1; return handled;\n\t\t}\n\t\t_tuple = $assertType(p.arg, Formatter, true);\n\t\tformatter = _tuple[0];\n\t\tok = _tuple[1];\n\t\t/* */ if (ok) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (ok) { */ case 1:\n\t\t\thandled = true;\n\t\t\t$deferred.push([$methodVal(p, \"catchPanic\"), [p.arg, verb]]);\n\t\t\t$r = formatter.Format(p, verb); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = -1; return handled;\n\t\t/* } */ case 2:\n\t\t/* */ if (p.fmt.fmtFlags.sharpV) { $s = 4; continue; }\n\t\t/* */ $s = 5; continue;\n\t\t/* if (p.fmt.fmtFlags.sharpV) { */ case 4:\n\t\t\t_tuple$1 = $assertType(p.arg, GoStringer, true);\n\t\t\tstringer = _tuple$1[0];\n\t\t\tok$1 = _tuple$1[1];\n\t\t\t/* */ if (ok$1) { $s = 7; continue; }\n\t\t\t/* */ $s = 8; continue;\n\t\t\t/* if (ok$1) { */ case 7:\n\t\t\t\thandled = true;\n\t\t\t\t$deferred.push([$methodVal(p, \"catchPanic\"), [p.arg, verb]]);\n\t\t\t\t_r = stringer.GoString(); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$r = p.fmt.fmt_s(_r); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return handled;\n\t\t\t/* } */ case 8:\n\t\t\t$s = 6; continue;\n\t\t/* } else { */ case 5:\n\t\t\t\t_1 = verb;\n\t\t\t\t/* */ if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { $s = 12; continue; }\n\t\t\t\t/* */ $s = 13; continue;\n\t\t\t\t/* if ((_1 === (118)) || (_1 === (115)) || (_1 === (120)) || (_1 === (88)) || (_1 === (113))) { */ case 12:\n\t\t\t\t\t_ref = p.arg;\n\t\t\t\t\t/* */ if ($assertType(_ref, $error, true)[1]) { $s = 14; continue; }\n\t\t\t\t\t/* */ if ($assertType(_ref, Stringer, true)[1]) { $s = 15; continue; }\n\t\t\t\t\t/* */ $s = 16; continue;\n\t\t\t\t\t/* if ($assertType(_ref, $error, true)[1]) { */ case 14:\n\t\t\t\t\t\tv = _ref;\n\t\t\t\t\t\thandled = true;\n\t\t\t\t\t\t$deferred.push([$methodVal(p, \"catchPanic\"), [p.arg, verb]]);\n\t\t\t\t\t\t_r$1 = v.Error(); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t\t\t$r = p.fmtString(_r$1, verb); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t$s = -1; return handled;\n\t\t\t\t\t/* } else if ($assertType(_ref, Stringer, true)[1]) { */ case 15:\n\t\t\t\t\t\tv$1 = _ref;\n\t\t\t\t\t\thandled = true;\n\t\t\t\t\t\t$deferred.push([$methodVal(p, \"catchPanic\"), [p.arg, verb]]);\n\t\t\t\t\t\t_r$2 = v$1.String(); /* */ $s = 19; case 19: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t\t\t$r = p.fmtString(_r$2, verb); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t$s = -1; return handled;\n\t\t\t\t\t/* } */ case 16:\n\t\t\t\t/* } */ case 13:\n\t\t\tcase 11:\n\t\t/* } */ case 6:\n\t\thandled = false;\n\t\t$s = -1; return handled;\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  handled; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: pp.ptr.prototype.handleMethods }; } $f.$ptr = $ptr; $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.formatter = formatter; $f.handled = handled; $f.ok = ok; $f.ok$1 = ok$1; $f.p = p; $f.stringer = stringer; $f.v = v; $f.v$1 = v$1; $f.verb = verb; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\tpp.prototype.handleMethods = function(verb) { return this.$val.handleMethods(verb); };\n\tpp.ptr.prototype.printArg = function(arg, verb) {\n\t\tvar $ptr, _1, _2, _r, _r$1, _r$2, _r$3, _ref, arg, f, f$1, f$10, f$11, f$12, f$13, f$14, f$15, f$16, f$17, f$18, f$19, f$2, f$3, f$4, f$5, f$6, f$7, f$8, f$9, p, verb, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _2 = $f._2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; arg = $f.arg; f = $f.f; f$1 = $f.f$1; f$10 = $f.f$10; f$11 = $f.f$11; f$12 = $f.f$12; f$13 = $f.f$13; f$14 = $f.f$14; f$15 = $f.f$15; f$16 = $f.f$16; f$17 = $f.f$17; f$18 = $f.f$18; f$19 = $f.f$19; f$2 = $f.f$2; f$3 = $f.f$3; f$4 = $f.f$4; f$5 = $f.f$5; f$6 = $f.f$6; f$7 = $f.f$7; f$8 = $f.f$8; f$9 = $f.f$9; p = $f.p; verb = $f.verb; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\tp.arg = arg;\n\t\tp.value = new reflect.Value.ptr(ptrType.nil, 0, 0);\n\t\t/* */ if ($interfaceIsEqual(arg, $ifaceNil)) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if ($interfaceIsEqual(arg, $ifaceNil)) { */ case 1:\n\t\t\t\t_1 = verb;\n\t\t\t\t/* */ if ((_1 === (84)) || (_1 === (118))) { $s = 4; continue; }\n\t\t\t\t/* */ $s = 5; continue;\n\t\t\t\t/* if ((_1 === (84)) || (_1 === (118))) { */ case 4:\n\t\t\t\t\tp.fmt.padString(\"<nil>\");\n\t\t\t\t\t$s = 6; continue;\n\t\t\t\t/* } else { */ case 5:\n\t\t\t\t\t$r = p.badVerb(verb); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t/* } */ case 6:\n\t\t\tcase 3:\n\t\t\t$s = -1; return;\n\t\t/* } */ case 2:\n\t\t\t_2 = verb;\n\t\t\t/* */ if (_2 === (84)) { $s = 9; continue; }\n\t\t\t/* */ if (_2 === (112)) { $s = 10; continue; }\n\t\t\t/* */ $s = 11; continue;\n\t\t\t/* if (_2 === (84)) { */ case 9:\n\t\t\t\t_r = reflect.TypeOf(arg).String(); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\t\t$r = p.fmt.fmt_s(_r); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return;\n\t\t\t/* } else if (_2 === (112)) { */ case 10:\n\t\t\t\t_r$1 = reflect.ValueOf(arg); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t\t$r = p.fmtPointer($clone(_r$1, reflect.Value), 112); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = -1; return;\n\t\t\t/* } */ case 11:\n\t\tcase 8:\n\t\t_ref = arg;\n\t\t/* */ if ($assertType(_ref, $Bool, true)[1]) { $s = 16; continue; }\n\t\t/* */ if ($assertType(_ref, $Float32, true)[1]) { $s = 17; continue; }\n\t\t/* */ if ($assertType(_ref, $Float64, true)[1]) { $s = 18; continue; }\n\t\t/* */ if ($assertType(_ref, $Complex64, true)[1]) { $s = 19; continue; }\n\t\t/* */ if ($assertType(_ref, $Complex128, true)[1]) { $s = 20; continue; }\n\t\t/* */ if ($assertType(_ref, $Int, true)[1]) { $s = 21; continue; }\n\t\t/* */ if ($assertType(_ref, $Int8, true)[1]) { $s = 22; continue; }\n\t\t/* */ if ($assertType(_ref, $Int16, true)[1]) { $s = 23; continue; }\n\t\t/* */ if ($assertType(_ref, $Int32, true)[1]) { $s = 24; continue; }\n\t\t/* */ if ($assertType(_ref, $Int64, true)[1]) { $s = 25; continue; }\n\t\t/* */ if ($assertType(_ref, $Uint, true)[1]) { $s = 26; continue; }\n\t\t/* */ if ($assertType(_ref, $Uint8, true)[1]) { $s = 27; continue; }\n\t\t/* */ if ($assertType(_ref, $Uint16, true)[1]) { $s = 28; continue; }\n\t\t/* */ if ($assertType(_ref, $Uint32, true)[1]) { $s = 29; continue; }\n\t\t/* */ if ($assertType(_ref, $Uint64, true)[1]) { $s = 30; continue; }\n\t\t/* */ if ($assertType(_ref, $Uintptr, true)[1]) { $s = 31; continue; }\n\t\t/* */ if ($assertType(_ref, $String, true)[1]) { $s = 32; continue; }\n\t\t/* */ if ($assertType(_ref, sliceType$2, true)[1]) { $s = 33; continue; }\n\t\t/* */ if ($assertType(_ref, reflect.Value, true)[1]) { $s = 34; continue; }\n\t\t/* */ $s = 35; continue;\n\t\t/* if ($assertType(_ref, $Bool, true)[1]) { */ case 16:\n\t\t\tf = _ref.$val;\n\t\t\t$r = p.fmtBool(f, verb); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Float32, true)[1]) { */ case 17:\n\t\t\tf$1 = _ref.$val;\n\t\t\t$r = p.fmtFloat(f$1, 32, verb); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Float64, true)[1]) { */ case 18:\n\t\t\tf$2 = _ref.$val;\n\t\t\t$r = p.fmtFloat(f$2, 64, verb); /* */ $s = 39; case 39: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Complex64, true)[1]) { */ case 19:\n\t\t\tf$3 = _ref.$val;\n\t\t\t$r = p.fmtComplex(new $Complex128(f$3.$real, f$3.$imag), 64, verb); /* */ $s = 40; case 40: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Complex128, true)[1]) { */ case 20:\n\t\t\tf$4 = _ref.$val;\n\t\t\t$r = p.fmtComplex(f$4, 128, verb); /* */ $s = 41; case 41: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Int, true)[1]) { */ case 21:\n\t\t\tf$5 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$5), true, verb); /* */ $s = 42; case 42: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Int8, true)[1]) { */ case 22:\n\t\t\tf$6 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$6), true, verb); /* */ $s = 43; case 43: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Int16, true)[1]) { */ case 23:\n\t\t\tf$7 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$7), true, verb); /* */ $s = 44; case 44: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Int32, true)[1]) { */ case 24:\n\t\t\tf$8 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$8), true, verb); /* */ $s = 45; case 45: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Int64, true)[1]) { */ case 25:\n\t\t\tf$9 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(f$9.$high, f$9.$low), true, verb); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Uint, true)[1]) { */ case 26:\n\t\t\tf$10 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$10), false, verb); /* */ $s = 47; case 47: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Uint8, true)[1]) { */ case 27:\n\t\t\tf$11 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$11), false, verb); /* */ $s = 48; case 48: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Uint16, true)[1]) { */ case 28:\n\t\t\tf$12 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$12), false, verb); /* */ $s = 49; case 49: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Uint32, true)[1]) { */ case 29:\n\t\t\tf$13 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$13), false, verb); /* */ $s = 50; case 50: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Uint64, true)[1]) { */ case 30:\n\t\t\tf$14 = _ref.$val;\n\t\t\t$r = p.fmtInteger(f$14, false, verb); /* */ $s = 51; case 51: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $Uintptr, true)[1]) { */ case 31:\n\t\t\tf$15 = _ref.$val;\n\t\t\t$r = p.fmtInteger(new $Uint64(0, f$15.constructor === Number ? f$15 : 1), false, verb); /* */ $s = 52; case 52: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, $String, true)[1]) { */ case 32:\n\t\t\tf$16 = _ref.$val;\n\t\t\t$r = p.fmtString(f$16, verb); /* */ $s = 53; case 53: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, sliceType$2, true)[1]) { */ case 33:\n\t\t\tf$17 = _ref.$val;\n\t\t\t$r = p.fmtBytes(f$17, verb, \"[]byte\"); /* */ $s = 54; case 54: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else if ($assertType(_ref, reflect.Value, true)[1]) { */ case 34:\n\t\t\tf$18 = _ref.$val;\n\t\t\t$r = p.printValue($clone(f$18, reflect.Value), verb, 0); /* */ $s = 55; case 55: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t$s = 36; continue;\n\t\t/* } else { */ case 35:\n\t\t\tf$19 = _ref;\n\t\t\t_r$2 = p.handleMethods(verb); /* */ $s = 58; case 58: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t/* */ if (!_r$2) { $s = 56; continue; }\n\t\t\t/* */ $s = 57; continue;\n\t\t\t/* if (!_r$2) { */ case 56:\n\t\t\t\t_r$3 = reflect.ValueOf(f$19); /* */ $s = 59; case 59: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t\t$r = p.printValue($clone(_r$3, reflect.Value), verb, 0); /* */ $s = 60; case 60: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 57:\n\t\t/* } */ case 36:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.printArg }; } $f.$ptr = $ptr; $f._1 = _1; $f._2 = _2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f.arg = arg; $f.f = f; $f.f$1 = f$1; $f.f$10 = f$10; $f.f$11 = f$11; $f.f$12 = f$12; $f.f$13 = f$13; $f.f$14 = f$14; $f.f$15 = f$15; $f.f$16 = f$16; $f.f$17 = f$17; $f.f$18 = f$18; $f.f$19 = f$19; $f.f$2 = f$2; $f.f$3 = f$3; $f.f$4 = f$4; $f.f$5 = f$5; $f.f$6 = f$6; $f.f$7 = f$7; $f.f$8 = f$8; $f.f$9 = f$9; $f.p = p; $f.verb = verb; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.printArg = function(arg, verb) { return this.$val.printArg(arg, verb); };\n\tpp.ptr.prototype.printValue = function(value, verb, depth) {\n\t\tvar $ptr, _1, _2, _3, _4, _arg, _arg$1, _arg$2, _i, _i$1, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$2, _r$20, _r$21, _r$22, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, a, bytes, depth, f, i, i$1, i$2, i$3, i$4, key, keys, name, p, t, value, value$1, verb, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _arg = $f._arg; _arg$1 = $f._arg$1; _arg$2 = $f._arg$2; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$2 = $f._r$2; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; a = $f.a; bytes = $f.bytes; depth = $f.depth; f = $f.f; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; key = $f.key; keys = $f.keys; name = $f.name; p = $f.p; t = $f.t; value = $f.value; value$1 = $f.value$1; verb = $f.verb; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t/* */ if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (depth > 0 && $clone(value, reflect.Value).IsValid() && $clone(value, reflect.Value).CanInterface()) { */ case 1:\n\t\t\t_r = $clone(value, reflect.Value).Interface(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tp.arg = _r;\n\t\t\t_r$1 = p.handleMethods(verb); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t/* */ if (_r$1) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if (_r$1) { */ case 4:\n\t\t\t\t$s = -1; return;\n\t\t\t/* } */ case 5:\n\t\t/* } */ case 2:\n\t\tp.arg = $ifaceNil;\n\t\tp.value = value;\n\t\t\tf = value;\n\t\t\t_1 = $clone(value, reflect.Value).Kind();\n\t\t\t/* */ if (_1 === (0)) { $s = 8; continue; }\n\t\t\t/* */ if (_1 === (1)) { $s = 9; continue; }\n\t\t\t/* */ if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { $s = 10; continue; }\n\t\t\t/* */ if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { $s = 11; continue; }\n\t\t\t/* */ if (_1 === (13)) { $s = 12; continue; }\n\t\t\t/* */ if (_1 === (14)) { $s = 13; continue; }\n\t\t\t/* */ if (_1 === (15)) { $s = 14; continue; }\n\t\t\t/* */ if (_1 === (16)) { $s = 15; continue; }\n\t\t\t/* */ if (_1 === (24)) { $s = 16; continue; }\n\t\t\t/* */ if (_1 === (21)) { $s = 17; continue; }\n\t\t\t/* */ if (_1 === (25)) { $s = 18; continue; }\n\t\t\t/* */ if (_1 === (20)) { $s = 19; continue; }\n\t\t\t/* */ if ((_1 === (17)) || (_1 === (23))) { $s = 20; continue; }\n\t\t\t/* */ if (_1 === (22)) { $s = 21; continue; }\n\t\t\t/* */ if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { $s = 22; continue; }\n\t\t\t/* */ $s = 23; continue;\n\t\t\t/* if (_1 === (0)) { */ case 8:\n\t\t\t\t/* */ if (depth === 0) { $s = 25; continue; }\n\t\t\t\t/* */ $s = 26; continue;\n\t\t\t\t/* if (depth === 0) { */ case 25:\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"<invalid reflect.Value>\");\n\t\t\t\t\t$s = 27; continue;\n\t\t\t\t/* } else { */ case 26:\n\t\t\t\t\t\t_2 = verb;\n\t\t\t\t\t\t/* */ if (_2 === (118)) { $s = 29; continue; }\n\t\t\t\t\t\t/* */ $s = 30; continue;\n\t\t\t\t\t\t/* if (_2 === (118)) { */ case 29:\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"<nil>\");\n\t\t\t\t\t\t\t$s = 31; continue;\n\t\t\t\t\t\t/* } else { */ case 30:\n\t\t\t\t\t\t\t$r = p.badVerb(verb); /* */ $s = 32; case 32: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t/* } */ case 31:\n\t\t\t\t\tcase 28:\n\t\t\t\t/* } */ case 27:\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (1)) { */ case 9:\n\t\t\t\t$r = p.fmtBool($clone(f, reflect.Value).Bool(), verb); /* */ $s = 33; case 33: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if ((_1 === (2)) || (_1 === (3)) || (_1 === (4)) || (_1 === (5)) || (_1 === (6))) { */ case 10:\n\t\t\t\t$r = p.fmtInteger((x = $clone(f, reflect.Value).Int(), new $Uint64(x.$high, x.$low)), true, verb); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if ((_1 === (7)) || (_1 === (8)) || (_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12))) { */ case 11:\n\t\t\t\t$r = p.fmtInteger($clone(f, reflect.Value).Uint(), false, verb); /* */ $s = 35; case 35: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (13)) { */ case 12:\n\t\t\t\t$r = p.fmtFloat($clone(f, reflect.Value).Float(), 32, verb); /* */ $s = 36; case 36: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (14)) { */ case 13:\n\t\t\t\t$r = p.fmtFloat($clone(f, reflect.Value).Float(), 64, verb); /* */ $s = 37; case 37: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (15)) { */ case 14:\n\t\t\t\t$r = p.fmtComplex($clone(f, reflect.Value).Complex(), 64, verb); /* */ $s = 38; case 38: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (16)) { */ case 15:\n\t\t\t\t$r = p.fmtComplex($clone(f, reflect.Value).Complex(), 128, verb); /* */ $s = 39; case 39: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (24)) { */ case 16:\n\t\t\t\t_r$2 = $clone(f, reflect.Value).String(); /* */ $s = 40; case 40: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t$r = p.fmtString(_r$2, verb); /* */ $s = 41; case 41: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (21)) { */ case 17:\n\t\t\t\t/* */ if (p.fmt.fmtFlags.sharpV) { $s = 42; continue; }\n\t\t\t\t/* */ $s = 43; continue;\n\t\t\t\t/* if (p.fmt.fmtFlags.sharpV) { */ case 42:\n\t\t\t\t\t_r$3 = $clone(f, reflect.Value).Type().String(); /* */ $s = 45; case 45: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }\n\t\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$3); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\tif ($clone(f, reflect.Value).IsNil()) {\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"(nil)\");\n\t\t\t\t\t\t$s = -1; return;\n\t\t\t\t\t}\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);\n\t\t\t\t\t$s = 44; continue;\n\t\t\t\t/* } else { */ case 43:\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"map[\");\n\t\t\t\t/* } */ case 44:\n\t\t\t\t_r$4 = $clone(f, reflect.Value).MapKeys(); /* */ $s = 47; case 47: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }\n\t\t\t\tkeys = _r$4;\n\t\t\t\t_ref = keys;\n\t\t\t\t_i = 0;\n\t\t\t\t/* while (true) { */ case 48:\n\t\t\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 49; continue; }\n\t\t\t\t\ti = _i;\n\t\t\t\t\tkey = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tif (p.fmt.fmtFlags.sharpV) {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\", \");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t$r = p.printValue($clone(key, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 50; case 50: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(58);\n\t\t\t\t\t_r$5 = $clone(f, reflect.Value).MapIndex($clone(key, reflect.Value)); /* */ $s = 51; case 51: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }\n\t\t\t\t\t$r = p.printValue($clone(_r$5, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 52; case 52: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t_i++;\n\t\t\t\t/* } */ $s = 48; continue; case 49:\n\t\t\t\tif (p.fmt.fmtFlags.sharpV) {\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);\n\t\t\t\t} else {\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);\n\t\t\t\t}\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (25)) { */ case 18:\n\t\t\t\t/* */ if (p.fmt.fmtFlags.sharpV) { $s = 53; continue; }\n\t\t\t\t/* */ $s = 54; continue;\n\t\t\t\t/* if (p.fmt.fmtFlags.sharpV) { */ case 53:\n\t\t\t\t\t_r$6 = $clone(f, reflect.Value).Type().String(); /* */ $s = 55; case 55: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }\n\t\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$6); /* */ $s = 56; case 56: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t/* } */ case 54:\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);\n\t\t\t\ti$1 = 0;\n\t\t\t\t/* while (true) { */ case 57:\n\t\t\t\t\t/* if (!(i$1 < $clone(f, reflect.Value).NumField())) { break; } */ if(!(i$1 < $clone(f, reflect.Value).NumField())) { $s = 58; continue; }\n\t\t\t\t\tif (i$1 > 0) {\n\t\t\t\t\t\tif (p.fmt.fmtFlags.sharpV) {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\", \");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* */ if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { $s = 59; continue; }\n\t\t\t\t\t/* */ $s = 60; continue;\n\t\t\t\t\t/* if (p.fmt.fmtFlags.plusV || p.fmt.fmtFlags.sharpV) { */ case 59:\n\t\t\t\t\t\t_r$7 = $clone(f, reflect.Value).Type().Field(i$1); /* */ $s = 61; case 61: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }\n\t\t\t\t\t\tname = _r$7.Name;\n\t\t\t\t\t\tif (!(name === \"\")) {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(name);\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(58);\n\t\t\t\t\t\t}\n\t\t\t\t\t/* } */ case 60:\n\t\t\t\t\t_r$8 = getField($clone(f, reflect.Value), i$1); /* */ $s = 62; case 62: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }\n\t\t\t\t\t$r = p.printValue($clone(_r$8, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 63; case 63: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\ti$1 = i$1 + (1) >> 0;\n\t\t\t\t/* } */ $s = 57; continue; case 58:\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (20)) { */ case 19:\n\t\t\t\t_r$9 = $clone(f, reflect.Value).Elem(); /* */ $s = 64; case 64: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }\n\t\t\t\tvalue$1 = _r$9;\n\t\t\t\t/* */ if (!$clone(value$1, reflect.Value).IsValid()) { $s = 65; continue; }\n\t\t\t\t/* */ $s = 66; continue;\n\t\t\t\t/* if (!$clone(value$1, reflect.Value).IsValid()) { */ case 65:\n\t\t\t\t\t/* */ if (p.fmt.fmtFlags.sharpV) { $s = 68; continue; }\n\t\t\t\t\t/* */ $s = 69; continue;\n\t\t\t\t\t/* if (p.fmt.fmtFlags.sharpV) { */ case 68:\n\t\t\t\t\t\t_r$10 = $clone(f, reflect.Value).Type().String(); /* */ $s = 71; case 71: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }\n\t\t\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$10); /* */ $s = 72; case 72: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"(nil)\");\n\t\t\t\t\t\t$s = 70; continue;\n\t\t\t\t\t/* } else { */ case 69:\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"<nil>\");\n\t\t\t\t\t/* } */ case 70:\n\t\t\t\t\t$s = 67; continue;\n\t\t\t\t/* } else { */ case 66:\n\t\t\t\t\t$r = p.printValue($clone(value$1, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 73; case 73: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t/* } */ case 67:\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if ((_1 === (17)) || (_1 === (23))) { */ case 20:\n\t\t\t\t\t_3 = verb;\n\t\t\t\t\t/* */ if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { $s = 75; continue; }\n\t\t\t\t\t/* */ $s = 76; continue;\n\t\t\t\t\t/* if ((_3 === (115)) || (_3 === (113)) || (_3 === (120)) || (_3 === (88))) { */ case 75:\n\t\t\t\t\t\tt = $clone(f, reflect.Value).Type();\n\t\t\t\t\t\t_r$11 = t.Elem(); /* */ $s = 79; case 79: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }\n\t\t\t\t\t\t_r$12 = _r$11.Kind(); /* */ $s = 80; case 80: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }\n\t\t\t\t\t\t/* */ if (_r$12 === 8) { $s = 77; continue; }\n\t\t\t\t\t\t/* */ $s = 78; continue;\n\t\t\t\t\t\t/* if (_r$12 === 8) { */ case 77:\n\t\t\t\t\t\t\tbytes = sliceType$2.nil;\n\t\t\t\t\t\t\t/* */ if ($clone(f, reflect.Value).Kind() === 23) { $s = 81; continue; }\n\t\t\t\t\t\t\t/* */ if ($clone(f, reflect.Value).CanAddr()) { $s = 82; continue; }\n\t\t\t\t\t\t\t/* */ $s = 83; continue;\n\t\t\t\t\t\t\t/* if ($clone(f, reflect.Value).Kind() === 23) { */ case 81:\n\t\t\t\t\t\t\t\t_r$13 = $clone(f, reflect.Value).Bytes(); /* */ $s = 85; case 85: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t\tbytes = _r$13;\n\t\t\t\t\t\t\t\t$s = 84; continue;\n\t\t\t\t\t\t\t/* } else if ($clone(f, reflect.Value).CanAddr()) { */ case 82:\n\t\t\t\t\t\t\t\t_r$14 = $clone(f, reflect.Value).Slice(0, $clone(f, reflect.Value).Len()); /* */ $s = 86; case 86: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t\t_r$15 = $clone(_r$14, reflect.Value).Bytes(); /* */ $s = 87; case 87: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t\tbytes = _r$15;\n\t\t\t\t\t\t\t\t$s = 84; continue;\n\t\t\t\t\t\t\t/* } else { */ case 83:\n\t\t\t\t\t\t\t\tbytes = $makeSlice(sliceType$2, $clone(f, reflect.Value).Len());\n\t\t\t\t\t\t\t\t_ref$1 = bytes;\n\t\t\t\t\t\t\t\t_i$1 = 0;\n\t\t\t\t\t\t\t\t/* while (true) { */ case 88:\n\t\t\t\t\t\t\t\t\t/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 89; continue; }\n\t\t\t\t\t\t\t\t\ti$2 = _i$1;\n\t\t\t\t\t\t\t\t\t_r$16 = $clone(f, reflect.Value).Index(i$2); /* */ $s = 90; case 90: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t\t\t_r$17 = $clone(_r$16, reflect.Value).Uint(); /* */ $s = 91; case 91: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t\t\t((i$2 < 0 || i$2 >= bytes.$length) ? $throwRuntimeError(\"index out of range\") : bytes.$array[bytes.$offset + i$2] = (_r$17.$low << 24 >>> 24));\n\t\t\t\t\t\t\t\t\t_i$1++;\n\t\t\t\t\t\t\t\t/* } */ $s = 88; continue; case 89:\n\t\t\t\t\t\t\t/* } */ case 84:\n\t\t\t\t\t\t\t_arg = bytes;\n\t\t\t\t\t\t\t_arg$1 = verb;\n\t\t\t\t\t\t\t_r$18 = t.String(); /* */ $s = 92; case 92: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t_arg$2 = _r$18;\n\t\t\t\t\t\t\t$r = p.fmtBytes(_arg, _arg$1, _arg$2); /* */ $s = 93; case 93: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t$s = -1; return;\n\t\t\t\t\t\t/* } */ case 78:\n\t\t\t\t\t/* } */ case 76:\n\t\t\t\tcase 74:\n\t\t\t\t/* */ if (p.fmt.fmtFlags.sharpV) { $s = 94; continue; }\n\t\t\t\t/* */ $s = 95; continue;\n\t\t\t\t/* if (p.fmt.fmtFlags.sharpV) { */ case 94:\n\t\t\t\t\t_r$19 = $clone(f, reflect.Value).Type().String(); /* */ $s = 97; case 97: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }\n\t\t\t\t\t$r = (p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(_r$19); /* */ $s = 98; case 98: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t/* */ if (($clone(f, reflect.Value).Kind() === 23) && $clone(f, reflect.Value).IsNil()) { $s = 99; continue; }\n\t\t\t\t\t/* */ $s = 100; continue;\n\t\t\t\t\t/* if (($clone(f, reflect.Value).Kind() === 23) && $clone(f, reflect.Value).IsNil()) { */ case 99:\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\"(nil)\");\n\t\t\t\t\t\t$s = -1; return;\n\t\t\t\t\t/* } else { */ case 100:\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(123);\n\t\t\t\t\t\ti$3 = 0;\n\t\t\t\t\t\t/* while (true) { */ case 102:\n\t\t\t\t\t\t\t/* if (!(i$3 < $clone(f, reflect.Value).Len())) { break; } */ if(!(i$3 < $clone(f, reflect.Value).Len())) { $s = 103; continue; }\n\t\t\t\t\t\t\tif (i$3 > 0) {\n\t\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteString(\", \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_r$20 = $clone(f, reflect.Value).Index(i$3); /* */ $s = 104; case 104: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t$r = p.printValue($clone(_r$20, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 105; case 105: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\ti$3 = i$3 + (1) >> 0;\n\t\t\t\t\t\t/* } */ $s = 102; continue; case 103:\n\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(125);\n\t\t\t\t\t/* } */ case 101:\n\t\t\t\t\t$s = 96; continue;\n\t\t\t\t/* } else { */ case 95:\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(91);\n\t\t\t\t\ti$4 = 0;\n\t\t\t\t\t/* while (true) { */ case 106:\n\t\t\t\t\t\t/* if (!(i$4 < $clone(f, reflect.Value).Len())) { break; } */ if(!(i$4 < $clone(f, reflect.Value).Len())) { $s = 107; continue; }\n\t\t\t\t\t\tif (i$4 > 0) {\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_r$21 = $clone(f, reflect.Value).Index(i$4); /* */ $s = 108; case 108: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }\n\t\t\t\t\t\t$r = p.printValue($clone(_r$21, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 109; case 109: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\ti$4 = i$4 + (1) >> 0;\n\t\t\t\t\t/* } */ $s = 106; continue; case 107:\n\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(93);\n\t\t\t\t/* } */ case 96:\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if (_1 === (22)) { */ case 21:\n\t\t\t\t/* */ if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { $s = 110; continue; }\n\t\t\t\t/* */ $s = 111; continue;\n\t\t\t\t/* if ((depth === 0) && !(($clone(f, reflect.Value).Pointer() === 0))) { */ case 110:\n\t\t\t\t\t\t_r$22 = $clone(f, reflect.Value).Elem(); /* */ $s = 113; case 113: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }\n\t\t\t\t\t\ta = _r$22;\n\t\t\t\t\t\t_4 = $clone(a, reflect.Value).Kind();\n\t\t\t\t\t\t/* */ if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { $s = 114; continue; }\n\t\t\t\t\t\t/* */ $s = 115; continue;\n\t\t\t\t\t\t/* if ((_4 === (17)) || (_4 === (23)) || (_4 === (25)) || (_4 === (21))) { */ case 114:\n\t\t\t\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(38);\n\t\t\t\t\t\t\t$r = p.printValue($clone(a, reflect.Value), verb, depth + 1 >> 0); /* */ $s = 116; case 116: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t\t\t\t$s = -1; return;\n\t\t\t\t\t\t/* } */ case 115:\n\t\t\t\t\tcase 112:\n\t\t\t\t/* } */ case 111:\n\t\t\t\t$r = p.fmtPointer($clone(f, reflect.Value), verb); /* */ $s = 117; case 117: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else if ((_1 === (18)) || (_1 === (19)) || (_1 === (26))) { */ case 22:\n\t\t\t\t$r = p.fmtPointer($clone(f, reflect.Value), verb); /* */ $s = 118; case 118: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t\t$s = 24; continue;\n\t\t\t/* } else { */ case 23:\n\t\t\t\t$r = p.unknownType($clone(f, reflect.Value)); /* */ $s = 119; case 119: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t/* } */ case 24:\n\t\tcase 7:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.printValue }; } $f.$ptr = $ptr; $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._arg = _arg; $f._arg$1 = _arg$1; $f._arg$2 = _arg$2; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$2 = _r$2; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f.a = a; $f.bytes = bytes; $f.depth = depth; $f.f = f; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.key = key; $f.keys = keys; $f.name = name; $f.p = p; $f.t = t; $f.value = value; $f.value$1 = value$1; $f.verb = verb; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.printValue = function(value, verb, depth) { return this.$val.printValue(value, verb, depth); };\n\tpp.ptr.prototype.doPrintln = function(a) {\n\t\tvar $ptr, _i, _ref, a, arg, argNum, p, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _i = $f._i; _ref = $f._ref; a = $f.a; arg = $f.arg; argNum = $f.argNum; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tp = this;\n\t\t_ref = a;\n\t\t_i = 0;\n\t\t/* while (true) { */ case 1:\n\t\t\t/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }\n\t\t\targNum = _i;\n\t\t\targ = ((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]);\n\t\t\tif (argNum > 0) {\n\t\t\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(32);\n\t\t\t}\n\t\t\t$r = p.printArg(arg, 118); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t\t_i++;\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t(p.$ptr_buf || (p.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, p))).WriteByte(10);\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: pp.ptr.prototype.doPrintln }; } $f.$ptr = $ptr; $f._i = _i; $f._ref = _ref; $f.a = a; $f.arg = arg; $f.argNum = argNum; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tpp.prototype.doPrintln = function(a) { return this.$val.doPrintln(a); };\n\tss.ptr.prototype.Read = function(buf) {\n\t\tvar $ptr, _tmp, _tmp$1, buf, err, n, s;\n\t\tn = 0;\n\t\terr = $ifaceNil;\n\t\ts = this;\n\t\t_tmp = 0;\n\t\t_tmp$1 = errors.New(\"ScanState's Read should not be called. Use ReadRune\");\n\t\tn = _tmp;\n\t\terr = _tmp$1;\n\t\treturn [n, err];\n\t};\n\tss.prototype.Read = function(buf) { return this.$val.Read(buf); };\n\tss.ptr.prototype.ReadRune = function() {\n\t\tvar $ptr, _r, _tuple, err, r, s, size, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; err = $f.err; r = $f.r; s = $f.s; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tr = 0;\n\t\tsize = 0;\n\t\terr = $ifaceNil;\n\t\ts = this;\n\t\tif (s.atEOF || s.count >= s.ssave.argLimit) {\n\t\t\terr = io.EOF;\n\t\t\t$s = -1; return [r, size, err];\n\t\t}\n\t\t_r = s.rs.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tr = _tuple[0];\n\t\tsize = _tuple[1];\n\t\terr = _tuple[2];\n\t\tif ($interfaceIsEqual(err, $ifaceNil)) {\n\t\t\ts.count = s.count + (1) >> 0;\n\t\t\tif (s.ssave.nlIsEnd && (r === 10)) {\n\t\t\t\ts.atEOF = true;\n\t\t\t}\n\t\t} else if ($interfaceIsEqual(err, io.EOF)) {\n\t\t\ts.atEOF = true;\n\t\t}\n\t\t$s = -1; return [r, size, err];\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.ReadRune }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.r = r; $f.s = s; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.ReadRune = function() { return this.$val.ReadRune(); };\n\tss.ptr.prototype.Width = function() {\n\t\tvar $ptr, _tmp, _tmp$1, _tmp$2, _tmp$3, ok, s, wid;\n\t\twid = 0;\n\t\tok = false;\n\t\ts = this;\n\t\tif (s.ssave.maxWid === 1073741824) {\n\t\t\t_tmp = 0;\n\t\t\t_tmp$1 = false;\n\t\t\twid = _tmp;\n\t\t\tok = _tmp$1;\n\t\t\treturn [wid, ok];\n\t\t}\n\t\t_tmp$2 = s.ssave.maxWid;\n\t\t_tmp$3 = true;\n\t\twid = _tmp$2;\n\t\tok = _tmp$3;\n\t\treturn [wid, ok];\n\t};\n\tss.prototype.Width = function() { return this.$val.Width(); };\n\tss.ptr.prototype.getRune = function() {\n\t\tvar $ptr, _r, _tuple, err, r, s, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _tuple = $f._tuple; err = $f.err; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\tr = 0;\n\t\ts = this;\n\t\t_r = s.ReadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_tuple = _r;\n\t\tr = _tuple[0];\n\t\terr = _tuple[2];\n\t\tif (!($interfaceIsEqual(err, $ifaceNil))) {\n\t\t\tif ($interfaceIsEqual(err, io.EOF)) {\n\t\t\t\tr = -1;\n\t\t\t\t$s = -1; return r;\n\t\t\t}\n\t\t\ts.error(err);\n\t\t}\n\t\t$s = -1; return r;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.getRune }; } $f.$ptr = $ptr; $f._r = _r; $f._tuple = _tuple; $f.err = err; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.getRune = function() { return this.$val.getRune(); };\n\tss.ptr.prototype.UnreadRune = function() {\n\t\tvar $ptr, _r, s, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ts = this;\n\t\t_r = s.rs.UnreadRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r;\n\t\ts.atEOF = false;\n\t\ts.count = s.count - (1) >> 0;\n\t\t$s = -1; return $ifaceNil;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.UnreadRune }; } $f.$ptr = $ptr; $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };\n\tss.ptr.prototype.error = function(err) {\n\t\tvar $ptr, err, s, x;\n\t\ts = this;\n\t\t$panic((x = new scanError.ptr(err), new x.constructor.elem(x)));\n\t};\n\tss.prototype.error = function(err) { return this.$val.error(err); };\n\tss.ptr.prototype.errorString = function(err) {\n\t\tvar $ptr, err, s, x;\n\t\ts = this;\n\t\t$panic((x = new scanError.ptr(errors.New(err)), new x.constructor.elem(x)));\n\t};\n\tss.prototype.errorString = function(err) { return this.$val.errorString(err); };\n\tss.ptr.prototype.Token = function(skipSpace, f) {\n\t\tvar $ptr, _r, err, f, s, skipSpace, tok, $s, $deferred, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; err = $f.err; f = $f.f; s = $f.s; skipSpace = $f.skipSpace; tok = $f.tok; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);\n\t\terr = [err];\n\t\ttok = sliceType$2.nil;\n\t\terr[0] = $ifaceNil;\n\t\ts = this;\n\t\t$deferred.push([(function(err) { return function() {\n\t\t\tvar $ptr, _tuple, e, ok, se;\n\t\t\te = $recover();\n\t\t\tif (!($interfaceIsEqual(e, $ifaceNil))) {\n\t\t\t\t_tuple = $assertType(e, scanError, true);\n\t\t\t\tse = $clone(_tuple[0], scanError);\n\t\t\t\tok = _tuple[1];\n\t\t\t\tif (ok) {\n\t\t\t\t\terr[0] = se.err;\n\t\t\t\t} else {\n\t\t\t\t\t$panic(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}; })(err), []]);\n\t\tif (f === $throwNilPointerError) {\n\t\t\tf = notSpace;\n\t\t}\n\t\ts.buf = $subslice(s.buf, 0, 0);\n\t\t_r = s.token(skipSpace, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\ttok = _r;\n\t\t$s = -1; return [tok, err[0]];\n\t\t/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if (!$curGoroutine.asleep) { return  [tok, err[0]]; } if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: ss.ptr.prototype.Token }; } $f.$ptr = $ptr; $f._r = _r; $f.err = err; $f.f = f; $f.s = s; $f.skipSpace = skipSpace; $f.tok = tok; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }\n\t};\n\tss.prototype.Token = function(skipSpace, f) { return this.$val.Token(skipSpace, f); };\n\tisSpace = function(r) {\n\t\tvar $ptr, _i, _ref, r, rng, rx;\n\t\tif (r >= 65536) {\n\t\t\treturn false;\n\t\t}\n\t\trx = (r << 16 >>> 16);\n\t\t_ref = space;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.$length)) { break; }\n\t\t\trng = $clone(((_i < 0 || _i >= _ref.$length) ? $throwRuntimeError(\"index out of range\") : _ref.$array[_ref.$offset + _i]), arrayType$1);\n\t\t\tif (rx < rng[0]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (rx <= rng[1]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t_i++;\n\t\t}\n\t\treturn false;\n\t};\n\tnotSpace = function(r) {\n\t\tvar $ptr, r;\n\t\treturn !isSpace(r);\n\t};\n\tss.ptr.prototype.SkipSpace = function() {\n\t\tvar $ptr, s, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ts = this;\n\t\t$r = s.skipSpace(false); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.SkipSpace }; } $f.$ptr = $ptr; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.SkipSpace = function() { return this.$val.SkipSpace(); };\n\tss.ptr.prototype.free = function(old) {\n\t\tvar $ptr, old, s;\n\t\ts = this;\n\t\tif (old.validSave) {\n\t\t\tssave.copy(s.ssave, old);\n\t\t\treturn;\n\t\t}\n\t\tif (s.buf.$capacity > 1024) {\n\t\t\treturn;\n\t\t}\n\t\ts.buf = $subslice(s.buf, 0, 0);\n\t\ts.rs = $ifaceNil;\n\t\tssFree.Put(s);\n\t};\n\tss.prototype.free = function(old) { return this.$val.free(old); };\n\tss.ptr.prototype.skipSpace = function(stopAtNewline) {\n\t\tvar $ptr, _r, _r$1, _r$2, _v, r, s, stopAtNewline, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _v = $f._v; r = $f.r; s = $f.s; stopAtNewline = $f.stopAtNewline; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ts = this;\n\t\t/* while (true) { */ case 1:\n\t\t\t_r = s.getRune(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tr = _r;\n\t\t\tif (r === -1) {\n\t\t\t\t$s = -1; return;\n\t\t\t}\n\t\t\tif (!(r === 13)) { _v = false; $s = 6; continue s; }\n\t\t\t_r$1 = s.peek(\"\\n\"); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t_v = _r$1; case 6:\n\t\t\t/* */ if (_v) { $s = 4; continue; }\n\t\t\t/* */ $s = 5; continue;\n\t\t\t/* if (_v) { */ case 4:\n\t\t\t\t/* continue; */ $s = 1; continue;\n\t\t\t/* } */ case 5:\n\t\t\t/* */ if (r === 10) { $s = 8; continue; }\n\t\t\t/* */ $s = 9; continue;\n\t\t\t/* if (r === 10) { */ case 8:\n\t\t\t\tif (stopAtNewline) {\n\t\t\t\t\t/* break; */ $s = 2; continue;\n\t\t\t\t}\n\t\t\t\tif (s.ssave.nlIsSpace) {\n\t\t\t\t\t/* continue; */ $s = 1; continue;\n\t\t\t\t}\n\t\t\t\ts.errorString(\"unexpected newline\");\n\t\t\t\t$s = -1; return;\n\t\t\t/* } */ case 9:\n\t\t\t/* */ if (!isSpace(r)) { $s = 10; continue; }\n\t\t\t/* */ $s = 11; continue;\n\t\t\t/* if (!isSpace(r)) { */ case 10:\n\t\t\t\t_r$2 = s.UnreadRune(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_r$2;\n\t\t\t\t/* break; */ $s = 2; continue;\n\t\t\t/* } */ case 11:\n\t\t/* } */ $s = 1; continue; case 2:\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.skipSpace }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._v = _v; $f.r = r; $f.s = s; $f.stopAtNewline = stopAtNewline; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.skipSpace = function(stopAtNewline) { return this.$val.skipSpace(stopAtNewline); };\n\tss.ptr.prototype.token = function(skipSpace, f) {\n\t\tvar $ptr, _r, _r$1, _r$2, f, r, s, skipSpace, x, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; f = $f.f; r = $f.r; s = $f.s; skipSpace = $f.skipSpace; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ts = this;\n\t\t/* */ if (skipSpace) { $s = 1; continue; }\n\t\t/* */ $s = 2; continue;\n\t\t/* if (skipSpace) { */ case 1:\n\t\t\t$r = s.skipSpace(false); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t/* } */ case 2:\n\t\t/* while (true) { */ case 4:\n\t\t\t_r = s.getRune(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t\tr = _r;\n\t\t\tif (r === -1) {\n\t\t\t\t/* break; */ $s = 5; continue;\n\t\t\t}\n\t\t\t_r$1 = f(r); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t/* */ if (!_r$1) { $s = 7; continue; }\n\t\t\t/* */ $s = 8; continue;\n\t\t\t/* if (!_r$1) { */ case 7:\n\t\t\t\t_r$2 = s.UnreadRune(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }\n\t\t\t\t_r$2;\n\t\t\t\t/* break; */ $s = 5; continue;\n\t\t\t/* } */ case 8:\n\t\t\t(s.$ptr_buf || (s.$ptr_buf = new ptrType$1(function() { return this.$target.buf; }, function($v) { this.$target.buf = $v; }, s))).WriteRune(r);\n\t\t/* } */ $s = 4; continue; case 5:\n\t\t$s = -1; return (x = s.buf, $subslice(new sliceType$2(x.$array), x.$offset, x.$offset + x.$length));\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.token }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.f = f; $f.r = r; $f.s = s; $f.skipSpace = skipSpace; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.token = function(skipSpace, f) { return this.$val.token(skipSpace, f); };\n\tindexRune = function(s, r) {\n\t\tvar $ptr, _i, _ref, _rune, c, i, r, s;\n\t\t_ref = s;\n\t\t_i = 0;\n\t\twhile (true) {\n\t\t\tif (!(_i < _ref.length)) { break; }\n\t\t\t_rune = $decodeRune(_ref, _i);\n\t\t\ti = _i;\n\t\t\tc = _rune[0];\n\t\t\tif (c === r) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\t_i += _rune[1];\n\t\t}\n\t\treturn -1;\n\t};\n\tss.ptr.prototype.peek = function(ok) {\n\t\tvar $ptr, _r, _r$1, ok, r, s, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; _r$1 = $f._r$1; ok = $f.ok; r = $f.r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\ts = this;\n\t\t_r = s.getRune(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\tr = _r;\n\t\t/* */ if (!((r === -1))) { $s = 2; continue; }\n\t\t/* */ $s = 3; continue;\n\t\t/* if (!((r === -1))) { */ case 2:\n\t\t\t_r$1 = s.UnreadRune(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }\n\t\t\t_r$1;\n\t\t/* } */ case 3:\n\t\t$s = -1; return indexRune(ok, r) >= 0;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: ss.ptr.prototype.peek }; } $f.$ptr = $ptr; $f._r = _r; $f._r$1 = _r$1; $f.ok = ok; $f.r = r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\tss.prototype.peek = function(ok) { return this.$val.peek(ok); };\n\tptrType$25.methods = [{prop: \"clearflags\", name: \"clearflags\", pkg: \"fmt\", typ: $funcType([], [], false)}, {prop: \"init\", name: \"init\", pkg: \"fmt\", typ: $funcType([ptrType$1], [], false)}, {prop: \"writePadding\", name: \"writePadding\", pkg: \"fmt\", typ: $funcType([$Int], [], false)}, {prop: \"pad\", name: \"pad\", pkg: \"fmt\", typ: $funcType([sliceType$2], [], false)}, {prop: \"padString\", name: \"padString\", pkg: \"fmt\", typ: $funcType([$String], [], false)}, {prop: \"fmt_boolean\", name: \"fmt_boolean\", pkg: \"fmt\", typ: $funcType([$Bool], [], false)}, {prop: \"fmt_unicode\", name: \"fmt_unicode\", pkg: \"fmt\", typ: $funcType([$Uint64], [], false)}, {prop: \"fmt_integer\", name: \"fmt_integer\", pkg: \"fmt\", typ: $funcType([$Uint64, $Int, $Bool, $String], [], false)}, {prop: \"truncate\", name: \"truncate\", pkg: \"fmt\", typ: $funcType([$String], [$String], false)}, {prop: \"fmt_s\", name: \"fmt_s\", pkg: \"fmt\", typ: $funcType([$String], [], false)}, {prop: \"fmt_sbx\", name: \"fmt_sbx\", pkg: \"fmt\", typ: $funcType([$String, sliceType$2, $String], [], false)}, {prop: \"fmt_sx\", name: \"fmt_sx\", pkg: \"fmt\", typ: $funcType([$String, $String], [], false)}, {prop: \"fmt_bx\", name: \"fmt_bx\", pkg: \"fmt\", typ: $funcType([sliceType$2, $String], [], false)}, {prop: \"fmt_q\", name: \"fmt_q\", pkg: \"fmt\", typ: $funcType([$String], [], false)}, {prop: \"fmt_c\", name: \"fmt_c\", pkg: \"fmt\", typ: $funcType([$Uint64], [], false)}, {prop: \"fmt_qc\", name: \"fmt_qc\", pkg: \"fmt\", typ: $funcType([$Uint64], [], false)}, {prop: \"fmt_float\", name: \"fmt_float\", pkg: \"fmt\", typ: $funcType([$Float64, $Int, $Int32, $Int], [], false)}];\n\tptrType$1.methods = [{prop: \"Write\", name: \"Write\", pkg: \"\", typ: $funcType([sliceType$2], [], false)}, {prop: \"WriteString\", name: \"WriteString\", pkg: \"\", typ: $funcType([$String], [], false)}, {prop: \"WriteByte\", name: \"WriteByte\", pkg: \"\", typ: $funcType([$Uint8], [], false)}, {prop: \"WriteRune\", name: \"WriteRune\", pkg: \"\", typ: $funcType([$Int32], [], false)}];\n\tptrType$2.methods = [{prop: \"free\", name: \"free\", pkg: \"fmt\", typ: $funcType([], [], false)}, {prop: \"Width\", name: \"Width\", pkg: \"\", typ: $funcType([], [$Int, $Bool], false)}, {prop: \"Precision\", name: \"Precision\", pkg: \"\", typ: $funcType([], [$Int, $Bool], false)}, {prop: \"Flag\", name: \"Flag\", pkg: \"\", typ: $funcType([$Int], [$Bool], false)}, {prop: \"Write\", name: \"Write\", pkg: \"\", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: \"unknownType\", name: \"unknownType\", pkg: \"fmt\", typ: $funcType([reflect.Value], [], false)}, {prop: \"badVerb\", name: \"badVerb\", pkg: \"fmt\", typ: $funcType([$Int32], [], false)}, {prop: \"fmtBool\", name: \"fmtBool\", pkg: \"fmt\", typ: $funcType([$Bool, $Int32], [], false)}, {prop: \"fmt0x64\", name: \"fmt0x64\", pkg: \"fmt\", typ: $funcType([$Uint64, $Bool], [], false)}, {prop: \"fmtInteger\", name: \"fmtInteger\", pkg: \"fmt\", typ: $funcType([$Uint64, $Bool, $Int32], [], false)}, {prop: \"fmtFloat\", name: \"fmtFloat\", pkg: \"fmt\", typ: $funcType([$Float64, $Int, $Int32], [], false)}, {prop: \"fmtComplex\", name: \"fmtComplex\", pkg: \"fmt\", typ: $funcType([$Complex128, $Int, $Int32], [], false)}, {prop: \"fmtString\", name: \"fmtString\", pkg: \"fmt\", typ: $funcType([$String, $Int32], [], false)}, {prop: \"fmtBytes\", name: \"fmtBytes\", pkg: \"fmt\", typ: $funcType([sliceType$2, $Int32, $String], [], false)}, {prop: \"fmtPointer\", name: \"fmtPointer\", pkg: \"fmt\", typ: $funcType([reflect.Value, $Int32], [], false)}, {prop: \"catchPanic\", name: \"catchPanic\", pkg: \"fmt\", typ: $funcType([$emptyInterface, $Int32], [], false)}, {prop: \"handleMethods\", name: \"handleMethods\", pkg: \"fmt\", typ: $funcType([$Int32], [$Bool], false)}, {prop: \"printArg\", name: \"printArg\", pkg: \"fmt\", typ: $funcType([$emptyInterface, $Int32], [], false)}, {prop: \"printValue\", name: \"printValue\", pkg: \"fmt\", typ: $funcType([reflect.Value, $Int32, $Int], [], false)}, {prop: \"argNumber\", name: \"argNumber\", pkg: \"fmt\", typ: $funcType([$Int, $String, $Int, $Int], [$Int, $Int, $Bool], false)}, {prop: \"badArgNum\", name: \"badArgNum\", pkg: \"fmt\", typ: $funcType([$Int32], [], false)}, {prop: \"missingArg\", name: \"missingArg\", pkg: \"fmt\", typ: $funcType([$Int32], [], false)}, {prop: \"doPrintf\", name: \"doPrintf\", pkg: \"fmt\", typ: $funcType([$String, sliceType], [], false)}, {prop: \"doPrint\", name: \"doPrint\", pkg: \"fmt\", typ: $funcType([sliceType], [], false)}, {prop: \"doPrintln\", name: \"doPrintln\", pkg: \"fmt\", typ: $funcType([sliceType], [], false)}];\n\tptrType$5.methods = [{prop: \"Read\", name: \"Read\", pkg: \"\", typ: $funcType([sliceType$2], [$Int, $error], false)}, {prop: \"ReadRune\", name: \"ReadRune\", pkg: \"\", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: \"Width\", name: \"Width\", pkg: \"\", typ: $funcType([], [$Int, $Bool], false)}, {prop: \"getRune\", name: \"getRune\", pkg: \"fmt\", typ: $funcType([], [$Int32], false)}, {prop: \"mustReadRune\", name: \"mustReadRune\", pkg: \"fmt\", typ: $funcType([], [$Int32], false)}, {prop: \"UnreadRune\", name: \"UnreadRune\", pkg: \"\", typ: $funcType([], [$error], false)}, {prop: \"error\", name: \"error\", pkg: \"fmt\", typ: $funcType([$error], [], false)}, {prop: \"errorString\", name: \"errorString\", pkg: \"fmt\", typ: $funcType([$String], [], false)}, {prop: \"Token\", name: \"Token\", pkg: \"\", typ: $funcType([$Bool, funcType], [sliceType$2, $error], false)}, {prop: \"SkipSpace\", name: \"SkipSpace\", pkg: \"\", typ: $funcType([], [], false)}, {prop: \"free\", name: \"free\", pkg: \"fmt\", typ: $funcType([ssave], [], false)}, {prop: \"skipSpace\", name: \"skipSpace\", pkg: \"fmt\", typ: $funcType([$Bool], [], false)}, {prop: \"token\", name: \"token\", pkg: \"fmt\", typ: $funcType([$Bool, funcType], [sliceType$2], false)}, {prop: \"consume\", name: \"consume\", pkg: \"fmt\", typ: $funcType([$String, $Bool], [$Bool], false)}, {prop: \"peek\", name: \"peek\", pkg: \"fmt\", typ: $funcType([$String], [$Bool], false)}, {prop: \"notEOF\", name: \"notEOF\", pkg: \"fmt\", typ: $funcType([], [], false)}, {prop: \"accept\", name: \"accept\", pkg: \"fmt\", typ: $funcType([$String], [$Bool], false)}, {prop: \"okVerb\", name: \"okVerb\", pkg: \"fmt\", typ: $funcType([$Int32, $String, $String], [$Bool], false)}, {prop: \"scanBool\", name: \"scanBool\", pkg: \"fmt\", typ: $funcType([$Int32], [$Bool], false)}, {prop: \"getBase\", name: \"getBase\", pkg: \"fmt\", typ: $funcType([$Int32], [$Int, $String], false)}, {prop: \"scanNumber\", name: \"scanNumber\", pkg: \"fmt\", typ: $funcType([$String, $Bool], [$String], false)}, {prop: \"scanRune\", name: \"scanRune\", pkg: \"fmt\", typ: $funcType([$Int], [$Int64], false)}, {prop: \"scanBasePrefix\", name: \"scanBasePrefix\", pkg: \"fmt\", typ: $funcType([], [$Int, $String, $Bool], false)}, {prop: \"scanInt\", name: \"scanInt\", pkg: \"fmt\", typ: $funcType([$Int32, $Int], [$Int64], false)}, {prop: \"scanUint\", name: \"scanUint\", pkg: \"fmt\", typ: $funcType([$Int32, $Int], [$Uint64], false)}, {prop: \"floatToken\", name: \"floatToken\", pkg: \"fmt\", typ: $funcType([], [$String], false)}, {prop: \"complexTokens\", name: \"complexTokens\", pkg: \"fmt\", typ: $funcType([], [$String, $String], false)}, {prop: \"convertFloat\", name: \"convertFloat\", pkg: \"fmt\", typ: $funcType([$String, $Int], [$Float64], false)}, {prop: \"scanComplex\", name: \"scanComplex\", pkg: \"fmt\", typ: $funcType([$Int32, $Int], [$Complex128], false)}, {prop: \"convertString\", name: \"convertString\", pkg: \"fmt\", typ: $funcType([$Int32], [$String], false)}, {prop: \"quotedString\", name: \"quotedString\", pkg: \"fmt\", typ: $funcType([], [$String], false)}, {prop: \"hexByte\", name: \"hexByte\", pkg: \"fmt\", typ: $funcType([], [$Uint8, $Bool], false)}, {prop: \"hexString\", name: \"hexString\", pkg: \"fmt\", typ: $funcType([], [$String], false)}, {prop: \"scanOne\", name: \"scanOne\", pkg: \"fmt\", typ: $funcType([$Int32, $emptyInterface], [], false)}, {prop: \"doScan\", name: \"doScan\", pkg: \"fmt\", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: \"advance\", name: \"advance\", pkg: \"fmt\", typ: $funcType([$String], [$Int], false)}, {prop: \"doScanf\", name: \"doScanf\", pkg: \"fmt\", typ: $funcType([$String, sliceType], [$Int, $error], false)}];\n\tfmtFlags.init(\"fmt\", [{prop: \"widPresent\", name: \"widPresent\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"precPresent\", name: \"precPresent\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"minus\", name: \"minus\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"plus\", name: \"plus\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"sharp\", name: \"sharp\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"space\", name: \"space\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"zero\", name: \"zero\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"plusV\", name: \"plusV\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"sharpV\", name: \"sharpV\", exported: false, typ: $Bool, tag: \"\"}]);\n\tfmt.init(\"fmt\", [{prop: \"buf\", name: \"buf\", exported: false, typ: ptrType$1, tag: \"\"}, {prop: \"fmtFlags\", name: \"\", exported: false, typ: fmtFlags, tag: \"\"}, {prop: \"wid\", name: \"wid\", exported: false, typ: $Int, tag: \"\"}, {prop: \"prec\", name: \"prec\", exported: false, typ: $Int, tag: \"\"}, {prop: \"intbuf\", name: \"intbuf\", exported: false, typ: arrayType, tag: \"\"}]);\n\tState.init([{prop: \"Flag\", name: \"Flag\", pkg: \"\", typ: $funcType([$Int], [$Bool], false)}, {prop: \"Precision\", name: \"Precision\", pkg: \"\", typ: $funcType([], [$Int, $Bool], false)}, {prop: \"Width\", name: \"Width\", pkg: \"\", typ: $funcType([], [$Int, $Bool], false)}, {prop: \"Write\", name: \"Write\", pkg: \"\", typ: $funcType([sliceType$2], [$Int, $error], false)}]);\n\tFormatter.init([{prop: \"Format\", name: \"Format\", pkg: \"\", typ: $funcType([State, $Int32], [], false)}]);\n\tStringer.init([{prop: \"String\", name: \"String\", pkg: \"\", typ: $funcType([], [$String], false)}]);\n\tGoStringer.init([{prop: \"GoString\", name: \"GoString\", pkg: \"\", typ: $funcType([], [$String], false)}]);\n\tbuffer.init($Uint8);\n\tpp.init(\"fmt\", [{prop: \"buf\", name: \"buf\", exported: false, typ: buffer, tag: \"\"}, {prop: \"arg\", name: \"arg\", exported: false, typ: $emptyInterface, tag: \"\"}, {prop: \"value\", name: \"value\", exported: false, typ: reflect.Value, tag: \"\"}, {prop: \"fmt\", name: \"fmt\", exported: false, typ: fmt, tag: \"\"}, {prop: \"reordered\", name: \"reordered\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"goodArgNum\", name: \"goodArgNum\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"panicking\", name: \"panicking\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"erroring\", name: \"erroring\", exported: false, typ: $Bool, tag: \"\"}]);\n\tscanError.init(\"fmt\", [{prop: \"err\", name: \"err\", exported: false, typ: $error, tag: \"\"}]);\n\tss.init(\"fmt\", [{prop: \"rs\", name: \"rs\", exported: false, typ: io.RuneScanner, tag: \"\"}, {prop: \"buf\", name: \"buf\", exported: false, typ: buffer, tag: \"\"}, {prop: \"count\", name: \"count\", exported: false, typ: $Int, tag: \"\"}, {prop: \"atEOF\", name: \"atEOF\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"ssave\", name: \"\", exported: false, typ: ssave, tag: \"\"}]);\n\tssave.init(\"fmt\", [{prop: \"validSave\", name: \"validSave\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"nlIsEnd\", name: \"nlIsEnd\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"nlIsSpace\", name: \"nlIsSpace\", exported: false, typ: $Bool, tag: \"\"}, {prop: \"argLimit\", name: \"argLimit\", exported: false, typ: $Int, tag: \"\"}, {prop: \"limit\", name: \"limit\", exported: false, typ: $Int, tag: \"\"}, {prop: \"maxWid\", name: \"maxWid\", exported: false, typ: $Int, tag: \"\"}]);\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = os.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = reflect.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = sync.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tppFree = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {\n\t\t\tvar $ptr;\n\t\t\treturn new pp.ptr(buffer.nil, $ifaceNil, new reflect.Value.ptr(ptrType.nil, 0, 0), new fmt.ptr(ptrType$1.nil, new fmtFlags.ptr(false, false, false, false, false, false, false, false, false), 0, 0, arrayType.zero()), false, false, false, false);\n\t\t}));\n\t\tbyteType = reflect.TypeOf(new $Uint8(0));\n\t\tspace = new sliceType$1([$toNativeArray($kindUint16, [9, 13]), $toNativeArray($kindUint16, [32, 32]), $toNativeArray($kindUint16, [133, 133]), $toNativeArray($kindUint16, [160, 160]), $toNativeArray($kindUint16, [5760, 5760]), $toNativeArray($kindUint16, [8192, 8202]), $toNativeArray($kindUint16, [8232, 8233]), $toNativeArray($kindUint16, [8239, 8239]), $toNativeArray($kindUint16, [8287, 8287]), $toNativeArray($kindUint16, [12288, 12288])]);\n\t\tssFree = new sync.Pool.ptr(0, 0, sliceType.nil, (function() {\n\t\t\tvar $ptr;\n\t\t\treturn new ss.ptr($ifaceNil, buffer.nil, 0, false, new ssave.ptr(false, false, false, 0, 0, 0));\n\t\t}));\n\t\tcomplexError = errors.New(\"syntax error scanning complex number\");\n\t\tboolError = errors.New(\"syntax error scanning boolean\");\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$packages[\".\"] = (function() {\n\tvar $pkg = {}, $init, fmt, js, funcType, mapType, sliceType, main, Main;\n\tfmt = $packages[\"fmt\"];\n\tjs = $packages[\"github.com/gopherjs/gopherjs/js\"];\n\tfuncType = $funcType([], [], false);\n\tmapType = $mapType($String, $emptyInterface);\n\tsliceType = $sliceType($emptyInterface);\n\tmain = function() {\n\t\tvar $ptr;\n\t\t$module.exports = $externalize($makeMap($String.keyFor, [{ k: \"main\", v: new funcType(Main) }]), mapType);\n\t};\n\tMain = function() {\n\t\tvar $ptr, _r, $s, $r;\n\t\t/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $ptr = $f.$ptr; _r = $f._r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t_r = fmt.Println(new sliceType([new $String(\"Hello, World\")])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }\n\t\t_r;\n\t\t$s = -1; return;\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: Main }; } $f.$ptr = $ptr; $f._r = _r; $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.Main = Main;\n\t$init = function() {\n\t\t$pkg.$init = function() {};\n\t\t/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:\n\t\t$r = fmt.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\t$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }\n\t\tif ($pkg === $mainPkg) {\n\t\t\tmain();\n\t\t\t$mainFinished = true;\n\t\t}\n\t\t/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;\n\t};\n\t$pkg.$init = $init;\n\treturn $pkg;\n})();\n$synthesizeMethods();\nvar $mainPkg = $packages[\".\"];\n$packages[\"runtime\"].$init();\n$go($mainPkg.$init, [], true);\n$flushConsole();\n\n}).call(this);\n//# sourceMappingURL=a.js.map\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(2)(module)))\n\n//////////////////\n// WEBPACK FOOTER\n// ./app.go\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./app.go?");

/***/ })
/******/ ]);